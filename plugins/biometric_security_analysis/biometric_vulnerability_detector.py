"""
Biometric Vulnerability Detector

Analyzes static and dynamic findings to identify biometric authentication vulnerabilities.
Generates comprehensive vulnerability reports with evidence and recommendations.
"""

import logging
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class BiometricVulnerabilityType(Enum):
    """Types of biometric vulnerabilities."""
    BIOMETRIC_BYPASS = "biometric_bypass"
    WEAK_BIOMETRIC_IMPLEMENTATION = "weak_biometric_implementation"
    INSECURE_FALLBACK = "insecure_fallback"
    BIOMETRIC_TEMPLATE_SECURITY = "biometric_template_security"
    AUTH_STATE_MANIPULATION = "auth_state_manipulation"
    DEPRECATED_API_USAGE = "deprecated_api_usage"
    CRYPTO_OBJECT_BYPASS = "crypto_object_bypass"

class BiometricSeverityLevel(Enum):
    """Severity levels for biometric vulnerabilities."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

@dataclass
class BiometricVulnerability:
    """Represents a biometric security vulnerability."""
    vuln_type: BiometricVulnerabilityType
    severity: BiometricSeverityLevel
    title: str
    description: str
    evidence: Dict[str, Any]
    confidence: float
    cwe_id: str
    masvs_control: str
    recommendations: List[str]
    affected_components: List[str]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary format."""
        return {
            "type": self.vuln_type.value,
            "severity": self.severity.value,
            "title": self.title,
            "description": self.description,
            "evidence": self.evidence,
            "confidence": self.confidence,
            "cwe_id": self.cwe_id,
            "masvs_control": self.masvs_control,
            "recommendations": self.recommendations,
            "affected_components": self.affected_components
        }

class BiometricVulnerabilityDetector:
    """Detector for biometric authentication vulnerabilities."""
    
    def __init__(self):
        """Initialize the vulnerability detector."""
        self.logger = logger
        
        # Vulnerability patterns and their characteristics
        self.vulnerability_patterns = {
            BiometricVulnerabilityType.BIOMETRIC_BYPASS: {
                "static_patterns": [
                    "auth.*bypass",
                    "biometric.*skip",
                    "force.*auth.*success"
                ],
                "dynamic_indicators": ["auth_bypass", "state_manipulation", "direct_auth_write"],
                "severity": BiometricSeverityLevel.HIGH,
                "cwe_id": "CWE-287",
                "masvs_control": "MASVS-AUTH-2"
            },
            BiometricVulnerabilityType.WEAK_BIOMETRIC_IMPLEMENTATION: {
                "static_patterns": [
                    "authenticate.*null",
                    "BiometricPrompt.*null",
                    "FingerprintManager"
                ],
                "dynamic_indicators": ["no_crypto_object", "deprecated_api", "weak_implementation"],
                "severity": BiometricSeverityLevel.HIGH,
                "cwe_id": "CWE-303",
                "masvs_control": "MASVS-AUTH-2"
            },
            BiometricVulnerabilityType.INSECURE_FALLBACK: {
                "static_patterns": [
                    "fallback.*password",
                    "backup.*auth",
                    "simple.*pin"
                ],
                "dynamic_indicators": ["weak_fallback", "fallback_bypass"],
                "severity": BiometricSeverityLevel.MEDIUM,
                "cwe_id": "CWE-287",
                "masvs_control": "MASVS-AUTH-2"
            },
            BiometricVulnerabilityType.AUTH_STATE_MANIPULATION: {
                "static_patterns": [
                    "SharedPreferences.*auth",
                    "putBoolean.*auth.*true",
                    "auth.*state.*file"
                ],
                "dynamic_indicators": ["insecure_storage", "state_manipulation"],
                "severity": BiometricSeverityLevel.MEDIUM,
                "cwe_id": "CWE-798",
                "masvs_control": "MASVS-STORAGE-1"
            },
            BiometricVulnerabilityType.CRYPTO_OBJECT_BYPASS: {
                "static_patterns": [
                    "authenticate.*null.*crypto",
                    "CryptoObject.*null",
                    "cipher.*null"
                ],
                "dynamic_indicators": ["null_crypto_object", "crypto_bypass"],
                "severity": BiometricSeverityLevel.HIGH,
                "cwe_id": "CWE-327",
                "masvs_control": "MASVS-CRYPTO-1"
            }
        }
    
    def detect_biometric_vulnerabilities(self, static_results: Dict[str, Any], 
                                        dynamic_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Detect biometric vulnerabilities from static and dynamic analysis results.
        
        Args:
            static_results: Results from static analysis
            dynamic_results: Results from dynamic analysis
            
        Returns:
            List of detected vulnerabilities
        """
        try:
            self.logger.info("Starting biometric vulnerability detection")
            
            vulnerabilities = []
            
            # Analyze static findings
            static_vulns = self._analyze_static_findings(static_results)
            vulnerabilities.extend(static_vulns)
            
            # Analyze dynamic findings
            dynamic_vulns = self._analyze_dynamic_findings(dynamic_results)
            vulnerabilities.extend(dynamic_vulns)
            
            # Cross-reference static and dynamic findings
            correlated_vulns = self._correlate_findings(static_results, dynamic_results)
            vulnerabilities.extend(correlated_vulns)
            
            # Deduplicate and prioritize vulnerabilities
            final_vulnerabilities = self._deduplicate_vulnerabilities(vulnerabilities)
            
            self.logger.info(f"Biometric vulnerability detection completed: {len(final_vulnerabilities)} vulnerabilities found")
            return [v.to_dict() for v in final_vulnerabilities]
            
        except Exception as e:
            self.logger.error(f"Biometric vulnerability detection failed: {e}")
            return []
    
    def _analyze_static_findings(self, static_results: Dict[str, Any]) -> List[BiometricVulnerability]:
        """Analyze static analysis results for vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Check for deprecated API usage
            apis = static_results.get("apis_detected", [])
            for api in apis:
                if hasattr(api, 'deprecated') and api.deprecated:
                    vulnerability = BiometricVulnerability(
                        vuln_type=BiometricVulnerabilityType.DEPRECATED_API_USAGE,
                        severity=BiometricSeverityLevel.MEDIUM,
                        title="Deprecated Biometric API Usage",
                        description=f"Application uses deprecated {api.api_type} instead of modern BiometricPrompt",
                        evidence={
                            "api_type": api.api_type,
                            "class_name": api.class_name,
                            "methods_used": api.methods_used,
                            "deprecated": api.deprecated
                        },
                        confidence=0.9,
                        cwe_id="CWE-477",
                        masvs_control="MASVS-AUTH-2",
                        recommendations=[
                            "Migrate from FingerprintManager to androidx.biometric.BiometricPrompt",
                            "Update biometric implementation to use modern APIs",
                            "Follow Android biometric authentication best practices"
                        ],
                        affected_components=["Biometric Authentication", api.api_type]
                    )
                    vulnerabilities.append(vulnerability)
            
            # Check for missing CryptoObject usage
            if not static_results.get("uses_crypto_object", False) and static_results.get("apis_found", 0) > 0:
                vulnerability = BiometricVulnerability(
                    vuln_type=BiometricVulnerabilityType.WEAK_BIOMETRIC_IMPLEMENTATION,
                    severity=BiometricSeverityLevel.HIGH,
                    title="Biometric Authentication Without CryptoObject",
                    description="Biometric authentication implemented without CryptoObject for cryptographic operations",
                    evidence={
                        "uses_crypto_object": False,
                        "apis_found": static_results.get("apis_found", 0),
                        "security_risk": "Authentication can be bypassed without cryptographic validation"
                    },
                    confidence=0.8,
                    cwe_id="CWE-303",
                    masvs_control="MASVS-AUTH-2",
                    recommendations=[
                        "Implement CryptoObject for biometric authentication",
                        "Use cryptographic operations to validate authentication",
                        "Bind authentication to cryptographic operations"
                    ],
                    affected_components=["Biometric Authentication", "Cryptography"]
                )
                vulnerabilities.append(vulnerability)
            
            # Analyze security patterns from static code analysis
            patterns = static_results.get("security_patterns", [])
            for pattern in patterns:
                vuln_type = self._determine_vulnerability_type_from_pattern(pattern)
                if vuln_type:
                    vulnerability = self._create_vulnerability_from_pattern(pattern, vuln_type)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
            
            # Check for high-risk authentication patterns
            security_assessment = static_results.get("security_assessment", {})
            if security_assessment.get("potential_vulnerabilities", 0) > 2:
                vulnerability = BiometricVulnerability(
                    vuln_type=BiometricVulnerabilityType.WEAK_BIOMETRIC_IMPLEMENTATION,
                    severity=BiometricSeverityLevel.MEDIUM,
                    title="Multiple Biometric Security Issues",
                    description=f"Multiple potential biometric vulnerabilities detected: {security_assessment.get('potential_vulnerabilities', 0)}",
                    evidence={
                        "vulnerability_count": security_assessment.get("potential_vulnerabilities", 0),
                        "risk_factors": security_assessment.get("risk_factors", []),
                        "risk_level": security_assessment.get("risk_level", "UNKNOWN")
                    },
                    confidence=0.6,
                    cwe_id="CWE-287",
                    masvs_control="MASVS-AUTH-2",
                    recommendations=[
                        "Review biometric authentication implementation",
                        "Address identified security patterns",
                        "Implement comprehensive authentication validation"
                    ],
                    affected_components=["Biometric Authentication"]
                )
                vulnerabilities.append(vulnerability)
        
        except Exception as e:
            self.logger.error(f"Static findings analysis failed: {e}")
        
        return vulnerabilities
    
    def _analyze_dynamic_findings(self, dynamic_results: Dict[str, Any]) -> List[BiometricVulnerability]:
        """Analyze dynamic analysis results for vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Analyze bypass attempts
            bypass_attempts = dynamic_results.get("bypass_attempts", [])
            for bypass_attempt in bypass_attempts:
                vuln_type = self._determine_vulnerability_type_from_bypass(bypass_attempt)
                severity = self._determine_severity_from_bypass(bypass_attempt)
                
                vulnerability = BiometricVulnerability(
                    vuln_type=vuln_type,
                    severity=severity,
                    title=f"Biometric Authentication Bypass Detected",
                    description=f"Runtime analysis detected bypass attempt: {bypass_attempt.get('bypass_reason', 'Unknown')}",
                    evidence={
                        "bypass_event": bypass_attempt.get("event", ""),
                        "api_type": bypass_attempt.get("api_type", ""),
                        "bypass_reason": bypass_attempt.get("bypass_reason", ""),
                        "timestamp": bypass_attempt.get("timestamp", 0)
                    },
                    confidence=0.9,
                    cwe_id=self.vulnerability_patterns[vuln_type]["cwe_id"],
                    masvs_control=self.vulnerability_patterns[vuln_type]["masvs_control"],
                    recommendations=self._get_recommendations_for_type(vuln_type),
                    affected_components=["Biometric Authentication", bypass_attempt.get("api_type", "Unknown")]
                )
                vulnerabilities.append(vulnerability)
            
            # Analyze runtime vulnerability detections
            vuln_detections = dynamic_results.get("vulnerability_detections", [])
            for detection in vuln_detections:
                if detection.get("type") == "biometric_vulnerability":
                    vuln_type_str = detection.get("subtype", "biometric_bypass")
                    vuln_type = BiometricVulnerabilityType(vuln_type_str)
                    
                    vulnerability = BiometricVulnerability(
                        vuln_type=vuln_type,
                        severity=BiometricSeverityLevel(detection.get("severity", "MEDIUM")),
                        title=detection.get("title", "Biometric Vulnerability"),
                        description=detection.get("description", ""),
                        evidence=detection.get("evidence", {}),
                        confidence=0.8,
                        cwe_id=detection.get("cwe_id", "CWE-287"),
                        masvs_control=detection.get("masvs_control", "MASVS-AUTH-2"),
                        recommendations=detection.get("recommendations", []),
                        affected_components=["Biometric Authentication"]
                    )
                    vulnerabilities.append(vulnerability)
        
        except Exception as e:
            self.logger.error(f"Dynamic findings analysis failed: {e}")
        
        return vulnerabilities
    
    def _correlate_findings(self, static_results: Dict[str, Any], 
                           dynamic_results: Dict[str, Any]) -> List[BiometricVulnerability]:
        """Correlate static and dynamic findings to identify complex vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Check for APIs with runtime bypass attempts
            has_biometric_apis = static_results.get("apis_found", 0) > 0
            has_bypass_attempts = len(dynamic_results.get("bypass_attempts", [])) > 0
            
            if has_biometric_apis and has_bypass_attempts:
                vulnerability = BiometricVulnerability(
                    vuln_type=BiometricVulnerabilityType.BIOMETRIC_BYPASS,
                    severity=BiometricSeverityLevel.HIGH,
                    title="Confirmed Biometric Authentication Bypass",
                    description="Static analysis detected biometric APIs with confirmed runtime bypass attempts",
                    evidence={
                        "static_apis": static_results.get("apis_found", 0),
                        "runtime_bypasses": len(dynamic_results.get("bypass_attempts", [])),
                        "correlation": "Static biometric APIs + Runtime bypass attempts"
                    },
                    confidence=0.95,
                    cwe_id="CWE-287",
                    masvs_control="MASVS-AUTH-2",
                    recommendations=[
                        "Implement robust authentication validation",
                        "Use CryptoObject for all biometric operations",
                        "Add bypass detection and prevention mechanisms"
                    ],
                    affected_components=["Biometric Authentication", "Security Validation"]
                )
                vulnerabilities.append(vulnerability)
            
            # Check for deprecated APIs with runtime issues
            deprecated_apis = [api for api in static_results.get("apis_detected", []) 
                             if hasattr(api, 'deprecated') and api.deprecated]
            auth_events = dynamic_results.get("auth_events", [])
            
            if deprecated_apis and auth_events:
                vulnerability = BiometricVulnerability(
                    vuln_type=BiometricVulnerabilityType.DEPRECATED_API_USAGE,
                    severity=BiometricSeverityLevel.MEDIUM,
                    title="Deprecated API with Runtime Security Issues",
                    description="Application uses deprecated biometric APIs with confirmed runtime activity",
                    evidence={
                        "deprecated_apis": len(deprecated_apis),
                        "runtime_events": len(auth_events),
                        "api_types": [api.api_type if hasattr(api, 'api_type') else str(api) for api in deprecated_apis]
                    },
                    confidence=0.8,
                    cwe_id="CWE-477",
                    masvs_control="MASVS-AUTH-2",
                    recommendations=[
                        "Migrate to androidx.biometric.BiometricPrompt",
                        "Update authentication implementation",
                        "Test biometric functionality with modern APIs"
                    ],
                    affected_components=["Biometric Authentication", "API Migration"]
                )
                vulnerabilities.append(vulnerability)
        
        except Exception as e:
            self.logger.error(f"Findings correlation failed: {e}")
        
        return vulnerabilities
    
    def _determine_vulnerability_type_from_pattern(self, pattern: Dict[str, Any]) -> Optional[BiometricVulnerabilityType]:
        """Determine vulnerability type from static pattern."""
        pattern_type = pattern.get("type", "")
        
        type_mapping = {
            "crypto_object_usage": BiometricVulnerabilityType.CRYPTO_OBJECT_BYPASS,
            "weak_implementation": BiometricVulnerabilityType.WEAK_BIOMETRIC_IMPLEMENTATION,
            "auth_state_storage": BiometricVulnerabilityType.AUTH_STATE_MANIPULATION,
            "fallback_auth": BiometricVulnerabilityType.INSECURE_FALLBACK,
            "insecure_storage": BiometricVulnerabilityType.AUTH_STATE_MANIPULATION
        }
        
        return type_mapping.get(pattern_type)
    
    def _determine_vulnerability_type_from_bypass(self, bypass_attempt: Dict[str, Any]) -> BiometricVulnerabilityType:
        """Determine vulnerability type from bypass attempt."""
        bypass_reason = bypass_attempt.get("bypass_reason", "").lower()
        
        if "crypto" in bypass_reason or "cryptoobject" in bypass_reason:
            return BiometricVulnerabilityType.CRYPTO_OBJECT_BYPASS
        elif "deprecated" in bypass_reason:
            return BiometricVulnerabilityType.DEPRECATED_API_USAGE
        elif "state" in bypass_reason or "storage" in bypass_reason:
            return BiometricVulnerabilityType.AUTH_STATE_MANIPULATION
        else:
            return BiometricVulnerabilityType.BIOMETRIC_BYPASS
    
    def _determine_severity_from_bypass(self, bypass_attempt: Dict[str, Any]) -> BiometricSeverityLevel:
        """Determine severity from bypass attempt."""
        bypass_reason = bypass_attempt.get("bypass_reason", "").lower()
        
        if "crypto" in bypass_reason or "cryptoobject" in bypass_reason:
            return BiometricSeverityLevel.HIGH
        elif "state" in bypass_reason and "direct" in bypass_reason:
            return BiometricSeverityLevel.HIGH
        elif "deprecated" in bypass_reason:
            return BiometricSeverityLevel.MEDIUM
        else:
            return BiometricSeverityLevel.MEDIUM
    
    def _create_vulnerability_from_pattern(self, pattern: Dict[str, Any], 
                                         vuln_type: BiometricVulnerabilityType) -> Optional[BiometricVulnerability]:
        """Create vulnerability from static pattern."""
        try:
            pattern_info = self.vulnerability_patterns[vuln_type]
            
            vulnerability = BiometricVulnerability(
                vuln_type=vuln_type,
                severity=pattern_info["severity"],
                title=f"Biometric {vuln_type.value.replace('_', ' ').title()} Detected",
                description=f"Static analysis detected {vuln_type.value} pattern in biometric implementation",
                evidence={
                    "pattern": pattern.get("pattern", ""),
                    "file": pattern.get("file", ""),
                    "line": pattern.get("line", 0),
                    "match": pattern.get("match", "")
                },
                confidence=0.7,
                cwe_id=pattern_info["cwe_id"],
                masvs_control=pattern_info["masvs_control"],
                recommendations=self._get_recommendations_for_type(vuln_type),
                affected_components=["Biometric Authentication"]
            )
            
            return vulnerability
        
        except Exception as e:
            self.logger.error(f"Vulnerability creation from pattern failed: {e}")
            return None
    
    def _get_recommendations_for_type(self, vuln_type: BiometricVulnerabilityType) -> List[str]:
        """Get security recommendations for vulnerability type."""
        recommendations = {
            BiometricVulnerabilityType.BIOMETRIC_BYPASS: [
                "Implement proper authentication validation",
                "Use CryptoObject for cryptographic operations",
                "Add bypass detection mechanisms"
            ],
            BiometricVulnerabilityType.WEAK_BIOMETRIC_IMPLEMENTATION: [
                "Use androidx.biometric.BiometricPrompt",
                "Implement CryptoObject for authentication",
                "Follow Android biometric best practices"
            ],
            BiometricVulnerabilityType.INSECURE_FALLBACK: [
                "Implement strong fallback authentication",
                "Validate fallback methods security",
                "Use secure credential storage"
            ],
            BiometricVulnerabilityType.AUTH_STATE_MANIPULATION: [
                "Use secure storage for authentication state",
                "Implement tamper detection",
                "Validate authentication before state changes"
            ],
            BiometricVulnerabilityType.CRYPTO_OBJECT_BYPASS: [
                "Always use CryptoObject for authentication",
                "Validate cryptographic operations",
                "Implement proper cipher validation"
            ],
            BiometricVulnerabilityType.DEPRECATED_API_USAGE: [
                "Migrate to androidx.biometric.BiometricPrompt",
                "Update to modern biometric APIs",
                "Remove deprecated FingerprintManager usage"
            ]
        }
        
        return recommendations.get(vuln_type, [
            "Review biometric implementation for security issues",
            "Follow Android biometric security guidelines",
            "Implement proper authentication validation"
        ])
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[BiometricVulnerability]) -> List[BiometricVulnerability]:
        """Remove duplicate vulnerabilities and prioritize by severity."""
        # Group by type and evidence similarity
        unique_vulns = {}
        
        for vuln in vulnerabilities:
            key = f"{vuln.vuln_type.value}_{vuln.title}_{str(vuln.evidence.get('file', ''))}"
            
            if key not in unique_vulns or vuln.confidence > unique_vulns[key].confidence:
                unique_vulns[key] = vuln
        
        # Sort by severity (CRITICAL > HIGH > MEDIUM > LOW > INFO)
        severity_order = {
            BiometricSeverityLevel.CRITICAL: 0,
            BiometricSeverityLevel.HIGH: 1,
            BiometricSeverityLevel.MEDIUM: 2,
            BiometricSeverityLevel.LOW: 3,
            BiometricSeverityLevel.INFO: 4
        }
        
        return sorted(unique_vulns.values(), key=lambda v: severity_order[v.severity])