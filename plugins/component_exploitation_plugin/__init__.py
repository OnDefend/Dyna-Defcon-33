#!/usr/bin/env python3
"""
Component Exploitation Plugin - Modular Architecture Entry Point

Comprehensive component exploitation analysis with modular architecture.
Integrates command generation, security assessment, and vulnerability detection
with evidence-based confidence calculation and comprehensive reporting.
"""

import os
import sys
import logging
from typing import Dict, Any, Optional, List, Tuple, Union
from datetime import datetime
from pathlib import Path

# Add parent directories to path for imports
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir.parent.parent / "core"))

# Import modular components
from .data_structures import (
    ComponentType, ExploitationRisk, SecurityGrade, ThreatLevel,
    ComponentVulnerability, ExploitationCommand, SecurityAssessment,
    AnalysisContext, PluginResults
)
from .confidence_calculator import ComponentExploitationConfidenceCalculator
from .command_generator import ComponentExploitationCommandGenerator
from .security_assessor import ComponentSecurityAssessor

# Import external dependencies
try:
    from component_exploitation_analyzer import ComponentExploitationAnalyzer
    from adb_exploitation_framework import ADBExploitationFramework
except ImportError as e:
    logging.warning(f"External component dependencies not available: {e}")
    ComponentExploitationAnalyzer = None
    ADBExploitationFramework = None

logger = logging.getLogger(__name__)

class ComponentExploitationPlugin:
    """
    Modular Component Exploitation Analysis Plugin.
    
    Provides comprehensive component exploitation analysis with evidence-based
    confidence calculation, intelligent command generation, and security assessment.
    Implements dependency injection and structured error handling.
    """
    
    def __init__(self, apk_ctx, analysis_context: Optional[AnalysisContext] = None):
        """Initialize plugin with dependency injection."""
        self.apk_ctx = apk_ctx
        self.plugin_name = "component_exploitation"
        self.plugin_version = "2.0.0"  # Modular version
        
        # Create analysis context if not provided
        if analysis_context is None:
            self.analysis_context = AnalysisContext(
                apk_package=getattr(apk_ctx, 'package_name', 'unknown'),
                analysis_timestamp=datetime.now(),
                plugin_version=self.plugin_version,
                total_components_analyzed=0
            )
        else:
            self.analysis_context = analysis_context
        
        # Initialize modular components with dependency injection
        self.confidence_calculator = ComponentExploitationConfidenceCalculator()
        self.command_generator = ComponentExploitationCommandGenerator()
        self.security_assessor = ComponentSecurityAssessor()
        
        # Initialize external components if available
        self.component_analyzer = None
        self.adb_framework = None
        
        if ComponentExploitationAnalyzer:
            self.component_analyzer = ComponentExploitationAnalyzer(apk_ctx)
        if ADBExploitationFramework:
            self.adb_framework = ADBExploitationFramework()
        
        # Plugin results storage
        self.exploitation_findings = []
        self.exploitation_commands = []
        self.security_assessment = None
        
        logger.debug(f"Component Exploitation Plugin v{self.plugin_version} initialized (modular)")
    
    def analyze(self) -> Dict[str, Any]:
        """
        Main plugin analysis method with modular architecture.
        
        Returns:
            Comprehensive analysis results with structured findings
        """
        start_time = datetime.now()
        
        try:
            logger.debug("Starting modular component exploitation analysis...")
            
            # Phase 1: Component Discovery and Analysis
            component_analysis = self._perform_component_analysis()
            
            # Phase 2: Exploitation Command Generation
            exploitation_commands = self._generate_exploitation_commands(component_analysis)
            
            # Phase 3: Security Assessment
            security_assessment = self._perform_security_assessment(component_analysis)
            
            # Phase 4: AODS Findings Generation
            aods_findings = self._generate_aods_findings(
                component_analysis, security_assessment, exploitation_commands
            )
            
            # Phase 5: User Interface Data Creation
            user_interface_data = self._create_user_interface_data(exploitation_commands)
            
            # Phase 6: Results Compilation
            analysis_duration = (datetime.now() - start_time).total_seconds()
            self.analysis_context.analysis_duration = analysis_duration
            
            plugin_results = PluginResults(
                plugin_metadata={
                    'name': self.plugin_name,
                    'version': self.plugin_version,
                    'analysis_timestamp': self.analysis_context.analysis_timestamp.isoformat(),
                    'apk_package': self.analysis_context.apk_package,
                    'analysis_duration': analysis_duration
                },
                component_analysis=component_analysis,
                exploitation_commands=exploitation_commands,
                security_assessment=security_assessment,
                aods_findings=aods_findings,
                user_interface=user_interface_data,
                analysis_summary=self._generate_analysis_summary(
                    component_analysis, security_assessment, len(aods_findings)
                )
            )
            
            # Store results for reporting
            self.exploitation_findings = aods_findings
            self.exploitation_commands = exploitation_commands
            self.security_assessment = security_assessment
            
            logger.debug(f"Modular component exploitation analysis completed: "
                       f"{len(aods_findings)} findings, {len(exploitation_commands)} commands, "
                       f"grade {security_assessment.security_grade.value}")
            
            return self._convert_to_dict(plugin_results)
            
        except Exception as e:
            logger.error(f"Component exploitation analysis failed: {e}")
            return {
                'error': str(e),
                'plugin_metadata': {
                    'name': self.plugin_name,
                    'version': self.plugin_version,
                    'status': 'failed'
                }
            }
    
    def _perform_component_analysis(self) -> Dict[str, Any]:
        """Perform component discovery and analysis."""
        if self.component_analyzer:
            # Use external component analyzer if available
            try:
                analysis_results = self.component_analyzer.analyze_apk_components()
                self.analysis_context.total_components_analyzed = len(
                    analysis_results.get('discovered_components', [])
                )
                return analysis_results
            except Exception as e:
                logger.error(f"External component analyzer failed: {e}")
        
        # Fallback to basic analysis using APK context
        return self._perform_basic_component_analysis()
    
    def _perform_basic_component_analysis(self) -> Dict[str, Any]:
        """Perform basic component analysis using APK context."""
        discovered_components = []
        
        # Analyze activities
        activities = getattr(self.apk_ctx, 'get_activities', lambda: [])()
        for activity in activities:
            component_data = self._create_component_data(activity, ComponentType.ACTIVITY)
            discovered_components.append(component_data)
        
        # Analyze services
        services = getattr(self.apk_ctx, 'get_services', lambda: [])()
        for service in services:
            component_data = self._create_component_data(service, ComponentType.SERVICE)
            discovered_components.append(component_data)
        
        # Analyze receivers
        receivers = getattr(self.apk_ctx, 'get_receivers', lambda: [])()
        for receiver in receivers:
            component_data = self._create_component_data(receiver, ComponentType.RECEIVER)
            discovered_components.append(component_data)
        
        # Analyze providers
        providers = getattr(self.apk_ctx, 'get_providers', lambda: [])()
        for provider in providers:
            component_data = self._create_component_data(provider, ComponentType.PROVIDER)
            discovered_components.append(component_data)
        
        # Calculate statistics
        exploitable_count = sum(1 for comp in discovered_components if comp.get('exploitable', False))
        high_risk_count = sum(1 for comp in discovered_components if comp.get('risk') in ['critical', 'high'])
        
        self.analysis_context.total_components_analyzed = len(discovered_components)
        
        return {
            'discovered_components': discovered_components,
            'component_statistics': {
                'total_components': len(discovered_components),
                'exploitable_count': exploitable_count,
                'high_risk_count': high_risk_count
            }
        }
    
    def _create_component_data(self, component: Dict[str, Any], comp_type: ComponentType) -> Dict[str, Any]:
        """Create standardized component data from APK context."""
        component_name = component.get('name', 'unknown')
        exported = component.get('exported', False)
        permissions = component.get('permissions', [])
        
        # Assess risk level
        risk_level = self._assess_component_risk(exported, permissions, comp_type)
        
        # Determine if exploitable
        exploitable = exported and (not permissions or len(permissions) == 0)
        
        return {
            'name': component_name,
            'type': comp_type.value,
            'exported': exported,
            'permissions': permissions,
            'intent_filters': component.get('intent_filters', []),
            'risk': risk_level.value,
            'exploitable': exploitable,
            'vulnerabilities': self._identify_component_vulnerabilities(component, comp_type),
            'commands': [],  # Will be populated by command generator
            'metadata': {
                'analysis_method': 'apk_context',
                'confidence': 0.8  # Default confidence for APK context analysis
            }
        }
    
    def _assess_component_risk(self, exported: bool, permissions: List[str], 
                             comp_type: ComponentType) -> ExploitationRisk:
        """Assess risk level for a component."""
        if not exported:
            return ExploitationRisk.MINIMAL
        
        if not permissions:
            # Exported with no permissions - high risk
            return ExploitationRisk.HIGH if comp_type != ComponentType.ACTIVITY else ExploitationRisk.CRITICAL
        
        # Check permission strength
        has_signature_perm = any('signature' in str(p) for p in permissions)
        has_dangerous_perm = any('dangerous' in str(p) for p in permissions)
        
        if has_signature_perm:
            return ExploitationRisk.LOW
        elif has_dangerous_perm:
            return ExploitationRisk.MEDIUM
        else:
            return ExploitationRisk.HIGH
    
    def _identify_component_vulnerabilities(self, component: Dict[str, Any], 
                                          comp_type: ComponentType) -> List[str]:
        """Identify potential vulnerabilities for a component."""
        vulnerabilities = []
        
        if component.get('exported', False):
            if not component.get('permissions', []):
                vulnerabilities.append("Exported without permission protection")
            
            intent_filters = component.get('intent_filters', [])
            if intent_filters:
                vulnerabilities.append("Intent filters may allow unauthorized access")
            
            if comp_type == ComponentType.PROVIDER:
                vulnerabilities.append("Content provider may expose sensitive data")
            elif comp_type == ComponentType.SERVICE:
                vulnerabilities.append("Service may perform unauthorized operations")
        
        return vulnerabilities
    
    def _generate_exploitation_commands(self, component_analysis: Dict[str, Any]) -> List[ExploitationCommand]:
        """Generate exploitation commands with confidence calculation."""
        commands = self.command_generator.generate_exploitation_commands(component_analysis)
        
        # Calculate confidence for each command
        for command in commands:
            evidence = {
                'component_data': self._find_component_data(command.component_name, component_analysis),
                'detection_method': 'command_generation',
                'validation_methods': ['template_matching', 'safety_assessment']
            }
            
            confidence = self.confidence_calculator.calculate_command_confidence(command, evidence)
            command.metadata['confidence'] = confidence
        
        return commands
    
    def _perform_security_assessment(self, component_analysis: Dict[str, Any]) -> SecurityAssessment:
        """Perform comprehensive security assessment with confidence calculation."""
        assessment = self.security_assessor.assess_security_posture(component_analysis)
        
        # Calculate confidence for assessment
        evidence = {
            'analysis_completeness': True,
            'manifest_parsed': True,
            'components_discovered': True,
            'permissions_analyzed': True,
            'validation_methods': ['statistical_analysis', 'risk_assessment'],
            'analyzed_component_count': len(component_analysis.get('discovered_components', []))
        }
        
        confidence = self.confidence_calculator.calculate_assessment_confidence(assessment, evidence)
        
        # Store confidence in assessment metadata
        if not hasattr(assessment, 'metadata'):
            assessment.metadata = {}
        assessment.metadata = {'confidence': confidence}
        
        return assessment
    
    def _generate_aods_findings(self, component_analysis: Dict[str, Any], 
                              security_assessment: SecurityAssessment,
                              commands: List[ExploitationCommand]) -> List[ComponentVulnerability]:
        """Generate AODS-compatible vulnerability findings with confidence calculation."""
        findings = []
        components = component_analysis.get('discovered_components', [])
        
        for component in components:
            if component.get('exploitable', False):
                # Create vulnerability finding
                vulnerability = self._create_vulnerability_finding(component, security_assessment)
                
                # Calculate confidence
                evidence = {
                    'component_data': component,
                    'detection_method': 'explicit_export_detection',
                    'context_type': 'production_manifest',
                    'validation_methods': ['manifest_parsing', 'permission_analysis'],
                    'permission_analysis': {
                        'custom_permissions_analyzed': True,
                        'dangerous_permissions_identified': True,
                        'protection_level_analyzed': True
                    }
                }
                
                confidence = self.confidence_calculator.calculate_vulnerability_confidence(
                    vulnerability, evidence
                )
                vulnerability.confidence = confidence
                
                findings.append(vulnerability)
        
        return findings
    
    def _create_vulnerability_finding(self, component: Dict[str, Any], 
                                    assessment: SecurityAssessment) -> ComponentVulnerability:
        """Create structured vulnerability finding."""
        comp_type = ComponentType(component.get('type', 'activity'))
        risk_level = component.get('risk', 'low')
        
        return ComponentVulnerability(
            id=f"comp_exploit_{len(self.exploitation_findings) + 1}",
            title=f"Exported {comp_type.value.title()} Without Protection",
            description=self._generate_finding_description(component),
            severity=self._map_risk_to_severity(risk_level),
            component_name=component.get('name', 'unknown'),
            component_type=comp_type,
            risk_factors=self._extract_risk_factors(component),
            impact=self._describe_impact(component),
            recommendation=self._generate_component_recommendation(component),
            owasp_category=self._map_to_owasp_category(comp_type),
            cwe_id=self._map_to_cwe_id(comp_type),
            cvss_score=self._calculate_cvss_score(component),
            evidence={'component_data': component, 'assessment': assessment.__dict__},
            references=self._get_security_references(comp_type)
        )
    
    def _generate_finding_description(self, component: Dict[str, Any]) -> str:
        """Generate detailed finding description."""
        comp_name = component.get('name', 'unknown').split('.')[-1]
        comp_type = component.get('type', 'component')
        permissions = component.get('permissions', [])
        
        if not permissions:
            return (f"The {comp_type} '{comp_name}' is exported without any permission protection, "
                   f"allowing any application to access it directly through intent-based exploitation.")
        else:
            return (f"The {comp_type} '{comp_name}' is exported with weak permission protection "
                   f"({', '.join(permissions[:3])}), potentially allowing unauthorized access.")
    
    def _map_risk_to_severity(self, risk: str) -> str:
        """Map risk level to AODS severity."""
        mapping = {
            'critical': 'CRITICAL',
            'high': 'HIGH',
            'medium': 'MEDIUM',
            'low': 'LOW',
            'minimal': 'INFO'
        }
        return mapping.get(risk, 'MEDIUM')
    
    def _map_to_owasp_category(self, comp_type: ComponentType) -> str:
        """Map component type to OWASP category."""
        from .data_structures import OWASP_CATEGORY_MAPPING
        return OWASP_CATEGORY_MAPPING.get(comp_type, "M6-Insecure Authorization")
    
    def _map_to_cwe_id(self, comp_type: ComponentType) -> str:
        """Map component type to CWE ID."""
        from .data_structures import CWE_MAPPING
        return CWE_MAPPING.get(comp_type, "CWE-284")
    
    def _calculate_cvss_score(self, component: Dict[str, Any]) -> float:
        """Calculate CVSS score for component vulnerability."""
        base_score = 5.0  # Medium base score
        
        # Adjust based on risk level
        risk_level = component.get('risk', 'low')
        risk_adjustments = {
            'critical': 2.5,
            'high': 1.5,
            'medium': 0.0,
            'low': -1.0,
            'minimal': -2.0
        }
        
        base_score += risk_adjustments.get(risk_level, 0.0)
        
        # Adjust based on component type
        comp_type = component.get('type', 'activity')
        type_adjustments = {
            'provider': 1.0,    # Higher risk for data exposure
            'service': 0.5,     # Medium risk for background operations
            'receiver': 0.3,    # Lower risk for event handling
            'activity': 0.0     # Base risk for UI components
        }
        
        base_score += type_adjustments.get(comp_type, 0.0)
        
        return max(0.0, min(10.0, base_score))
    
    def _extract_risk_factors(self, component: Dict[str, Any]) -> List[str]:
        """Extract risk factors for vulnerability."""
        factors = []
        
        if component.get('exported', False):
            factors.append("Component is exported")
        
        if not component.get('permissions', []):
            factors.append("No permission protection")
        
        if component.get('intent_filters', []):
            factors.append("Intent filters allow external access")
        
        comp_type = component.get('type', '')
        if comp_type == 'provider':
            factors.append("Content provider may expose sensitive data")
        elif comp_type == 'service':
            factors.append("Service operations may be triggered externally")
        
        return factors
    
    def _describe_impact(self, component: Dict[str, Any]) -> str:
        """Describe potential impact of vulnerability."""
        comp_type = component.get('type', 'component')
        risk_level = component.get('risk', 'low')
        
        impacts = {
            'activity': "Unauthorized access to application screens and functionality",
            'service': "Unauthorized execution of background operations and services",
            'receiver': "Triggering of unintended application behavior through broadcasts",
            'provider': "Exposure of application data through content provider queries"
        }
        
        base_impact = impacts.get(comp_type, "Unauthorized component access")
        
        if risk_level in ['critical', 'high']:
            return f"{base_impact}, potentially leading to data theft or privilege escalation"
        else:
            return f"{base_impact} with limited security implications"
    
    def _generate_component_recommendation(self, component: Dict[str, Any]) -> str:
        """Generate specific recommendation for component."""
        comp_type = component.get('type', 'component')
        permissions = component.get('permissions', [])
        
        if not permissions:
            return (f"Add signature-level permission protection to the {comp_type} or "
                   f"set android:exported=\"false\" if external access is not required")
        else:
            return (f"Review and strengthen permission requirements for the {comp_type}, "
                   f"consider using signature-level permissions for sensitive operations")
    
    def _get_security_references(self, comp_type: ComponentType) -> List[str]:
        """Get security references for component type."""
        references = [
            "https://owasp.org/www-project-mobile-security-testing-guide/",
            "https://developer.android.com/guide/components/fundamentals"
        ]
        
        type_specific = {
            ComponentType.ACTIVITY: "https://developer.android.com/guide/components/activities/intro-activities",
            ComponentType.SERVICE: "https://developer.android.com/guide/components/services",
            ComponentType.RECEIVER: "https://developer.android.com/guide/components/broadcasts",
            ComponentType.PROVIDER: "https://developer.android.com/guide/topics/providers/content-providers"
        }
        
        if comp_type in type_specific:
            references.append(type_specific[comp_type])
        
        return references
    
    def _create_user_interface_data(self, commands: List[ExploitationCommand]) -> Dict[str, Any]:
        """Create user interface data for command execution."""
        categories = self.command_generator.get_command_categories(commands)
        quick_start = self.command_generator.get_quick_start_commands(commands)
        
        return {
            'total_commands': len(commands),
            'command_categories': categories,
            'quick_start_commands': [self._command_to_dict(cmd) for cmd in quick_start],
            'risk_summary': self._summarize_command_risks(commands),
            'execution_guidance': {
                'prerequisites': [
                    "Android device connected via ADB",
                    "Target APK installed on device",
                    "ADB debugging enabled"
                ],
                'safety_notes': [
                    "Test commands in controlled environment",
                    "Monitor device and application behavior",
                    "Use test data for content provider operations"
                ]
            }
        }
    
    def _summarize_command_risks(self, commands: List[ExploitationCommand]) -> Dict[str, Any]:
        """Summarize risk distribution of commands."""
        risk_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        safety_counts = {'SAFE': 0, 'CAUTION': 0, 'DANGEROUS': 0}
        
        for cmd in commands:
            risk_level = cmd.risk_level.value
            if risk_level in risk_counts:
                risk_counts[risk_level] += 1
            
            safety_level = cmd.safety_level.value
            if safety_level in safety_counts:
                safety_counts[safety_level] += 1
        
        return {
            'risk_distribution': risk_counts,
            'safety_distribution': safety_counts,
            'total_high_risk': risk_counts['critical'] + risk_counts['high'],
            'total_safe': safety_counts['SAFE']
        }
    
    def _generate_analysis_summary(self, component_analysis: Dict[str, Any],
                                 security_assessment: SecurityAssessment,
                                 findings_count: int) -> Dict[str, Any]:
        """Generate comprehensive analysis summary."""
        stats = component_analysis.get('component_statistics', {})
        
        return {
            'analysis_summary': {
                'total_components': stats.get('total_components', 0),
                'exploitable_components': stats.get('exploitable_count', 0),
                'high_risk_components': stats.get('high_risk_count', 0),
                'security_grade': security_assessment.security_grade.value,
                'security_score': security_assessment.security_score,
                'threat_level': security_assessment.threat_level.value
            },
            'key_findings': [
                f"{stats.get('exploitable_count', 0)} components can be directly exploited",
                f"{stats.get('high_risk_count', 0)} components pose high security risks",
                f"Security grade: {security_assessment.security_grade.value} "
                f"({security_assessment.grade_description})",
                f"{len(self.exploitation_commands)} ADB exploitation commands generated"
            ],
            'next_steps': security_assessment.recommendations[:3],
            'threat_assessment': {
                'level': security_assessment.threat_level.value,
                'impact': security_assessment.impact_assessment,
                'urgency': security_assessment.mitigation_urgency
            }
        }
    
    def _find_component_data(self, component_name: str, component_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Find component data by name."""
        components = component_analysis.get('discovered_components', [])
        for comp in components:
            if comp.get('name') == component_name:
                return comp
        return {}
    
    def _command_to_dict(self, command: ExploitationCommand) -> Dict[str, Any]:
        """Convert command object to dictionary."""
        return {
            'id': command.id,
            'component_name': command.component_name,
            'component_type': command.component_type.value,
            'command': command.command,
            'risk_level': command.risk_level.value,
            'safety_level': command.safety_level.value,
            'description': command.description,
            'execution_notes': command.execution_notes,
            'expected_outcome': command.expected_outcome,
            'prerequisites': command.prerequisites,
            'confidence': command.metadata.get('confidence', 0.7)
        }
    
    def _convert_to_dict(self, plugin_results: PluginResults) -> Dict[str, Any]:
        """Convert plugin results to dictionary format."""
        return {
            'plugin_metadata': plugin_results.plugin_metadata,
            'component_analysis': plugin_results.component_analysis,
            'exploitation_commands': [self._command_to_dict(cmd) for cmd in plugin_results.exploitation_commands],
            'security_assessment': {
                'security_grade': plugin_results.security_assessment.security_grade.value,
                'security_score': plugin_results.security_assessment.security_score,
                'grade_description': plugin_results.security_assessment.grade_description,
                'threat_level': plugin_results.security_assessment.threat_level.value,
                'total_components': plugin_results.security_assessment.total_components,
                'exploitable_components': plugin_results.security_assessment.exploitable_components,
                'high_risk_components': plugin_results.security_assessment.high_risk_components,
                'risk_distribution': plugin_results.security_assessment.risk_distribution,
                'component_types': plugin_results.security_assessment.component_types,
                'recommendations': plugin_results.security_assessment.recommendations,
                'impact_assessment': plugin_results.security_assessment.impact_assessment,
                'mitigation_urgency': plugin_results.security_assessment.mitigation_urgency
            },
            'aods_findings': [self._vulnerability_to_dict(vuln) for vuln in plugin_results.aods_findings],
            'user_interface': plugin_results.user_interface,
            'summary': plugin_results.analysis_summary,
            'errors': plugin_results.errors
        }
    
    def _vulnerability_to_dict(self, vulnerability: ComponentVulnerability) -> Dict[str, Any]:
        """Convert vulnerability object to dictionary."""
        return {
            'id': vulnerability.id,
            'title': vulnerability.title,
            'description': vulnerability.description,
            'severity': vulnerability.severity,
            'component_name': vulnerability.component_name,
            'component_type': vulnerability.component_type.value,
            'risk_factors': vulnerability.risk_factors,
            'impact': vulnerability.impact,
            'recommendation': vulnerability.recommendation,
            'owasp_category': vulnerability.owasp_category,
            'cwe_id': vulnerability.cwe_id,
            'cvss_score': vulnerability.cvss_score,
            'confidence': vulnerability.confidence,
            'evidence': vulnerability.evidence,
            'references': vulnerability.references
        }
    
    def get_exploitation_report(self) -> Dict[str, Any]:
        """Get formatted exploitation report for AODS integration."""
        if not self.exploitation_findings:
            return {'error': 'No analysis results available. Run analyze() first.'}
        
        return {
            'plugin_name': self.plugin_name,
            'plugin_version': self.plugin_version,
            'findings_count': len(self.exploitation_findings),
            'findings': [self._vulnerability_to_dict(finding) for finding in self.exploitation_findings],
            'exploitation_commands': [self._command_to_dict(cmd) for cmd in self.exploitation_commands],
            'security_assessment': self.security_assessor.generate_security_summary(self.security_assessment),
            'timestamp': self.analysis_context.analysis_timestamp.isoformat()
        }

# Plugin interface functions for AODS framework compatibility
def run(apk_ctx) -> Tuple[str, Any]:
    """Main plugin entry point for AODS framework integration."""
    try:
        plugin = ComponentExploitationPlugin(apk_ctx)
        results = plugin.analyze()
        
        if 'error' in results:
            return 'error', f"Component Exploitation Analysis failed: {results['error']}"
        
        # Create summary report for AODS
        summary = results.get('summary', {})
        findings_count = len(results.get('aods_findings', []))
        commands_count = len(results.get('exploitation_commands', []))
        security_grade = summary.get('analysis_summary', {}).get('security_grade', 'Unknown')
        
        from rich.text import Text
        
        # Create rich formatted output
        output = Text()
        output.append("🎯 Component Exploitation Analysis Results\n", style="bold blue")
        output.append("=" * 50 + "\n", style="blue")
        output.append(f"Security Grade: {security_grade}\n", style="bold")
        output.append(f"Findings Generated: {findings_count}\n")
        output.append(f"Exploitation Commands: {commands_count}\n")
        
        if findings_count > 0:
            output.append("\n🔍 Key Findings:\n", style="bold yellow")
            for i, finding in enumerate(results.get('aods_findings', [])[:5], 1):
                severity = finding.get('severity', 'Unknown')
                title = finding.get('title', 'Component Issue')
                confidence = finding.get('confidence', 0.0)
                output.append(f"  {i}. [{severity}] {title} (Confidence: {confidence:.2f})\n")
        
        if commands_count > 0:
            output.append(f"\n✅ {commands_count} exploitation commands ready for testing\n", style="green")
            output.append("💡 Use the generated ADB commands to test component security\n", style="blue")
        
        # Add security assessment summary
        threat_level = summary.get('threat_assessment', {}).get('level', 'UNKNOWN')
        output.append(f"\n⚡ Threat Level: {threat_level}\n", style="bold red" if threat_level in ['CRITICAL', 'HIGH'] else "bold yellow")
        
        return 'success', output
        
    except Exception as e:
        logger.error(f"Component exploitation plugin run failed: {e}")
        return 'error', f"Component Exploitation Plugin Error: {str(e)}"

def run_plugin(apk_ctx) -> Tuple[str, Union[str, Any]]:
    """Plugin interface function expected by the plugin manager."""
    return run(apk_ctx)