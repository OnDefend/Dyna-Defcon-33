#!/usr/bin/env python3
"""
Component Exploitation Plugin - Command Generator

Generates ADB exploitation commands for discovered Android components.
Provides intelligent command generation with safety assessment, execution guidance,
and expected outcome prediction based on component characteristics.
"""

import logging
import re
import yaml
from typing import Dict, List, Any, Optional
from pathlib import Path
from .data_structures import (
    ComponentType, ExploitationRisk, CommandSafety, ExploitationCommand,
    ComponentInfo, ComponentData
)

logger = logging.getLogger(__name__)

class ComponentExploitationCommandGenerator:
    """
    Generates exploitation commands for Android components.
    
    Creates ADB commands for testing component security, assesses command safety,
    and provides comprehensive execution guidance for security testing.
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """Initialize command generator with configuration."""
        if config_path is None:
            config_path = Path(__file__).parent / "exploitation_patterns_config.yaml"
        
        self.config = self._load_configuration(config_path)
        self.command_templates = self.config.get('exploitation_commands', {})
        self.safety_patterns = self.config.get('command_safety', {})
        self.max_commands_per_component = self.config.get('analysis_config', {}).get(
            'max_commands_per_component', 10
        )
        
        logger.info("Initialized ComponentExploitationCommandGenerator")
    
    def generate_exploitation_commands(self, component_analysis: Dict[str, Any]) -> List[ExploitationCommand]:
        """
        Generate exploitation commands for discovered components.
        
        Args:
            component_analysis: Component analysis results
            
        Returns:
            List of structured exploitation commands
        """
        commands = []
        discovered_components = component_analysis.get('discovered_components', [])
        
        for component_data in discovered_components:
            if component_data.get('exploitable', False):
                component_commands = self._generate_component_commands(component_data)
                commands.extend(component_commands)
        
        # Limit total commands generated
        max_total_commands = self.config.get('analysis_config', {}).get('max_findings_to_report', 50)
        if len(commands) > max_total_commands:
            commands = commands[:max_total_commands]
            logger.warning(f"Limited command output to {max_total_commands} commands")
        
        logger.info(f"Generated {len(commands)} exploitation commands")
        return commands
    
    def _generate_component_commands(self, component_data: ComponentData) -> List[ExploitationCommand]:
        """Generate commands for a specific component."""
        commands = []
        component_type = component_data.get('type', '').lower()
        component_name = component_data.get('name', '')
        package_name = self._extract_package_name(component_name)
        
        # Get command templates for component type
        templates = self.command_templates.get(component_type, {})
        
        command_count = 0
        for template_name, template in templates.items():
            if command_count >= self.max_commands_per_component:
                break
            
            # Generate command from template
            command_str = self._generate_command_from_template(
                template, component_data, package_name
            )
            
            if command_str:
                # Create structured command object
                exploitation_command = ExploitationCommand(
                    id=f"exploit_{len(commands) + 1}",
                    component_name=component_name,
                    component_type=ComponentType(component_type),
                    command=command_str,
                    risk_level=ExploitationRisk(component_data.get('risk', 'low')),
                    safety_level=self._assess_command_safety(command_str),
                    description=self._generate_command_description(command_str, component_data),
                    execution_notes=self._generate_execution_notes(command_str, component_data),
                    expected_outcome=self._generate_expected_outcome(command_str, component_data),
                    prerequisites=self._generate_prerequisites(command_str, component_data),
                    metadata={
                        'template_name': template_name,
                        'template_source': template
                    }
                )
                
                commands.append(exploitation_command)
                command_count += 1
        
        return commands
    
    def _generate_command_from_template(self, template: str, component_data: ComponentData,
                                      package_name: str) -> Optional[str]:
        """Generate command string from template."""
        try:
            # Extract component name parts
            component_name = component_data.get('name', '')
            short_component = component_name.split('.')[-1] if component_name else ''
            
            # Basic template substitution
            command = template.format(
                package=package_name,
                component=short_component,
                full_component=component_name
            )
            
            # Add intent filters if available
            intent_filters = component_data.get('intent_filters', [])
            if intent_filters and '{action}' in template:
                action = intent_filters[0].get('action', 'android.intent.action.MAIN')
                command = command.replace('{action}', action)
            
            # Add authority for content providers
            if component_data.get('type') == 'provider' and '{authority}' in template:
                authority = component_data.get('authority', f"{package_name}.provider")
                command = command.replace('{authority}', authority)
            
            # Add sample extras for testing
            if '{key}' in template and '{value}' in template:
                command = command.replace('{key}', 'test_key').replace('{value}', 'test_value')
            
            # Add sample URI for testing
            if '{uri}' in template:
                command = command.replace('{uri}', 'content://example/data')
            
            # Add sample data for testing
            if '{data}' in template:
                command = command.replace('{data}', 'test_data=value')
            
            # Add sample columns for content queries
            if '{columns}' in template:
                command = command.replace('{columns}', '_id,name,data')
            
            # Add sample conditions for content queries
            if '{condition}' in template:
                command = command.replace('{condition}', '_id=1')
            
            return command
            
        except Exception as e:
            logger.error(f"Error generating command from template: {e}")
            return None
    
    def _assess_command_safety(self, command: str) -> CommandSafety:
        """Assess safety level of a command."""
        # Check against dangerous patterns
        dangerous_patterns = self.safety_patterns.get('dangerous_patterns', [])
        for pattern in dangerous_patterns:
            if re.search(pattern, command, re.IGNORECASE):
                return CommandSafety.DANGEROUS
        
        # Check against caution patterns
        caution_patterns = self.safety_patterns.get('caution_patterns', [])
        for pattern in caution_patterns:
            if re.search(pattern, command, re.IGNORECASE):
                return CommandSafety.CAUTION
        
        # Check against safe patterns
        safe_patterns = self.safety_patterns.get('safe_patterns', [])
        for pattern in safe_patterns:
            if re.search(pattern, command, re.IGNORECASE):
                return CommandSafety.SAFE
        
        # Default to caution if no patterns match
        return CommandSafety.CAUTION
    
    def _generate_command_description(self, command: str, component_data: ComponentData) -> str:
        """Generate user-friendly command description."""
        comp_type = component_data.get('type', '').lower()
        comp_name = component_data.get('name', '').split('.')[-1]
        
        if 'am start' in command:
            if '--es' in command or '--ei' in command or '--ez' in command:
                return f"Launch the exported {comp_type} '{comp_name}' with custom intent extras"
            elif '-d' in command:
                return f"Launch the exported {comp_type} '{comp_name}' with custom URI data"
            else:
                return f"Launch the exported {comp_type} '{comp_name}' directly without authentication"
        
        elif 'am startservice' in command:
            if '--es' in command:
                return f"Start the exported service '{comp_name}' with custom parameters"
            else:
                return f"Start the exported service '{comp_name}' bypassing normal application flow"
        
        elif 'am broadcast' in command:
            if '--es' in command:
                return f"Send broadcast to receiver '{comp_name}' with custom intent extras"
            elif '-d' in command:
                return f"Send broadcast to receiver '{comp_name}' with custom data URI"
            else:
                return f"Send broadcast to receiver '{comp_name}' with custom intent"
        
        elif 'content query' in command:
            if '--projection' in command:
                return f"Query content provider '{comp_name}' with specific column projection"
            elif '--where' in command:
                return f"Query content provider '{comp_name}' with conditional filtering"
            else:
                return f"Query content provider '{comp_name}' for data access testing"
        
        elif 'content insert' in command:
            return f"Insert data into content provider '{comp_name}' for modification testing"
        
        else:
            return f"Execute exploitation command against {comp_type} '{comp_name}'"
    
    def _generate_execution_notes(self, command: str, component_data: ComponentData) -> List[str]:
        """Generate execution notes for user guidance."""
        notes = [
            "Ensure Android device is connected and ADB debugging is enabled",
            "Install the target APK on the device before running commands"
        ]
        
        # Command-specific notes
        if '--es' in command or '--ei' in command or '--ez' in command:
            notes.append("This command includes intent extras - observe app behavior for parameter handling")
        
        if 'content://' in command or 'content query' in command:
            notes.append("Monitor for data leakage - content provider may expose sensitive information")
        
        if 'content insert' in command:
            notes.append("CAUTION: This command modifies data - use with test data only")
        
        if component_data.get('risk') in ['critical', 'high']:
            notes.append("HIGH RISK: This component has no permission protection - exploitation likely to succeed")
        
        # Add component-specific notes
        comp_type = component_data.get('type', '').lower()
        if comp_type == 'provider':
            notes.append("Content provider access may reveal database schema and sensitive data")
        elif comp_type == 'service':
            notes.append("Service may perform background operations affecting device state")
        elif comp_type == 'receiver':
            notes.append("Broadcast receiver may trigger unintended application behavior")
        
        return notes
    
    def _generate_expected_outcome(self, command: str, component_data: ComponentData) -> str:
        """Generate expected outcome description."""
        risk_level = component_data.get('risk', 'low')
        comp_type = component_data.get('type', '').lower()
        
        if risk_level in ['critical', 'high']:
            if comp_type == 'activity':
                return "Activity should launch without permission checks, potentially exposing application functionality"
            elif comp_type == 'service':
                return "Service should start and execute background operations without authorization"
            elif comp_type == 'provider':
                return "Content provider should return data, potentially exposing sensitive information"
            elif comp_type == 'receiver':
                return "Broadcast receiver should process intent, potentially triggering unintended actions"
        else:
            return "Command should be blocked by Android security controls or application permissions"
        
        return "Observe application behavior and system responses for security validation"
    
    def _generate_prerequisites(self, command: str, component_data: ComponentData) -> List[str]:
        """Generate command prerequisites."""
        prerequisites = [
            "Android device connected via ADB",
            "Target application installed on device",
            "ADB debugging enabled on device"
        ]
        
        # Add component-specific prerequisites
        comp_type = component_data.get('type', '').lower()
        if comp_type == 'provider':
            prerequisites.append("Content provider authority correctly identified")
        elif comp_type == 'service':
            prerequisites.append("Service component name accurately specified")
        
        # Add risk-specific prerequisites
        risk_level = component_data.get('risk', 'low')
        if risk_level in ['critical', 'high']:
            prerequisites.append("Monitoring tools ready to capture exploitation results")
        
        return prerequisites
    
    def _extract_package_name(self, component_name: str) -> str:
        """Extract package name from component name."""
        if not component_name:
            return "com.example.app"
        
        parts = component_name.split('.')
        if len(parts) >= 3:
            # Return first 3 parts as package name (typical pattern)
            return '.'.join(parts[:3])
        elif len(parts) >= 2:
            # Return first 2 parts
            return '.'.join(parts[:2])
        else:
            # Fallback to generic package name
            return "com.example.app"
    
    def _load_configuration(self, config_path: Path) -> Dict[str, Any]:
        """Load configuration from YAML file."""
        try:
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
            logger.info(f"Loaded configuration from {config_path}")
            return config
        except Exception as e:
            logger.error(f"Error loading configuration: {e}")
            return {}
    
    def get_command_categories(self, commands: List[ExploitationCommand]) -> Dict[str, List[ExploitationCommand]]:
        """Categorize commands by type and risk level."""
        categories = {
            'high_risk': [],
            'medium_risk': [], 
            'low_risk': [],
            'by_component_type': {
                'activity': [],
                'service': [],
                'receiver': [],
                'provider': []
            }
        }
        
        for cmd in commands:
            # Categorize by risk level
            if cmd.risk_level in [ExploitationRisk.CRITICAL, ExploitationRisk.HIGH]:
                categories['high_risk'].append(cmd)
            elif cmd.risk_level == ExploitationRisk.MEDIUM:
                categories['medium_risk'].append(cmd)
            else:
                categories['low_risk'].append(cmd)
            
            # Categorize by component type
            comp_type = cmd.component_type.value
            if comp_type in categories['by_component_type']:
                categories['by_component_type'][comp_type].append(cmd)
        
        return categories
    
    def get_quick_start_commands(self, commands: List[ExploitationCommand]) -> List[ExploitationCommand]:
        """Get recommended quick-start commands for immediate testing."""
        quick_start = []
        
        # Prioritize high-risk, safe commands
        for cmd in commands:
            if (cmd.risk_level in [ExploitationRisk.HIGH, ExploitationRisk.CRITICAL] and
                cmd.safety_level == CommandSafety.SAFE):
                quick_start.append(cmd)
        
        # Add diverse component types
        component_types_covered = set()
        for cmd in commands:
            if len(quick_start) >= 5:  # Limit quick start commands
                break
            
            if cmd.component_type not in component_types_covered:
                quick_start.append(cmd)
                component_types_covered.add(cmd.component_type)
        
        return quick_start[:5]  # Maximum 5 quick start commands 