#!/usr/bin/env python3
"""
Component Exploitation Plugin - Security Assessor

Comprehensive security assessment and threat analysis for Android components.
Provides security grading, threat level assessment, and security recommendations
based on component vulnerability analysis and exploitation potential.
"""

import logging
import yaml
from typing import Dict, List, Any, Optional
from pathlib import Path
from .data_structures import (
    SecurityGrade, ThreatLevel, SecurityAssessment, ExploitationRisk,
    ComponentType, ComponentData, AssessmentData
)

# Import unified deduplication framework
from core.unified_deduplication_framework import (
    deduplicate_findings, 
    DeduplicationStrategy,
    create_deduplication_engine
)

logger = logging.getLogger(__name__)

class ComponentSecurityAssessor:
    """
    Comprehensive security assessment for Android components.
    
    Analyzes component security posture, calculates security grades,
    assesses threat levels, and provides actionable security recommendations.
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """Initialize security assessor with configuration."""
        if config_path is None:
            config_path = Path(__file__).parent / "exploitation_patterns_config.yaml"
        
        self.config = self._load_configuration(config_path)
        self.scoring_config = self.config.get('security_scoring', {})
        self.threat_config = self.config.get('threat_assessment', {})
        self.recommendations_config = self.config.get('recommendations', {})
        
        logger.info("Initialized ComponentSecurityAssessor")
    
    def assess_security_posture(self, component_analysis: Dict[str, Any]) -> SecurityAssessment:
        """
        Perform comprehensive security assessment of component analysis results.
        
        Args:
            component_analysis: Complete component analysis results
            
        Returns:
            Comprehensive security assessment
        """
        try:
            # Extract component statistics
            stats = component_analysis.get('component_statistics', {})
            components = component_analysis.get('discovered_components', [])
            
            total_components = stats.get('total_components', len(components))
            exploitable_count = stats.get('exploitable_count', 0)
            high_risk_count = stats.get('high_risk_count', 0)
            
            # Calculate security score
            security_score = self._calculate_security_score(
                total_components, exploitable_count, high_risk_count, components
            )
            
            # Determine security grade
            security_grade = self._determine_security_grade(security_score)
            
            # Generate threat assessment
            threat_assessment = self._generate_threat_assessment(
                exploitable_count, high_risk_count, total_components
            )
            
            # Generate risk distribution
            risk_distribution = self._calculate_risk_distribution(components)
            
            # Generate component type distribution
            component_types = self._calculate_component_type_distribution(components)
            
            # Generate recommendations
            recommendations = self._generate_security_recommendations(
                exploitable_count, high_risk_count, risk_distribution, component_types
            )
            
            # Create comprehensive assessment
            assessment = SecurityAssessment(
                security_grade=security_grade,
                security_score=security_score,
                grade_description=self._get_grade_description(security_grade, security_score),
                threat_level=threat_assessment['level'],
                total_components=total_components,
                exploitable_components=exploitable_count,
                high_risk_components=high_risk_count,
                risk_distribution=risk_distribution,
                component_types=component_types,
                recommendations=recommendations,
                impact_assessment=self._assess_potential_impact(exploitable_count, high_risk_count),
                mitigation_urgency=self._assess_mitigation_urgency(threat_assessment['level'])
            )
            
            logger.info(f"Security assessment completed: Grade {security_grade.value}, "
                       f"Score {security_score:.1f}, Threat {threat_assessment['level'].value}")
            
            return assessment
            
        except Exception as e:
            logger.error(f"Error performing security assessment: {e}")
            # Return default assessment on error
            return SecurityAssessment(
                security_grade=SecurityGrade.F,
                security_score=0.0,
                grade_description="Assessment failed - unable to determine security posture",
                threat_level=ThreatLevel.CRITICAL,
                total_components=0,
                exploitable_components=0,
                high_risk_components=0
            )
    
    def _calculate_security_score(self, total_components: int, exploitable_count: int,
                                high_risk_count: int, components: List[ComponentData]) -> float:
        """Calculate overall security score based on component analysis."""
        if total_components == 0:
            return 50.0  # Neutral score for no components
        
        # Start with base score
        base_score = 100.0
        
        # Apply risk-based penalties
        risk_weights = self.scoring_config.get('risk_weights', {})
        
        for component in components:
            risk_level = component.get('risk', 'low')
            penalty = abs(risk_weights.get(risk_level, 0))  # Convert to positive penalty
            base_score -= penalty
        
        # Apply component type weights
        component_weights = self.scoring_config.get('component_type_weights', {})
        
        for component in components:
            comp_type = component.get('type', 'activity')
            if component.get('exported', False) and not component.get('permissions', []):
                # Extra penalty for unprotected exported components
                weight = component_weights.get(comp_type, 1.0)
                base_score -= (5 * weight)
        
        # Apply protection bonuses
        protection_bonuses = self.scoring_config.get('protection_bonuses', {})
        
        for component in components:
            permissions = component.get('permissions', [])
            
            # Bonus for signature-level permissions
            if any('signature' in str(p) for p in permissions):
                base_score += protection_bonuses.get('signature_permission', 0)
            
            # Bonus for dangerous permission protection
            if any('dangerous' in str(p) for p in permissions):
                base_score += protection_bonuses.get('dangerous_permission_protected', 0)
            
            # Bonus for custom permissions
            if any(not str(p).startswith('android.') for p in permissions):
                base_score += protection_bonuses.get('custom_permission', 0)
            
            # Bonus for restricted intent filters
            intent_filters = component.get('intent_filters', [])
            if intent_filters and len(intent_filters) == 1:  # Specific intent filters
                base_score += protection_bonuses.get('intent_filter_restricted', 0)
        
        # Ensure score is within valid range
        return max(0.0, min(100.0, base_score))
    
    def _determine_security_grade(self, security_score: float) -> SecurityGrade:
        """Determine security grade based on score."""
        thresholds = self.scoring_config.get('grade_thresholds', {})
        
        if security_score >= thresholds.get('A_PLUS', 95):
            return SecurityGrade.A_PLUS
        elif security_score >= thresholds.get('A', 85):
            return SecurityGrade.A
        elif security_score >= thresholds.get('B', 75):
            return SecurityGrade.B
        elif security_score >= thresholds.get('C', 65):
            return SecurityGrade.C
        elif security_score >= thresholds.get('D', 50):
            return SecurityGrade.D
        else:
            return SecurityGrade.F
    
    def _get_grade_description(self, grade: SecurityGrade, score: float) -> str:
        """Get description for security grade."""
        descriptions = {
            SecurityGrade.A_PLUS: "Excellent security posture with comprehensive protection",
            SecurityGrade.A: "Strong security posture with good protection mechanisms",
            SecurityGrade.B: "Adequate security posture with some vulnerabilities",
            SecurityGrade.C: "Below average security posture requiring attention",
            SecurityGrade.D: "Poor security posture with significant vulnerabilities",
            SecurityGrade.F: "Critical security issues requiring immediate attention"
        }
        
        description = descriptions.get(grade, "Unknown security posture")
        return f"{description} (Score: {score:.1f}/100)"
    
    def _generate_threat_assessment(self, exploitable_count: int, high_risk_count: int,
                                  total_components: int) -> Dict[str, Any]:
        """Generate comprehensive threat assessment."""
        # Calculate risk percentages
        if total_components > 0:
            exploitable_percentage = exploitable_count / total_components
            high_risk_percentage = high_risk_count / total_components
        else:
            exploitable_percentage = 0.0
            high_risk_percentage = 0.0
        
        # Determine threat level based on indicators
        critical_indicators = self.threat_config.get('critical_indicators', [])
        high_indicators = self.threat_config.get('high_indicators', [])
        medium_indicators = self.threat_config.get('medium_indicators', [])
        
        threat_level = ThreatLevel.LOW
        threat_factors = []
        
        # Check critical indicators
        for indicator in critical_indicators:
            if isinstance(indicator, dict):
                if (exploitable_count >= indicator.get('exploitable_count_threshold', float('inf')) or
                    high_risk_percentage >= indicator.get('high_risk_percentage', float('inf'))):
                    threat_level = ThreatLevel.CRITICAL
                    threat_factors.append("Multiple high-risk components exploitable")
                    break
        
        # Check high indicators if not already critical
        if threat_level != ThreatLevel.CRITICAL:
            for indicator in high_indicators:
                if isinstance(indicator, dict):
                    if (exploitable_count >= indicator.get('exploitable_count_threshold', float('inf')) or
                        high_risk_percentage >= indicator.get('high_risk_percentage', float('inf'))):
                        threat_level = ThreatLevel.HIGH
                        threat_factors.append("Several components vulnerable to exploitation")
                        break
        
        # Check medium indicators if not already high or critical
        if threat_level not in [ThreatLevel.CRITICAL, ThreatLevel.HIGH]:
            for indicator in medium_indicators:
                if isinstance(indicator, dict):
                    if (exploitable_count >= indicator.get('exploitable_count_threshold', float('inf')) or
                        high_risk_percentage >= indicator.get('high_risk_percentage', float('inf'))):
                        threat_level = ThreatLevel.MEDIUM
                        threat_factors.append("Some components may be exploitable")
                        break
        
        return {
            'level': threat_level,
            'factors': threat_factors,
            'exploitable_percentage': exploitable_percentage,
            'high_risk_percentage': high_risk_percentage,
            'description': self._get_threat_description(threat_level)
        }
    
    def _get_threat_description(self, threat_level: ThreatLevel) -> str:
        """Get description for threat level."""
        descriptions = {
            ThreatLevel.CRITICAL: "Critical threat - immediate exploitation possible",
            ThreatLevel.HIGH: "High threat - exploitation likely with minimal effort",
            ThreatLevel.MEDIUM: "Medium threat - exploitation possible with moderate effort",
            ThreatLevel.LOW: "Low threat - limited exploitation potential",
            ThreatLevel.MINIMAL: "Minimal threat - exploitation highly unlikely"
        }
        return descriptions.get(threat_level, "Unknown threat level")
    
    def _calculate_risk_distribution(self, components: List[ComponentData]) -> Dict[str, int]:
        """Calculate distribution of risk levels across components."""
        distribution = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'minimal': 0
        }
        
        for component in components:
            risk_level = component.get('risk', 'low')
            if risk_level in distribution:
                distribution[risk_level] += 1
        
        return distribution
    
    def _calculate_component_type_distribution(self, components: List[ComponentData]) -> Dict[str, int]:
        """Calculate distribution of component types."""
        distribution = {
            'activity': 0,
            'service': 0,
            'receiver': 0,
            'provider': 0
        }
        
        for component in components:
            comp_type = component.get('type', 'activity')
            if comp_type in distribution:
                distribution[comp_type] += 1
        
        return distribution
    
    def _generate_security_recommendations(self, exploitable_count: int, high_risk_count: int,
                                         risk_distribution: Dict[str, int],
                                         component_types: Dict[str, int]) -> List[str]:
        """Generate prioritized security recommendations."""
        recommendations = []
        
        # Critical recommendations for high-risk scenarios
        if exploitable_count > 0:
            critical_recs = self.recommendations_config.get('critical', [])
            recommendations.extend(critical_recs)
        
        # High priority recommendations
        if high_risk_count > 0:
            high_recs = self.recommendations_config.get('high', [])
            recommendations.extend(high_recs)
        
        # Medium priority recommendations
        if risk_distribution.get('medium', 0) > 0:
            medium_recs = self.recommendations_config.get('medium', [])
            recommendations.extend(medium_recs)
        
        # Component-specific recommendations
        if component_types.get('provider', 0) > 0:
            recommendations.append("Review content provider data exposure and implement proper URI permissions")
        
        if component_types.get('service', 0) > 0:
            recommendations.append("Audit service operations and implement proper service protection")
        
        if component_types.get('receiver', 0) > 0:
            recommendations.append("Secure broadcast receivers with appropriate permission requirements")
        
        # General recommendations
        general_recs = self.recommendations_config.get('general', [])
        recommendations.extend(general_recs)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_recommendations = []
        for rec in recommendations:
            if rec not in seen:
                seen.add(rec)
                unique_recommendations.append(rec)
        
        return unique_recommendations[:10]  # Limit to top 10 recommendations
    
    def _assess_potential_impact(self, exploitable_count: int, high_risk_count: int) -> str:
        """Assess potential impact of identified vulnerabilities."""
        if exploitable_count >= 5:
            return "SEVERE - Multiple attack vectors available, significant data exposure risk"
        elif exploitable_count >= 3:
            return "HIGH - Several attack vectors available, potential for privilege escalation"
        elif exploitable_count >= 1:
            return "MODERATE - Limited attack vectors, potential for unauthorized access"
        elif high_risk_count >= 3:
            return "MODERATE - High-risk components present, potential security weaknesses"
        elif high_risk_count >= 1:
            return "LOW - Some security concerns identified, limited exploitation potential"
        else:
            return "MINIMAL - No significant security issues identified"
    
    def _assess_mitigation_urgency(self, threat_level: ThreatLevel) -> str:
        """Assess urgency of mitigation efforts."""
        urgency_mapping = {
            ThreatLevel.CRITICAL: "IMMEDIATE - Address within 24 hours",
            ThreatLevel.HIGH: "URGENT - Address within 1 week",
            ThreatLevel.MEDIUM: "MODERATE - Address within 1 month",
            ThreatLevel.LOW: "LOW - Address in next development cycle",
            ThreatLevel.MINIMAL: "ROUTINE - Address during regular maintenance"
        }
        
        return urgency_mapping.get(threat_level, "UNKNOWN - Assessment needed")
    
    def _load_configuration(self, config_path: Path) -> Dict[str, Any]:
        """Load configuration from YAML file."""
        try:
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
            logger.info(f"Loaded security assessment configuration from {config_path}")
            return config
        except Exception as e:
            logger.error(f"Error loading configuration: {e}")
            return {}
    
    def generate_security_summary(self, assessment: SecurityAssessment) -> Dict[str, Any]:
        """Generate executive summary of security assessment."""
        return {
            'overall_grade': assessment.security_grade.value,
            'security_score': round(assessment.security_score, 1),
            'threat_level': assessment.threat_level.value,
            'total_components': assessment.total_components,
            'critical_issues': assessment.exploitable_components,
            'high_risk_issues': assessment.high_risk_components,
            'primary_concerns': assessment.recommendations[:3],
            'impact_assessment': assessment.impact_assessment,
            'urgency': assessment.mitigation_urgency,
            'component_breakdown': assessment.component_types,
            'risk_breakdown': assessment.risk_distribution
        } 