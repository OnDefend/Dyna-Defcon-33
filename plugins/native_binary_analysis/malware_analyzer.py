"""
Malware Pattern Analyzer Module

Specialized analyzer for malware pattern detection in native binary libraries.
Provides comprehensive malware signature detection, obfuscation analysis,
and threat assessment capabilities.

Features:
- Malware signature detection with 200+ patterns
- Anti-analysis technique identification
- Packer signature detection
- Obfuscation indicator analysis
- Persistence mechanism detection
- Command & control pattern analysis
- Risk assessment with evidence-based confidence
- Comprehensive threat intelligence reporting
"""

import logging
import re
import subprocess
from pathlib import Path
from typing import List, Dict, Set, Optional, Tuple
import yaml
from dataclasses import asdict

from core.shared_infrastructure.dependency_injection import AnalysisContext
from core.shared_infrastructure.analysis_exceptions import BinaryAnalysisError, safe_execute
from .data_structures import (
    MalwarePatternAnalysis, 
    MalwareRiskLevel, 
    NativeBinaryVulnerability,
    VulnerabilitySeverity
)
from .confidence_calculator import BinaryConfidenceCalculator

# Import unified deduplication framework
from core.unified_deduplication_framework import (
    deduplicate_findings, 
    DeduplicationStrategy,
    create_deduplication_engine
)

class MalwareAnalyzer:
    """
    Advanced malware pattern analyzer for native binary libraries.
    
    Detects malware signatures, anti-analysis techniques, obfuscation patterns,
    and assesses overall threat level with evidence-based confidence scoring.
    """
    
    def __init__(self, context: AnalysisContext, confidence_calculator: BinaryConfidenceCalculator, logger: logging.Logger):
        self.context = context
        self.confidence_calculator = confidence_calculator
        self.logger = logger
        self.patterns = self._load_malware_patterns()
        
        # Compiled regex patterns for performance
        self._compiled_patterns = {}
        self._compile_patterns()
    
    def _load_malware_patterns(self) -> Dict:
        """Load malware detection patterns from YAML configuration."""
        try:
            pattern_file = Path(__file__).parent / "binary_patterns_config.yaml"
            if not pattern_file.exists():
                self.logger.warning(f"Pattern file not found: {pattern_file}")
                return {}
            
            with open(pattern_file, 'r') as f:
                config = yaml.safe_load(f)
                return config.get('malware_patterns', {})
        except Exception as e:
            self.logger.error(f"Failed to load malware patterns: {e}")
            return {}
    
    def _compile_patterns(self):
        """Pre-compile regex patterns for improved performance."""
        try:
            for category, patterns in self.patterns.items():
                if isinstance(patterns, list):
                    compiled_list = []
                    for pattern in patterns:
                        try:
                            compiled_list.append(re.compile(pattern, re.IGNORECASE))
                        except re.error as e:
                            self.logger.warning(f"Invalid regex pattern '{pattern}': {e}")
                    self._compiled_patterns[category] = compiled_list
        except Exception as e:
            self.logger.error(f"Failed to compile patterns: {e}")
    
    def analyze(self, lib_path: Path) -> MalwarePatternAnalysis:
        """
        Perform comprehensive malware pattern analysis on native binary.
        
        Args:
            lib_path: Path to the native library file
            
        Returns:
            MalwarePatternAnalysis with detected threats and risk assessment
        """
        self.logger.info(f"Starting malware analysis for: {lib_path.name}")
        
        analysis = MalwarePatternAnalysis(library_name=lib_path.name)
        
        try:
            # Extract binary content for analysis
            binary_content = self._extract_binary_content(lib_path)
            if not binary_content:
                self.logger.warning(f"No binary content extracted from {lib_path}")
                return analysis
            
            # Perform comprehensive pattern detection
            analysis.suspicious_strings = self._detect_suspicious_strings(binary_content)
            analysis.packer_signatures = self._detect_packer_signatures(binary_content)
            analysis.anti_analysis_techniques = self._detect_anti_analysis_techniques(binary_content)
            analysis.obfuscation_indicators = self._detect_obfuscation_indicators(binary_content)
            analysis.persistence_mechanisms = self._detect_persistence_mechanisms(binary_content)
            analysis.command_control_indicators = self._detect_command_control_indicators(binary_content)
            
            # Calculate risk assessment
            analysis.risk_level, analysis.risk_score = self._calculate_risk_assessment(analysis)
            
            # Calculate evidence-based threat confidence
            analysis.threat_confidence = self._calculate_threat_confidence(analysis)
            
            # Generate vulnerabilities based on findings
            analysis.vulnerabilities = self._generate_vulnerabilities(analysis, lib_path)
            
            self.logger.info(f"Malware analysis completed for {lib_path.name}: "
                           f"Risk Level = {analysis.risk_level.value}, "
                           f"Risk Score = {analysis.risk_score:.2f}, "
                           f"Confidence = {analysis.threat_confidence:.3f}")
            
        except Exception as e:
            self.logger.error(f"Malware analysis failed for {lib_path}: {e}")
            raise BinaryAnalysisError(f"Malware analysis failed: {e}")
        
        return analysis
    
    def _extract_binary_content(self, lib_path: Path) -> Optional[bytes]:
        """Extract binary content for pattern analysis."""
        try:
            if not lib_path.exists() or lib_path.stat().st_size == 0:
                return None
            
            # Read binary content (limit to reasonable size for analysis)
            max_size = 50 * 1024 * 1024  # 50MB limit
            if lib_path.stat().st_size > max_size:
                self.logger.warning(f"Library {lib_path.name} too large for full analysis ({lib_path.stat().st_size} bytes)")
                # Read first portion for analysis
                with open(lib_path, 'rb') as f:
                    return f.read(max_size)
            else:
                return lib_path.read_bytes()
                
        except Exception as e:
            self.logger.error(f"Failed to extract binary content from {lib_path}: {e}")
            return None
    
    def _detect_suspicious_strings(self, binary_content: bytes) -> List[str]:
        """Detect suspicious strings indicating malware behavior."""
        detected = []
        
        try:
            # Convert to string for pattern matching (handle encoding issues)
            text_content = self._extract_text_content(binary_content)
            
            if 'suspicious_strings' in self._compiled_patterns:
                for pattern in self._compiled_patterns['suspicious_strings']:
                    matches = pattern.findall(text_content)
                    detected.extend(matches)
            
            # Remove duplicates while preserving order
            return list(dict.fromkeys(detected))
            
        except Exception as e:
            self.logger.error(f"Failed to detect suspicious strings: {e}")
            return []
    
    def _detect_packer_signatures(self, binary_content: bytes) -> List[str]:
        """Detect known packer signatures."""
        detected = []
        
        try:
            text_content = self._extract_text_content(binary_content)
            
            if 'packer_signatures' in self._compiled_patterns:
                for pattern in self._compiled_patterns['packer_signatures']:
                    matches = pattern.findall(text_content)
                    detected.extend(matches)
            
            # Also check for common packer magic bytes
            packer_magic = {
                b'UPX!': 'UPX',
                b'UPX0': 'UPX',
                b'UPX1': 'UPX',
                b'UPX2': 'UPX',
                b'.packed': 'Generic Packer',
                b'!This program cannot be run in DOS mode': 'PE Packer'
            }
            
            for magic, packer_name in packer_magic.items():
                if magic in binary_content:
                    detected.append(packer_name)
            
            return list(dict.fromkeys(detected))
            
        except Exception as e:
            self.logger.error(f"Failed to detect packer signatures: {e}")
            return []
    
    def _detect_anti_analysis_techniques(self, binary_content: bytes) -> List[str]:
        """Detect anti-analysis and evasion techniques."""
        detected = []
        
        try:
            text_content = self._extract_text_content(binary_content)
            
            if 'anti_analysis' in self._compiled_patterns:
                for pattern in self._compiled_patterns['anti_analysis']:
                    matches = pattern.findall(text_content)
                    detected.extend(matches)
            
            # Check for specific anti-analysis API calls
            anti_analysis_apis = [
                'IsDebuggerPresent', 'CheckRemoteDebuggerPresent', 'OutputDebugString',
                'GetTickCount', 'QueryPerformanceCounter', 'timeGetTime',
                'NtQueryInformationProcess', 'NtSetInformationThread'
            ]
            
            for api in anti_analysis_apis:
                if api.encode() in binary_content:
                    detected.append(f"Anti-Debug API: {api}")
            
            return list(dict.fromkeys(detected))
            
        except Exception as e:
            self.logger.error(f"Failed to detect anti-analysis techniques: {e}")
            return []
    
    def _detect_obfuscation_indicators(self, binary_content: bytes) -> List[str]:
        """Detect code and data obfuscation indicators."""
        detected = []
        
        try:
            text_content = self._extract_text_content(binary_content)
            
            if 'obfuscation' in self._compiled_patterns:
                for pattern in self._compiled_patterns['obfuscation']:
                    matches = pattern.findall(text_content)
                    detected.extend(matches)
            
            # Analyze entropy for obfuscation detection
            entropy_score = self._calculate_entropy(binary_content)
            if entropy_score > 7.5:  # High entropy indicates possible obfuscation
                detected.append(f"High entropy content (score: {entropy_score:.2f})")
            
            # Check for unusual string patterns
            if self._has_unusual_string_patterns(text_content):
                detected.append("Unusual string encoding patterns")
            
            return list(dict.fromkeys(detected))
            
        except Exception as e:
            self.logger.error(f"Failed to detect obfuscation indicators: {e}")
            return []
    
    def _detect_persistence_mechanisms(self, binary_content: bytes) -> List[str]:
        """Detect persistence and installation mechanisms."""
        detected = []
        
        try:
            text_content = self._extract_text_content(binary_content)
            
            if 'persistence' in self._compiled_patterns:
                for pattern in self._compiled_patterns['persistence']:
                    matches = pattern.findall(text_content)
                    detected.extend(matches)
            
            # Check for specific persistence techniques
            persistence_indicators = [
                'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
                'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce',
                'StartUp', 'startup', 'autorun', 'service',
                'DllRegisterServer', 'DllUnregisterServer'
            ]
            
            for indicator in persistence_indicators:
                if indicator.encode() in binary_content:
                    detected.append(f"Persistence indicator: {indicator}")
            
            return list(dict.fromkeys(detected))
            
        except Exception as e:
            self.logger.error(f"Failed to detect persistence mechanisms: {e}")
            return []
    
    def _detect_command_control_indicators(self, binary_content: bytes) -> List[str]:
        """Detect command and control communication patterns."""
        detected = []
        
        try:
            text_content = self._extract_text_content(binary_content)
            
            if 'command_control' in self._compiled_patterns:
                for pattern in self._compiled_patterns['command_control']:
                    matches = pattern.findall(text_content)
                    detected.extend(matches)
            
            # Check for suspicious network patterns
            suspicious_urls = re.findall(r'https?://[a-zA-Z0-9.-]+[a-zA-Z0-9.-/]*', text_content)
            suspicious_ips = re.findall(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}:[0-9]+\b', text_content)
            
            if suspicious_urls:
                detected.extend([f"Suspicious URL: {url}" for url in suspicious_urls[:5]])  # Limit output
            
            if suspicious_ips:
                detected.extend([f"Suspicious IP: {ip}" for ip in suspicious_ips[:5]])  # Limit output
            
            return list(dict.fromkeys(detected))
            
        except Exception as e:
            self.logger.error(f"Failed to detect C&C indicators: {e}")
            return []
    
    def _extract_text_content(self, binary_content: bytes) -> str:
        """Extract readable text content from binary data."""
        try:
            # Try to decode as UTF-8, replace invalid characters
            text_content = binary_content.decode('utf-8', errors='replace')
            return text_content
        except Exception:
            # Fallback to latin-1 which can decode any byte sequence
            return binary_content.decode('latin-1', errors='replace')
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data."""
        try:
            if not data:
                return 0.0
            
            # Calculate frequency of each byte
            freq = {}
            for byte in data:
                freq[byte] = freq.get(byte, 0) + 1
            
            # Calculate entropy
            entropy = 0.0
            data_len = len(data)
            for count in freq.values():
                p = count / data_len
                if p > 0:
                    entropy -= p * (p.bit_length() - 1)
            
            return entropy
            
        except Exception as e:
            self.logger.error(f"Failed to calculate entropy: {e}")
            return 0.0
    
    def _has_unusual_string_patterns(self, text_content: str) -> bool:
        """Check for unusual string encoding patterns that might indicate obfuscation."""
        try:
            # Check for high percentage of non-printable characters
            non_printable = sum(1 for c in text_content if ord(c) < 32 or ord(c) > 126)
            non_printable_ratio = non_printable / max(len(text_content), 1)
            
            # Check for repetitive patterns
            repetitive_patterns = re.findall(r'(.)\1{10,}', text_content)
            
            return non_printable_ratio > 0.8 or len(repetitive_patterns) > 5
            
        except Exception as e:
            self.logger.error(f"Failed to analyze string patterns: {e}")
            return False
    
    def _calculate_risk_assessment(self, analysis: MalwarePatternAnalysis) -> Tuple[MalwareRiskLevel, float]:
        """Calculate overall malware risk level and score."""
        try:
            risk_score = 0.0
            risk_factors = 0
            
            # Weight different threat categories
            threat_weights = {
                'suspicious_strings': 2.0,
                'packer_signatures': 3.0,
                'anti_analysis_techniques': 2.5,
                'obfuscation_indicators': 2.0,
                'persistence_mechanisms': 3.5,
                'command_control_indicators': 4.0
            }
            
            # Calculate weighted risk score
            for category, weight in threat_weights.items():
                findings = getattr(analysis, category, [])
                if findings:
                    risk_score += len(findings) * weight
                    risk_factors += len(findings)
            
            # Normalize score to 0-100 range
            if risk_factors > 0:
                risk_score = min(risk_score / max(risk_factors, 1) * 10, 100.0)
            
            # Determine risk level
            if risk_score >= 80:
                risk_level = MalwareRiskLevel.CRITICAL
            elif risk_score >= 60:
                risk_level = MalwareRiskLevel.HIGH
            elif risk_score >= 30:
                risk_level = MalwareRiskLevel.MEDIUM
            elif risk_score > 0:
                risk_level = MalwareRiskLevel.LOW
            else:
                risk_level = MalwareRiskLevel.CLEAN
            
            return risk_level, risk_score
            
        except Exception as e:
            self.logger.error(f"Failed to calculate risk assessment: {e}")
            return MalwareRiskLevel.CLEAN, 0.0
    
    def _calculate_threat_confidence(self, analysis: MalwarePatternAnalysis) -> float:
        """Calculate evidence-based threat confidence score."""
        try:
            # Create evidence dictionary for confidence calculation
            evidence = {
                'pattern_matches': len(analysis.suspicious_strings) + len(analysis.packer_signatures),
                'analysis_evasion': len(analysis.anti_analysis_techniques),
                'obfuscation_level': len(analysis.obfuscation_indicators),
                'persistence_indicators': len(analysis.persistence_mechanisms),
                'network_indicators': len(analysis.command_control_indicators),
                'overall_risk_score': analysis.risk_score
            }
            
            # Use confidence calculator for evidence-based scoring
            confidence = self.confidence_calculator.calculate_malware_confidence(
                analysis, evidence=evidence
            )
            
            return confidence
            
        except Exception as e:
            self.logger.error(f"Failed to calculate threat confidence: {e}")
            return 0.5  # Conservative default
    
    def _generate_vulnerabilities(self, analysis: MalwarePatternAnalysis, lib_path: Path) -> List[NativeBinaryVulnerability]:
        """Generate vulnerability findings based on malware analysis."""
        vulnerabilities = []
        
        try:
            # Generate vulnerabilities for high-risk findings
            if analysis.risk_level in [MalwareRiskLevel.CRITICAL, MalwareRiskLevel.HIGH]:
                vuln = NativeBinaryVulnerability(
                    id=f"MALWARE_{analysis.risk_level.value.upper()}_{lib_path.name}",
                    title=f"{analysis.risk_level.value} Malware Risk Detected",
                    description=f"Library {lib_path.name} exhibits malware characteristics with "
                               f"risk score {analysis.risk_score:.1f}/100",
                    severity=VulnerabilitySeverity.CRITICAL if analysis.risk_level == MalwareRiskLevel.CRITICAL 
                            else VulnerabilitySeverity.HIGH,
                    masvs_control="MSTG-RESILIENCE-3",
                    affected_files=[str(lib_path)],
                    evidence=[
                        f"Suspicious strings: {len(analysis.suspicious_strings)}",
                        f"Packer signatures: {len(analysis.packer_signatures)}",
                        f"Anti-analysis techniques: {len(analysis.anti_analysis_techniques)}",
                        f"Obfuscation indicators: {len(analysis.obfuscation_indicators)}",
                        f"Persistence mechanisms: {len(analysis.persistence_mechanisms)}",
                        f"C&C indicators: {len(analysis.command_control_indicators)}"
                    ],
                    remediation="Remove or replace the library with a trusted alternative. "
                              "Conduct thorough security review of the application.",
                    cwe_id="CWE-506",  # Embedded Malicious Code
                    cvss_score=9.0 if analysis.risk_level == MalwareRiskLevel.CRITICAL else 7.5,
                    confidence=analysis.threat_confidence,
                    context={
                        'risk_level': analysis.risk_level.value,
                        'risk_score': analysis.risk_score,
                        'threat_categories': {
                            'suspicious_strings': len(analysis.suspicious_strings),
                            'packer_signatures': len(analysis.packer_signatures),
                            'anti_analysis': len(analysis.anti_analysis_techniques),
                            'obfuscation': len(analysis.obfuscation_indicators),
                            'persistence': len(analysis.persistence_mechanisms),
                            'command_control': len(analysis.command_control_indicators)
                        }
                    }
                )
                vulnerabilities.append(vuln)
            
            # Generate specific vulnerabilities for packer detection
            if analysis.packer_signatures:
                vuln = NativeBinaryVulnerability(
                    id=f"PACKER_DETECTED_{lib_path.name}",
                    title="Packed Binary Detected",
                    description=f"Library {lib_path.name} appears to be packed with: "
                               f"{', '.join(analysis.packer_signatures)}",
                    severity=VulnerabilitySeverity.MEDIUM,
                    masvs_control="MSTG-RESILIENCE-9",
                    affected_files=[str(lib_path)],
                    evidence=analysis.packer_signatures,
                    remediation="Analyze the packed binary for malicious content. "
                              "Consider using unpacked versions of libraries.",
                    cwe_id="CWE-656",  # Reliance on Security Through Obscurity
                    cvss_score=5.0,
                    confidence=analysis.threat_confidence,
                    context={'packer_signatures': analysis.packer_signatures}
                )
                vulnerabilities.append(vuln)
            
        except Exception as e:
            self.logger.error(f"Failed to generate vulnerabilities: {e}")
        
        return vulnerabilities