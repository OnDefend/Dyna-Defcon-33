#!/usr/bin/env python3
"""
Vulnerability Scenario Engine

Specialized engine for executing targeted vulnerability scenarios
to trigger specific security issues during runtime analysis.

Author: AODS Team
Date: January 2025
"""

import logging
import time
import subprocess
import random
import json
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path


class VulnerabilityCategory(Enum):
    """Categories of vulnerability scenarios."""
    CRYPTO_WEAKNESS = "crypto_weakness"
    NETWORK_SECURITY = "network_security" 
    DATA_STORAGE = "data_storage"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    SESSION_MANAGEMENT = "session_management"
    COMMUNICATION = "communication"


class ScenarioComplexity(Enum):
    """Complexity levels for vulnerability scenarios."""
    BASIC = "basic"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"


@dataclass
class VulnerabilityScenario:
    """Defines a vulnerability testing scenario."""
    name: str
    description: str
    category: VulnerabilityCategory
    complexity: ScenarioComplexity
    cwe_ids: List[str] = field(default_factory=list)
    masvs_controls: List[str] = field(default_factory=list)
    steps: List[Dict[str, Any]] = field(default_factory=list)
    expected_detections: List[str] = field(default_factory=list)
    success_criteria: List[str] = field(default_factory=list)
    preconditions: List[str] = field(default_factory=list)


@dataclass
class ScenarioExecution:
    """Tracks execution of a vulnerability scenario."""
    scenario_name: str
    start_time: float
    end_time: float = 0.0
    status: str = "running"
    steps_completed: int = 0
    steps_failed: int = 0
    detections_triggered: List[str] = field(default_factory=list)
    evidence_collected: List[Dict[str, Any]] = field(default_factory=list)
    effectiveness_score: float = 0.0


class VulnerabilityScenarioEngine:
    """
    Specialized engine for executing targeted vulnerability scenarios
    to trigger specific security issues during runtime analysis.
    """
    
    def __init__(self, package_name: str = None, apk_ctx: Any = None):
        """Initialize vulnerability scenario engine."""
        self.logger = logging.getLogger(__name__)
        self.package_name = package_name
        self.apk_ctx = apk_ctx
        
        # Engine configuration
        self.scenario_timeout = 60  # seconds per scenario
        self.step_timeout = 10      # seconds per step
        self.detection_wait = 3     # seconds to wait for detection
        
        # Integration with runtime analysis
        self.hook_engine = None
        self.vulnerability_detector = None
        self.evidence_collector = None
        
        # Scenario state
        self.active_executions: Dict[str, ScenarioExecution] = {}
        self.completed_scenarios: List[ScenarioExecution] = []
        
        # Load predefined scenarios
        self.scenarios = self._initialize_vulnerability_scenarios()
        
        self.logger.info(f"🎯 VulnerabilityScenarioEngine initialized with {len(self.scenarios)} scenarios")
    
    def set_runtime_integrations(self, hook_engine=None, detector=None, collector=None):
        """Set runtime analysis component integrations."""
        self.hook_engine = hook_engine
        self.vulnerability_detector = detector
        self.evidence_collector = collector
        
        if hook_engine:
            self.logger.info("✅ Runtime hook engine integration enabled")
        if detector:
            self.logger.info("✅ Vulnerability detector integration enabled")
        if collector:
            self.logger.info("✅ Evidence collector integration enabled")
    
    def _initialize_vulnerability_scenarios(self) -> List[VulnerabilityScenario]:
        """Initialize predefined vulnerability scenarios."""
        scenarios = []
        
        # Crypto vulnerability scenarios
        scenarios.extend(self._create_crypto_scenarios())
        
        # Network security scenarios
        scenarios.extend(self._create_network_scenarios())
        
        # Storage security scenarios
        scenarios.extend(self._create_storage_scenarios())
        
        # Authentication scenarios
        scenarios.extend(self._create_authentication_scenarios())
        
        # Authorization scenarios
        scenarios.extend(self._create_authorization_scenarios())
        
        # Input validation scenarios
        scenarios.extend(self._create_input_validation_scenarios())
        
        return scenarios
    
    def _create_crypto_scenarios(self) -> List[VulnerabilityScenario]:
        """Create cryptographic vulnerability scenarios."""
        scenarios = []
        
        # Weak hash algorithm scenario
        scenarios.append(VulnerabilityScenario(
            name="weak_hash_detection",
            description="Trigger usage of weak hash algorithms (MD5, SHA1)",
            category=VulnerabilityCategory.CRYPTO_WEAKNESS,
            complexity=ScenarioComplexity.BASIC,
            cwe_ids=["CWE-327", "CWE-328"],
            masvs_controls=["V5.1", "V5.2"],
            steps=[
                {"action": "trigger_login", "data": "username:testuser,password:testpass"},
                {"action": "trigger_password_hash", "data": "password:weakpass123"},
                {"action": "trigger_data_hash", "data": "content:sensitive_data"}
            ],
            expected_detections=["weak_hash_algorithm", "md5_usage", "sha1_usage"],
            success_criteria=["Hash algorithm detection", "Stack trace captured"],
            preconditions=["App has login functionality", "App processes passwords"]
        ))
        
        # Weak encryption scenario
        scenarios.append(VulnerabilityScenario(
            name="weak_encryption_detection",
            description="Trigger usage of weak encryption algorithms (DES, RC4)",
            category=VulnerabilityCategory.CRYPTO_WEAKNESS,
            complexity=ScenarioComplexity.INTERMEDIATE,
            cwe_ids=["CWE-326", "CWE-327"],
            masvs_controls=["V5.1", "V5.3"],
            steps=[
                {"action": "trigger_data_encryption", "data": "content:sensitive_file_data"},
                {"action": "trigger_storage_encryption", "data": "file:secure_note.txt"},
                {"action": "trigger_communication_encryption", "data": "message:secure_chat"}
            ],
            expected_detections=["weak_encryption", "des_usage", "rc4_usage"],
            success_criteria=["Encryption algorithm detection", "Key size validation"],
            preconditions=["App has encryption features", "App stores encrypted data"]
        ))
        
        # Hardcoded key scenario
        scenarios.append(VulnerabilityScenario(
            name="hardcoded_key_detection", 
            description="Trigger usage of hardcoded encryption keys",
            category=VulnerabilityCategory.CRYPTO_WEAKNESS,
            complexity=ScenarioComplexity.ADVANCED,
            cwe_ids=["CWE-321", "CWE-798"],
            masvs_controls=["V5.2", "V5.3"],
            steps=[
                {"action": "trigger_key_generation", "data": "type:encryption_key"},
                {"action": "trigger_key_usage", "data": "operation:encrypt"},
                {"action": "trigger_key_storage", "data": "location:preferences"}
            ],
            expected_detections=["hardcoded_key", "static_key_usage"],
            success_criteria=["Key hardcoding detection", "Key derivation analysis"],
            preconditions=["App uses encryption", "App manages keys"]
        ))
        
        return scenarios
    
    def _create_network_scenarios(self) -> List[VulnerabilityScenario]:
        """Create network security vulnerability scenarios."""
        scenarios = []
        
        # Cleartext traffic scenario
        scenarios.append(VulnerabilityScenario(
            name="cleartext_traffic_detection",
            description="Trigger HTTP (non-HTTPS) network communications",
            category=VulnerabilityCategory.NETWORK_SECURITY,
            complexity=ScenarioComplexity.BASIC,
            cwe_ids=["CWE-319", "CWE-326"],
            masvs_controls=["V5.1", "V5.2"],
            steps=[
                {"action": "trigger_http_request", "data": "url:http://api.example.com/data"},
                {"action": "trigger_api_call", "data": "endpoint:http://insecure.api.com"},
                {"action": "trigger_data_sync", "data": "protocol:http"}
            ],
            expected_detections=["cleartext_traffic", "http_usage"],
            success_criteria=["HTTP request detection", "URL capture"],
            preconditions=["App makes network requests", "App has sync functionality"]
        ))
        
        # Certificate validation bypass scenario
        scenarios.append(VulnerabilityScenario(
            name="cert_validation_bypass",
            description="Trigger SSL certificate validation bypass attempts",
            category=VulnerabilityCategory.NETWORK_SECURITY,
            complexity=ScenarioComplexity.INTERMEDIATE,
            cwe_ids=["CWE-295", "CWE-297"],
            masvs_controls=["V5.3", "V5.4"],
            steps=[
                {"action": "trigger_ssl_connection", "data": "url:https://self-signed.example.com"},
                {"action": "trigger_cert_bypass", "data": "method:trust_all"},
                {"action": "trigger_hostname_bypass", "data": "method:allow_all"}
            ],
            expected_detections=["cert_bypass", "hostname_bypass", "trust_all_certs"],
            success_criteria=["Certificate bypass detection", "TrustManager analysis"],
            preconditions=["App uses HTTPS", "App has custom TrustManager"]
        ))
        
        # Insecure TLS configuration scenario
        scenarios.append(VulnerabilityScenario(
            name="insecure_tls_config",
            description="Trigger insecure TLS/SSL configuration usage",
            category=VulnerabilityCategory.NETWORK_SECURITY,
            complexity=ScenarioComplexity.ADVANCED,
            cwe_ids=["CWE-326", "CWE-327"],
            masvs_controls=["V5.3", "V5.4"],
            steps=[
                {"action": "trigger_weak_tls", "data": "version:TLSv1.0"},
                {"action": "trigger_weak_cipher", "data": "cipher:RC4"},
                {"action": "trigger_ssl_context", "data": "protocol:SSL"}
            ],
            expected_detections=["weak_tls", "weak_cipher", "insecure_ssl"],
            success_criteria=["TLS version detection", "Cipher suite analysis"],
            preconditions=["App configures TLS", "App has network security settings"]
        ))
        
        return scenarios
    
    def _create_storage_scenarios(self) -> List[VulnerabilityScenario]:
        """Create data storage vulnerability scenarios."""
        scenarios = []
        
        # External storage exposure scenario
        scenarios.append(VulnerabilityScenario(
            name="external_storage_exposure",
            description="Trigger sensitive data storage on external storage",
            category=VulnerabilityCategory.DATA_STORAGE,
            complexity=ScenarioComplexity.BASIC,
            cwe_ids=["CWE-922", "CWE-200"],
            masvs_controls=["V2.1", "V2.2"],
            steps=[
                {"action": "trigger_external_write", "data": "path:/sdcard/sensitive.txt"},
                {"action": "trigger_cache_write", "data": "path:/sdcard/Android/data/cache/"},
                {"action": "trigger_download_save", "data": "location:external"}
            ],
            expected_detections=["external_storage", "sdcard_write", "world_readable"],
            success_criteria=["External storage detection", "File path capture"],
            preconditions=["App saves files", "App has download functionality"]
        ))
        
        # Insecure database storage scenario
        scenarios.append(VulnerabilityScenario(
            name="insecure_database_storage",
            description="Trigger insecure database storage operations",
            category=VulnerabilityCategory.DATA_STORAGE,
            complexity=ScenarioComplexity.INTERMEDIATE,
            cwe_ids=["CWE-522", "CWE-200"],
            masvs_controls=["V2.1", "V2.3"],
            steps=[
                {"action": "trigger_db_create", "data": "name:sensitive.db"},
                {"action": "trigger_db_insert", "data": "table:users,data:passwords"},
                {"action": "trigger_db_query", "data": "sql:SELECT * FROM users"}
            ],
            expected_detections=["unencrypted_database", "plaintext_storage"],
            success_criteria=["Database operation detection", "SQL query capture"],
            preconditions=["App uses SQLite", "App stores user data"]
        ))
        
        # Insecure SharedPreferences scenario
        scenarios.append(VulnerabilityScenario(
            name="insecure_preferences_storage",
            description="Trigger insecure SharedPreferences storage",
            category=VulnerabilityCategory.DATA_STORAGE,
            complexity=ScenarioComplexity.BASIC,
            cwe_ids=["CWE-522", "CWE-200"],
            masvs_controls=["V2.1", "V2.2"],
            steps=[
                {"action": "trigger_prefs_store", "data": "key:password,value:secret123"},
                {"action": "trigger_prefs_store", "data": "key:token,value:abc123xyz"},
                {"action": "trigger_prefs_retrieve", "data": "key:sensitive_data"}
            ],
            expected_detections=["plaintext_preferences", "sensitive_prefs"],
            success_criteria=["SharedPreferences detection", "Key-value capture"],
            preconditions=["App uses SharedPreferences", "App stores settings"]
        ))
        
        return scenarios
    
    def _create_authentication_scenarios(self) -> List[VulnerabilityScenario]:
        """Create authentication vulnerability scenarios."""
        scenarios = []
        
        # Weak authentication scenario
        scenarios.append(VulnerabilityScenario(
            name="weak_authentication_bypass",
            description="Trigger weak authentication mechanisms",
            category=VulnerabilityCategory.AUTHENTICATION,
            complexity=ScenarioComplexity.INTERMEDIATE,
            cwe_ids=["CWE-287", "CWE-306"],
            masvs_controls=["V4.1", "V4.2"],
            steps=[
                {"action": "trigger_login_bypass", "data": "method:empty_password"},
                {"action": "trigger_pin_bypass", "data": "method:hardcoded_pin"},
                {"action": "trigger_biometric_bypass", "data": "method:fallback"}
            ],
            expected_detections=["weak_auth", "auth_bypass", "empty_password"],
            success_criteria=["Authentication bypass detection", "Method analysis"],
            preconditions=["App has authentication", "App has login screen"]
        ))
        
        # Session management scenario
        scenarios.append(VulnerabilityScenario(
            name="session_management_issues",
            description="Trigger session management vulnerabilities",
            category=VulnerabilityCategory.SESSION_MANAGEMENT,
            complexity=ScenarioComplexity.ADVANCED,
            cwe_ids=["CWE-384", "CWE-613"],
            masvs_controls=["V4.3", "V4.4"],
            steps=[
                {"action": "trigger_session_create", "data": "type:login_session"},
                {"action": "trigger_session_store", "data": "location:preferences"},
                {"action": "trigger_session_reuse", "data": "method:automatic"}
            ],
            expected_detections=["insecure_session", "session_fixation"],
            success_criteria=["Session handling detection", "Token analysis"],
            preconditions=["App manages sessions", "App has user accounts"]
        ))
        
        return scenarios
    
    def _create_authorization_scenarios(self) -> List[VulnerabilityScenario]:
        """Create authorization vulnerability scenarios."""
        scenarios = []
        
        # Privilege escalation scenario
        scenarios.append(VulnerabilityScenario(
            name="privilege_escalation",
            description="Trigger privilege escalation attempts",
            category=VulnerabilityCategory.AUTHORIZATION,
            complexity=ScenarioComplexity.ADVANCED,
            cwe_ids=["CWE-269", "CWE-284"],
            masvs_controls=["V4.5", "V4.6"],
            steps=[
                {"action": "trigger_admin_access", "data": "method:role_bypass"},
                {"action": "trigger_root_check", "data": "method:detection_bypass"},
                {"action": "trigger_permission_bypass", "data": "permission:sensitive"}
            ],
            expected_detections=["privilege_escalation", "root_bypass"],
            success_criteria=["Authorization bypass detection", "Role analysis"],
            preconditions=["App has user roles", "App checks permissions"]
        ))
        
        return scenarios
    
    def _create_input_validation_scenarios(self) -> List[VulnerabilityScenario]:
        """Create input validation vulnerability scenarios."""
        scenarios = []
        
        # Injection attack scenario
        scenarios.append(VulnerabilityScenario(
            name="injection_attacks",
            description="Trigger various injection attack vectors",
            category=VulnerabilityCategory.INPUT_VALIDATION,
            complexity=ScenarioComplexity.INTERMEDIATE,
            cwe_ids=["CWE-89", "CWE-79", "CWE-78"],
            masvs_controls=["V6.1", "V6.2"],
            steps=[
                {"action": "trigger_sql_injection", "data": "input:'; DROP TABLE users; --"},
                {"action": "trigger_xss_injection", "data": "input:<script>alert('xss')</script>"},
                {"action": "trigger_command_injection", "data": "input:; cat /etc/passwd"}
            ],
            expected_detections=["sql_injection", "xss_injection", "command_injection"],
            success_criteria=["Injection detection", "Input sanitization analysis"],
            preconditions=["App accepts user input", "App has search functionality"]
        ))
        
        return scenarios
    
    def run_crypto_scenarios(self) -> List[ScenarioExecution]:
        """Execute cryptographic vulnerability scenarios."""
        self.logger.info("🔐 Running cryptographic vulnerability scenarios")
        
        crypto_scenarios = [s for s in self.scenarios if s.category == VulnerabilityCategory.CRYPTO_WEAKNESS]
        executions = []
        
        for scenario in crypto_scenarios:
            execution = self.execute_scenario(scenario.name)
            if execution:
                executions.append(execution)
        
        self.logger.info(f"✅ Completed {len(executions)} crypto scenarios")
        return executions
    
    def run_network_scenarios(self) -> List[ScenarioExecution]:
        """Execute network security vulnerability scenarios."""
        self.logger.info("🌐 Running network security vulnerability scenarios")
        
        network_scenarios = [s for s in self.scenarios if s.category == VulnerabilityCategory.NETWORK_SECURITY]
        executions = []
        
        for scenario in network_scenarios:
            execution = self.execute_scenario(scenario.name)
            if execution:
                executions.append(execution)
        
        self.logger.info(f"✅ Completed {len(executions)} network scenarios")
        return executions
    
    def run_storage_scenarios(self) -> List[ScenarioExecution]:
        """Execute data storage vulnerability scenarios."""
        self.logger.info("📁 Running data storage vulnerability scenarios")
        
        storage_scenarios = [s for s in self.scenarios if s.category == VulnerabilityCategory.DATA_STORAGE]
        executions = []
        
        for scenario in storage_scenarios:
            execution = self.execute_scenario(scenario.name)
            if execution:
                executions.append(execution)
        
        self.logger.info(f"✅ Completed {len(executions)} storage scenarios")
        return executions
    
    def execute_scenario(self, scenario_name: str) -> Optional[ScenarioExecution]:
        """Execute a specific vulnerability scenario."""
        scenario = None
        for s in self.scenarios:
            if s.name == scenario_name:
                scenario = s
                break
        
        if not scenario:
            self.logger.error(f"❌ Unknown scenario: {scenario_name}")
            return None
        
        self.logger.info(f"🎯 Executing scenario: {scenario.name}")
        
        # Create execution tracker
        execution = ScenarioExecution(
            scenario_name=scenario.name,
            start_time=time.time(),
            status="running"
        )
        
        self.active_executions[scenario.name] = execution
        
        try:
            # Check preconditions
            if not self._verify_preconditions(scenario):
                self.logger.warning(f"⚠️ Preconditions not met for {scenario.name}")
                execution.status = "skipped"
                return execution
            
            # Execute scenario steps
            for i, step in enumerate(scenario.steps):
                step_result = self._execute_scenario_step(step, scenario)
                
                if step_result:
                    execution.steps_completed += 1
                else:
                    execution.steps_failed += 1
                    self.logger.warning(f"⚠️ Step {i+1} failed in {scenario.name}")
                
                # Wait for potential detections
                time.sleep(self.detection_wait)
                
                # Check for detections
                recent_detections = self._check_for_detections(scenario)
                execution.detections_triggered.extend(recent_detections)
                
                # Collect evidence if available
                evidence = self._collect_scenario_evidence(step, step_result)
                if evidence:
                    execution.evidence_collected.append(evidence)
            
            # Calculate effectiveness
            execution.effectiveness_score = self._calculate_scenario_effectiveness(execution, scenario)
            execution.status = "completed"
            execution.end_time = time.time()
            
            # Move to completed scenarios
            self.completed_scenarios.append(execution)
            del self.active_executions[scenario.name]
            
            self.logger.info(f"✅ Scenario {scenario.name} completed with effectiveness {execution.effectiveness_score:.2f}")
            return execution
            
        except Exception as e:
            self.logger.error(f"❌ Scenario {scenario.name} failed: {e}")
            execution.status = "failed"
            execution.end_time = time.time()
            return execution
    
    def _verify_preconditions(self, scenario: VulnerabilityScenario) -> bool:
        """Verify scenario preconditions are met."""
        # Simplified precondition checking
        # In real implementation, would check app capabilities
        return True
    
    def _execute_scenario_step(self, step: Dict[str, Any], scenario: VulnerabilityScenario) -> bool:
        """Execute a single scenario step."""
        action = step.get("action", "")
        data = step.get("data", "")
        
        try:
            self.logger.debug(f"🔧 Executing step: {action} with data: {data}")
            
            if action.startswith("trigger_login"):
                return self._trigger_login_action(data)
            elif action.startswith("trigger_password"):
                return self._trigger_password_action(data)
            elif action.startswith("trigger_data"):
                return self._trigger_data_action(data)
            elif action.startswith("trigger_http"):
                return self._trigger_http_action(data)
            elif action.startswith("trigger_ssl"):
                return self._trigger_ssl_action(data)
            elif action.startswith("trigger_external"):
                return self._trigger_external_storage_action(data)
            elif action.startswith("trigger_db"):
                return self._trigger_database_action(data)
            elif action.startswith("trigger_prefs"):
                return self._trigger_preferences_action(data)
            elif action.startswith("trigger_auth"):
                return self._trigger_auth_action(data)
            elif action.startswith("trigger_session"):
                return self._trigger_session_action(data)
            elif action.startswith("trigger_admin"):
                return self._trigger_admin_action(data)
            elif action.startswith("trigger_injection"):
                return self._trigger_injection_action(data)
            else:
                self.logger.debug(f"Unknown action: {action}")
                return False
                
        except Exception as e:
            self.logger.debug(f"Step execution failed: {e}")
            return False
    
    def _trigger_login_action(self, data: str) -> bool:
        """Trigger login-related actions."""
        # Parse data (e.g., "username:testuser,password:testpass")
        params = {}
        for param in data.split(','):
            if ':' in param:
                key, value = param.split(':', 1)
                params[key] = value
        
        # Simulate login attempt
        username = params.get('username', 'testuser')
        password = params.get('password', 'testpass')
        
        # Input username
        cmd = ['adb', 'shell', 'input', 'tap', '500', '400']
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'text', username]
        subprocess.run(cmd, capture_output=True, timeout=3)
        
        # Input password
        cmd = ['adb', 'shell', 'input', 'tap', '500', '500']
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'text', password]
        subprocess.run(cmd, capture_output=True, timeout=3)
        
        # Submit
        cmd = ['adb', 'shell', 'input', 'tap', '500', '600']
        subprocess.run(cmd, capture_output=True, timeout=3)
        
        return True
    
    def _trigger_password_action(self, data: str) -> bool:
        """Trigger password-related actions."""
        # Simulate password operations that might trigger hashing
        cmd = ['adb', 'shell', 'input', 'tap', '500', '300']  # Password field
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'text', 'WeakPassword123']
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '400']  # Confirm
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_data_action(self, data: str) -> bool:
        """Trigger data-related actions."""
        # Simulate data operations that might trigger encryption/hashing
        cmd = ['adb', 'shell', 'input', 'tap', '500', '350']
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'text', 'SensitiveDataToEncrypt']
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '450']  # Save/encrypt
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_http_action(self, data: str) -> bool:
        """Trigger HTTP-related actions."""
        # Simulate actions that might trigger HTTP requests
        cmd = ['adb', 'shell', 'input', 'swipe', '500', '200', '500', '600']  # Refresh
        subprocess.run(cmd, capture_output=True, timeout=3)
        time.sleep(2)
        return True
    
    def _trigger_ssl_action(self, data: str) -> bool:
        """Trigger SSL-related actions."""
        # Simulate actions that might trigger SSL/TLS operations
        cmd = ['adb', 'shell', 'input', 'tap', '600', '100']  # Network feature
        subprocess.run(cmd, capture_output=True, timeout=3)
        time.sleep(2)
        return True
    
    def _trigger_external_storage_action(self, data: str) -> bool:
        """Trigger external storage actions."""
        # Simulate file save operations
        cmd = ['adb', 'shell', 'input', 'tap', '400', '300']  # File menu
        subprocess.run(cmd, capture_output=True, timeout=3)
        time.sleep(1)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '400']  # Save option
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_database_action(self, data: str) -> bool:
        """Trigger database-related actions."""
        # Simulate database operations
        cmd = ['adb', 'shell', 'input', 'tap', '500', '300']  # Data field
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'text', 'DatabaseTestData']
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '500']  # Save to DB
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_preferences_action(self, data: str) -> bool:
        """Trigger SharedPreferences actions."""
        # Simulate preferences operations
        cmd = ['adb', 'shell', 'input', 'keyevent', 'KEYCODE_MENU']
        subprocess.run(cmd, capture_output=True, timeout=3)
        time.sleep(1)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '300']  # Settings
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '400']  # Toggle preference
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_auth_action(self, data: str) -> bool:
        """Trigger authentication bypass actions."""
        # Simulate authentication bypass attempts
        cmd = ['adb', 'shell', 'input', 'tap', '500', '400']  # Empty login
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '600']  # Submit
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_session_action(self, data: str) -> bool:
        """Trigger session management actions."""
        # Simulate session operations
        cmd = ['adb', 'shell', 'input', 'tap', '500', '300']  # Login
        subprocess.run(cmd, capture_output=True, timeout=3)
        time.sleep(2)
        cmd = ['adb', 'shell', 'input', 'keyevent', 'KEYCODE_BACK']  # Navigate away
        subprocess.run(cmd, capture_output=True, timeout=3)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '300']  # Return (session reuse)
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_admin_action(self, data: str) -> bool:
        """Trigger admin/privilege escalation actions."""
        # Simulate privilege escalation attempts
        cmd = ['adb', 'shell', 'input', 'tap', '600', '100']  # Admin menu
        subprocess.run(cmd, capture_output=True, timeout=3)
        time.sleep(1)
        cmd = ['adb', 'shell', 'input', 'tap', '500', '300']  # Admin function
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _trigger_injection_action(self, data: str) -> bool:
        """Trigger injection attack actions."""
        # Parse injection payload
        if 'input:' in data:
            payload = data.split('input:', 1)[1]
        else:
            payload = "'; DROP TABLE users; --"
        
        # Input malicious payload
        cmd = ['adb', 'shell', 'input', 'tap', '500', '300']  # Input field
        subprocess.run(cmd, capture_output=True, timeout=3)
        
        # Use quotes to handle special characters
        cmd = ['adb', 'shell', 'input', 'text', f'"{payload}"']
        subprocess.run(cmd, capture_output=True, timeout=3)
        
        cmd = ['adb', 'shell', 'input', 'tap', '500', '400']  # Submit
        subprocess.run(cmd, capture_output=True, timeout=3)
        return True
    
    def _check_for_detections(self, scenario: VulnerabilityScenario) -> List[str]:
        """Check for vulnerability detections related to scenario."""
        detections = []
        
        try:
            if self.hook_engine:
                # Check recent runtime events
                recent_events = getattr(self.hook_engine, 'runtime_events', [])
                current_time = time.time()
                
                # Look for events in the last few seconds
                recent = [
                    event for event in recent_events
                    if event.get('timestamp', 0) > current_time - self.detection_wait
                ]
                
                # Check if any events match expected detections
                for event in recent:
                    event_type = event.get('type', '')
                    for expected in scenario.expected_detections:
                        if expected.lower() in event_type.lower():
                            detections.append(expected)
            
            if self.vulnerability_detector:
                # Check recent vulnerability detections
                recent_vulns = getattr(self.vulnerability_detector, 'detected_vulnerabilities', [])
                
                # Look for vulnerabilities matching scenario expectations
                for vuln in recent_vulns[-5:]:  # Check last 5 detections
                    vuln_title = vuln.get('title', '').lower()
                    for expected in scenario.expected_detections:
                        if expected.lower() in vuln_title:
                            detections.append(expected)
            
        except Exception as e:
            self.logger.debug(f"Detection check failed: {e}")
        
        return list(set(detections))  # Remove duplicates
    
    def _collect_scenario_evidence(self, step: Dict[str, Any], step_result: bool) -> Optional[Dict[str, Any]]:
        """Collect evidence for scenario step execution."""
        if not self.evidence_collector:
            return None
        
        try:
            evidence = {
                "step_action": step.get("action", ""),
                "step_data": step.get("data", ""),
                "step_success": step_result,
                "timestamp": time.time(),
                "evidence_type": "scenario_execution"
            }
            
            # Add runtime context if available
            if self.hook_engine:
                recent_events = getattr(self.hook_engine, 'runtime_events', [])
                if recent_events:
                    evidence["runtime_events"] = recent_events[-3:]  # Last 3 events
            
            return evidence
            
        except Exception as e:
            self.logger.debug(f"Evidence collection failed: {e}")
            return None
    
    def _calculate_scenario_effectiveness(self, execution: ScenarioExecution, scenario: VulnerabilityScenario) -> float:
        """Calculate scenario execution effectiveness score."""
        # Base score from successful steps
        step_score = execution.steps_completed / max(1, len(scenario.steps))
        
        # Bonus for triggering expected detections
        detection_score = len(execution.detections_triggered) / max(1, len(scenario.expected_detections))
        
        # Evidence collection bonus
        evidence_score = min(1.0, len(execution.evidence_collected) / max(1, len(scenario.steps)))
        
        # Weighted effectiveness
        effectiveness = (
            step_score * 0.4 +           # 40% for completing steps
            detection_score * 0.4 +      # 40% for triggering detections
            evidence_score * 0.2         # 20% for evidence collection
        )
        
        return min(1.0, effectiveness)
    
    def get_scenario_summary(self) -> Dict[str, Any]:
        """Get summary of scenario execution results."""
        total_scenarios = len(self.scenarios)
        completed_scenarios = len(self.completed_scenarios)
        active_scenarios = len(self.active_executions)
        
        # Calculate aggregate statistics
        total_detections = sum(len(ex.detections_triggered) for ex in self.completed_scenarios)
        total_evidence = sum(len(ex.evidence_collected) for ex in self.completed_scenarios)
        avg_effectiveness = sum(ex.effectiveness_score for ex in self.completed_scenarios) / max(1, completed_scenarios)
        
        # Category breakdown
        category_stats = {}
        for execution in self.completed_scenarios:
            scenario = next((s for s in self.scenarios if s.name == execution.scenario_name), None)
            if scenario:
                cat = scenario.category.value
                if cat not in category_stats:
                    category_stats[cat] = {"completed": 0, "detections": 0, "effectiveness": 0.0}
                category_stats[cat]["completed"] += 1
                category_stats[cat]["detections"] += len(execution.detections_triggered)
                category_stats[cat]["effectiveness"] += execution.effectiveness_score
        
        # Average effectiveness per category
        for cat_stats in category_stats.values():
            if cat_stats["completed"] > 0:
                cat_stats["effectiveness"] /= cat_stats["completed"]
        
        return {
            "total_scenarios": total_scenarios,
            "completed_scenarios": completed_scenarios,
            "active_scenarios": active_scenarios,
            "total_detections": total_detections,
            "total_evidence_collected": total_evidence,
            "average_effectiveness": avg_effectiveness,
            "category_breakdown": category_stats,
            "available_categories": [cat.value for cat in VulnerabilityCategory],
            "scenario_execution_summary": [
                {
                    "name": ex.scenario_name,
                    "status": ex.status,
                    "effectiveness": ex.effectiveness_score,
                    "detections": len(ex.detections_triggered),
                    "duration": ex.end_time - ex.start_time if ex.end_time > 0 else 0
                }
                for ex in self.completed_scenarios
            ]
        }
    
    def get_available_scenarios(self, category: Optional[VulnerabilityCategory] = None) -> List[Dict[str, Any]]:
        """Get list of available scenarios, optionally filtered by category."""
        scenarios = self.scenarios
        if category:
            scenarios = [s for s in scenarios if s.category == category]
        
        return [
            {
                "name": scenario.name,
                "description": scenario.description,
                "category": scenario.category.value,
                "complexity": scenario.complexity.value,
                "cwe_ids": scenario.cwe_ids,
                "masvs_controls": scenario.masvs_controls,
                "expected_detections": scenario.expected_detections
            }
            for scenario in scenarios
        ]


# Convenience functions
def create_scenario_engine(package_name: str = None, apk_ctx: Any = None) -> VulnerabilityScenarioEngine:
    """Create vulnerability scenario engine instance."""
    return VulnerabilityScenarioEngine(package_name=package_name, apk_ctx=apk_ctx)


def execute_all_scenarios(package_name: str) -> Dict[str, Any]:
    """Execute all vulnerability scenarios for a package."""
    engine = VulnerabilityScenarioEngine(package_name=package_name)
    
    results = {
        "package_name": package_name,
        "start_time": time.time(),
        "scenario_results": {}
    }
    
    # Execute scenarios by category
    results["scenario_results"]["crypto"] = engine.run_crypto_scenarios()
    results["scenario_results"]["network"] = engine.run_network_scenarios()
    results["scenario_results"]["storage"] = engine.run_storage_scenarios()
    
    results["end_time"] = time.time()
    results["duration"] = results["end_time"] - results["start_time"]
    results["summary"] = engine.get_scenario_summary()
    
    return results


if __name__ == "__main__":
    # Demo usage
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python vulnerability_scenarios.py <package_name> [scenario_name]")
        sys.exit(1)
    
    package_name = sys.argv[1]
    scenario_name = sys.argv[2] if len(sys.argv) > 2 else None
    
    print(f"🎯 Vulnerability Scenario Engine Demo: {package_name}")
    print("=" * 50)
    
    engine = VulnerabilityScenarioEngine(package_name=package_name)
    
    if scenario_name:
        # Execute specific scenario
        result = engine.execute_scenario(scenario_name)
        if result:
            print(f"✅ Scenario {scenario_name} completed!")
            print(f"   Effectiveness: {result.effectiveness_score:.2f}")
            print(f"   Detections: {len(result.detections_triggered)}")
        else:
            print(f"❌ Scenario {scenario_name} failed!")
    else:
        # Execute all scenarios
        results = execute_all_scenarios(package_name)
        summary = results["summary"]
        print("✅ All scenarios completed!")
        print(f"📊 Summary:")
        print(f"   Completed: {summary['completed_scenarios']}/{summary['total_scenarios']}")
        print(f"   Detections: {summary['total_detections']}")
        print(f"   Avg Effectiveness: {summary['average_effectiveness']:.2f}")
        print(f"   Duration: {results['duration']:.1f}s")