#!/usr/bin/env python3
"""
Data structures for Advanced Vulnerability Detection Plugin

This module contains all dataclasses and type definitions used for
vulnerability analysis results aggregation.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any, Union
from enum import Enum

class SeverityLevel(Enum):
    """Enumeration for vulnerability severity levels."""
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"

class VulnerabilityCategory(Enum):
    """Enumeration for vulnerability categories."""
    SQL_INJECTION = "sql_injection"
    PATH_TRAVERSAL = "path_traversal"
    DATA_STORAGE = "data_storage"
    BACKUP_ANALYSIS = "backup_analysis"
    INJECTION_ATTACKS = "injection_attacks"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"

@dataclass
class VulnerabilityMatch:
    """Represents a single vulnerability match."""
    pattern: str
    match_text: str
    line_number: int
    column_start: int
    column_end: int
    context: str = ""
    severity: SeverityLevel = SeverityLevel.MEDIUM
    confidence: float = 0.0

@dataclass
class VulnerabilityFinding:
    """Represents a vulnerability finding in a class."""
    class_name: str
    vulnerability_type: str
    category: VulnerabilityCategory
    matches: List[VulnerabilityMatch] = field(default_factory=list)
    total_matches: int = 0
    max_severity: SeverityLevel = SeverityLevel.LOW
    confidence: float = 0.0
    description: str = ""
    remediation: str = ""
    masvs_control: str = ""
    
    def __post_init__(self) -> None:
        """Calculate derived fields after initialization."""
        self.total_matches = len(self.matches)
        if self.matches:
            severity_levels = [match.severity for match in self.matches]
            self.max_severity = max(severity_levels, key=lambda x: x.value)
            self.confidence = sum(match.confidence for match in self.matches) / len(self.matches)

@dataclass
class CategoryAnalysisResult:
    """Represents analysis results for a vulnerability category."""
    category: VulnerabilityCategory
    findings: List[VulnerabilityFinding] = field(default_factory=list)
    total_vulnerabilities: int = 0
    classes_analyzed: int = 0
    classes_with_issues: int = 0
    risk_score: float = 0.0
    
    def __post_init__(self) -> None:
        """Calculate derived fields after initialization."""
        self.total_vulnerabilities = sum(finding.total_matches for finding in self.findings)
        self.classes_with_issues = len([f for f in self.findings if f.total_matches > 0])

@dataclass
class DynamicTestResult:
    """Represents results from dynamic vulnerability testing."""
    test_name: str
    executed: bool = False
    success: bool = False
    findings: List[str] = field(default_factory=list)
    error_message: str = ""
    execution_time: float = 0.0

@dataclass
class VulnerabilityAnalysisResult:
    """Complete vulnerability analysis results."""
    sql_injection: CategoryAnalysisResult = field(default_factory=lambda: CategoryAnalysisResult(VulnerabilityCategory.SQL_INJECTION))
    path_traversal: CategoryAnalysisResult = field(default_factory=lambda: CategoryAnalysisResult(VulnerabilityCategory.PATH_TRAVERSAL))
    data_storage: CategoryAnalysisResult = field(default_factory=lambda: CategoryAnalysisResult(VulnerabilityCategory.DATA_STORAGE))
    backup_analysis: CategoryAnalysisResult = field(default_factory=lambda: CategoryAnalysisResult(VulnerabilityCategory.BACKUP_ANALYSIS))
    injection_attacks: CategoryAnalysisResult = field(default_factory=lambda: CategoryAnalysisResult(VulnerabilityCategory.INJECTION_ATTACKS))
    sensitive_data_exposure: CategoryAnalysisResult = field(default_factory=lambda: CategoryAnalysisResult(VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE))
    
    # Dynamic testing results
    dynamic_tests: List[DynamicTestResult] = field(default_factory=list)
    
    # Overall metrics
    overall_risk_score: float = 0.0
    total_vulnerabilities: int = 0
    total_classes_analyzed: int = 0
    categories_analyzed: List[str] = field(default_factory=list)
    analysis_duration: float = 0.0
    
    # Recommendations and compliance
    recommendations: List[str] = field(default_factory=list)
    masvs_controls: List[str] = field(default_factory=list)
    
    # Error tracking
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    
    @property
    def vulnerabilities(self) -> List[VulnerabilityFinding]:
        """Get all vulnerabilities from all categories."""
        all_vulns = []
        all_vulns.extend(self.sql_injection.findings)
        all_vulns.extend(self.path_traversal.findings)
        all_vulns.extend(self.data_storage.findings)
        all_vulns.extend(self.backup_analysis.findings)
        all_vulns.extend(self.injection_attacks.findings)
        all_vulns.extend(self.sensitive_data_exposure.findings)
        return all_vulns
    
    def __post_init__(self) -> None:
        """Calculate overall metrics after initialization."""
        self.total_vulnerabilities = sum([
            self.sql_injection.total_vulnerabilities,
            self.path_traversal.total_vulnerabilities,
            self.data_storage.total_vulnerabilities,
            self.backup_analysis.total_vulnerabilities,
            self.injection_attacks.total_vulnerabilities,
            self.sensitive_data_exposure.total_vulnerabilities
        ])
        
        self.total_classes_analyzed = max([
            self.sql_injection.classes_analyzed,
            self.path_traversal.classes_analyzed,
            self.data_storage.classes_analyzed,
            self.backup_analysis.classes_analyzed,
            self.injection_attacks.classes_analyzed,
            self.sensitive_data_exposure.classes_analyzed
        ])
        
        # Calculate overall risk score
        category_scores = [
            self.sql_injection.risk_score,
            self.path_traversal.risk_score,
            self.data_storage.risk_score,
            self.backup_analysis.risk_score,
            self.injection_attacks.risk_score,
            self.sensitive_data_exposure.risk_score
        ]
        self.overall_risk_score = sum(category_scores) / len([s for s in category_scores if s > 0]) if any(category_scores) else 0.0

@dataclass
class AnalysisConfiguration:
    """Configuration for vulnerability analysis."""
    max_findings_per_category: int = 50
    enable_dynamic_testing: bool = False
    device_timeout: int = 30
    parallel_workers: int = 4
    risk_thresholds: Dict[str, int] = field(default_factory=lambda: {
        "low": 10,
        "medium": 25,
        "high": 40,
        "critical": 60
    })
    
    def get_risk_level(self, score: float) -> SeverityLevel:
        """Get risk level based on score."""
        if score >= self.risk_thresholds["critical"]:
            return SeverityLevel.CRITICAL
        elif score >= self.risk_thresholds["high"]:
            return SeverityLevel.HIGH
        elif score >= self.risk_thresholds["medium"]:
            return SeverityLevel.MEDIUM
        else:
            return SeverityLevel.LOW

@dataclass
class CompiledPattern:
    """Represents a compiled regex pattern for efficient matching."""
    pattern: str
    compiled_regex: Any  # re.Pattern type
    category: str
    subcategory: str
    description: str = ""
    severity: SeverityLevel = SeverityLevel.MEDIUM
    confidence_weight: float = 1.0 