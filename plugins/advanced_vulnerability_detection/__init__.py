#!/usr/bin/env python3
"""
Advanced Vulnerability Detection Module

This module provides a refactored, modular approach to vulnerability detection
with improved performance, maintainability, and accuracy.

Components:
- data_structures: Structured dataclasses for results
- class_analysis_helper: Universal class analyzer with parallelization
- formatters: Output formatting functions
- patterns_config.yaml: External configuration for patterns
"""

from typing import Tuple, Union, Optional
import logging
from rich.text import Text

from .data_structures import (
    VulnerabilityAnalysisResult,
    AnalysisConfiguration,
    VulnerabilityCategory,
    SeverityLevel,
    VulnerabilityFinding,
    VulnerabilityMatch,
    CategoryAnalysisResult,
    DynamicTestResult,
    CompiledPattern
)

from .class_analysis_helper import (
    UniversalClassAnalyzer,
    ClassAnalysisContext,
    create_pattern_analyzer
)

from .formatters import (
    format_vulnerability_results,
    enhance_with_masvs_mapping,
    generate_summary_text,
    format_error_context,
    get_severity_style,
    get_risk_level_text
)

__version__ = "2.0.0"
__author__ = "AODS Development Team"

# Initialize logger for the module
logger = logging.getLogger(__name__)

# Export main interface
__all__ = [
    'AdvancedVulnerabilityDetectionPlugin',
    'create_vulnerability_detector',
    'AdvancedVulnerabilityAnalysisResult',
    'VulnerabilityConfig',
    'SecurityVulnerability',
    'VulnerabilityType',
    'VulnerabilitySeverity',
    'VulnerabilityConfidenceCalculator',
    'run',
    'run_plugin'
]

class AdvancedVulnerabilityDetectionPlugin:
    """Advanced vulnerability detection plugin with modular architecture."""
    
    def __init__(self, config: Optional[AnalysisConfiguration] = None):
        """Initialize the plugin with configuration."""
        self.config = config or AnalysisConfiguration()
        
    def analyze_vulnerabilities(self, apk_ctx) -> VulnerabilityAnalysisResult:
        """Perform comprehensive vulnerability analysis."""
        try:
            # Create universal analyzer
            analyzer = UniversalClassAnalyzer(apk_ctx, self.config)
            
            # Compile patterns for all categories
            from pathlib import Path
            import yaml
            
            patterns_file = Path(__file__).parent / "patterns_config.yaml"
            if patterns_file.exists():
                with open(patterns_file, 'r') as f:
                    patterns_config = yaml.safe_load(f)
            else:
                patterns_config = {}
            
            # Analyze key vulnerability categories
            categories = [
                VulnerabilityCategory.SQL_INJECTION,
                VulnerabilityCategory.PATH_TRAVERSAL,
                VulnerabilityCategory.INJECTION_ATTACKS,  # FIXED: Use correct category name
                VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE  # FIXED: Use correct category name
            ]
            
            # Create result object and populate category-specific results
            analysis_result = VulnerabilityAnalysisResult()
            category_mapping = {
                VulnerabilityCategory.SQL_INJECTION: 'sql_injection',
                VulnerabilityCategory.PATH_TRAVERSAL: 'path_traversal',
                VulnerabilityCategory.INJECTION_ATTACKS: 'injection_attacks',  # FIXED: Direct mapping
                VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: 'sensitive_data_exposure'  # FIXED: Direct mapping
            }
            
            all_findings = []
            failed_categories = []
            successful_categories = []
            
            for category in categories:
                try:
                    category_patterns = patterns_config.get(category.value, {})
                    if not category_patterns:
                        logger.debug(f"No patterns found for category {category.value}")
                        failed_categories.append(f"{category.value}: no patterns")
                        continue
                        
                    analyzer.compile_patterns(category_patterns, category)
                    category_result = analyzer.analyze_category_parallel(
                        category, 
                        create_pattern_analyzer,
                        f"Analyzing {category.value}"
                    )
                    all_findings.extend(category_result.findings)
                    successful_categories.append(category.value)
                    
                    # Store result in appropriate category field
                    if category in category_mapping:
                        field_name = category_mapping[category]
                        if hasattr(analysis_result, field_name):
                            setattr(analysis_result, field_name, category_result)
                            logger.debug(f"Successfully analyzed {category.value}: {len(category_result.findings)} findings")
                        else:
                            logger.warning(f"Unknown field mapping for category {category.value}")
                    else:
                        logger.warning(f"No mapping defined for category {category.value}")
                        
                except Exception as e:
                    error_msg = f"Error analyzing {category.value}: {e}"
                    logger.warning(error_msg)
                    failed_categories.append(f"{category.value}: {str(e)}")
                    analysis_result.errors.append(error_msg)
                    continue
            
            # Set metadata
            analysis_result.total_classes_analyzed = (
                getattr(apk_ctx, 'classes', []) if hasattr(apk_ctx, 'classes') else []
            )
            analysis_result.categories_analyzed = [cat.value for cat in categories]
            analysis_result.analysis_duration = 0.0  # Could be measured
            
            # Add analysis summary to warnings if there were issues
            if failed_categories:
                summary_warning = f"Failed to analyze {len(failed_categories)} categories: {', '.join(failed_categories)}"
                analysis_result.warnings.append(summary_warning)
                logger.info(summary_warning)
            
            # Log successful analysis summary
            logger.info(f"Advanced vulnerability detection completed:")
            logger.info(f"  • Successful categories: {len(successful_categories)} ({', '.join(successful_categories)})")
            logger.info(f"  • Failed categories: {len(failed_categories)}")
            logger.info(f"  • Total findings: {len(all_findings)}")
            logger.info(f"  • Total vulnerabilities: {analysis_result.total_vulnerabilities}")
            
            return analysis_result
            
        except Exception as e:
            logger.error(f"Vulnerability analysis failed: {e}")
            logger.error(f"APK: {getattr(apk_ctx, 'apk_path', 'unknown')}")
            logger.error(f"Package: {getattr(apk_ctx, 'package_name', 'unknown')}")
            
            # Create error result with context
            error_result = VulnerabilityAnalysisResult()
            error_result.errors.append(f"Critical analysis failure: {str(e)}")
            error_result.warnings.append("Analysis terminated due to unexpected error")
            return error_result  # FIXED: Return properly initialized result with error context

# Plugin compatibility functions
def run(apk_ctx) -> Tuple[str, Union[str, Text]]:
    """
    Main plugin entry point for compatibility with plugin manager.
    
    Args:
        apk_ctx: APK context object
        
    Returns:
        Tuple of (plugin_name, result)
    """
    try:
        # Create plugin with default configuration
        plugin = AdvancedVulnerabilityDetectionPlugin()
        
        # Perform analysis
        result = plugin.analyze_vulnerabilities(apk_ctx)
        
        # Format results
        if result.vulnerabilities:
            vuln_text = Text()
            vuln_text.append(f"Advanced Vulnerability Detection - {len(result.vulnerabilities)} vulnerabilities\n", style="bold red")
            
            for vuln in result.vulnerabilities[:10]:  # Limit to first 10 vulnerabilities
                severity_style = "red" if vuln.severity.name == "CRITICAL" else "yellow" if vuln.severity.name == "HIGH" else "blue"
                vuln_text.append(f"• {vuln.title}\n", style=severity_style)
                vuln_text.append(f"  {vuln.description}\n", style="dim")
        else:
            vuln_text = Text("Advanced Vulnerability Detection completed - No vulnerabilities found", style="green")
            
        return "Advanced Vulnerability Detection", vuln_text
        
    except Exception as e:
        logger.error(f"Advanced vulnerability detection failed: {e}")
        error_text = Text(f"Advanced Vulnerability Detection Error: {str(e)}", style="red")
        return "Advanced Vulnerability Detection", error_text

def run_plugin(apk_ctx) -> Tuple[str, Union[str, Text]]:
    """
    Plugin interface function expected by the plugin manager.
    
    Args:
        apk_ctx: APK context object
        
    Returns:
        Tuple of (plugin_name, result)
    """
    return run(apk_ctx) 