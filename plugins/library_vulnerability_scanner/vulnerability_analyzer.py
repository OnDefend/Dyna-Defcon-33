"""
Vulnerability Analyzer for Library Vulnerability Scanner

This module contains the core vulnerability analysis logic that checks
detected libraries against the vulnerability database and performs
sophisticated version comparisons and security assessments.

Features:
- Library-specific vulnerability checking
- Semantic version comparison
- Risk assessment and scoring
- Evidence-based confidence calculation
- Attack vector analysis
"""

import logging
import re
from typing import Dict, List, Optional, Tuple, Any
from packaging import version as pkg_version

from .data_structures import (
    LibraryInfo, LibraryVulnerability, VulnerabilitySeverity, 
    ExploitabilityLevel, LibraryType, ConfidenceEvidence
)
from .vulnerability_database import vulnerability_database
from .confidence_calculator import LibraryVulnerabilityConfidenceCalculator

logger = logging.getLogger(__name__)

class LibraryVulnerabilityAnalyzer:
    """Comprehensive vulnerability analyzer for detected libraries."""
    
    def __init__(self, apk_ctx):
        """Initialize the vulnerability analyzer."""
        self.apk_ctx = apk_ctx
        self.vulnerability_db = vulnerability_database
        self.confidence_calculator = LibraryVulnerabilityConfidenceCalculator()
        
        # Analysis results
        self.vulnerabilities: List[LibraryVulnerability] = []
        
        # Version comparison cache
        self.version_cache: Dict[str, Any] = {}
    
    def analyze_libraries(self, detected_libraries: List[LibraryInfo]) -> List[LibraryVulnerability]:
        """Analyze detected libraries for vulnerabilities."""
        logger.info(f"Analyzing {len(detected_libraries)} libraries for vulnerabilities")
        
        self.vulnerabilities.clear()
        
        for library in detected_libraries:
            try:
                self._analyze_library_vulnerabilities(library)
            except Exception as e:
                logger.error(f"Failed to analyze library {library.name}: {e}")
        
        logger.info(f"Vulnerability analysis completed. Found {len(self.vulnerabilities)} vulnerabilities")
        return self.vulnerabilities
    
    def _analyze_library_vulnerabilities(self, library: LibraryInfo) -> None:
        """Analyze a single library for vulnerabilities."""
        # Check library-specific vulnerabilities
        if library.name == "openssl":
            self._check_openssl_vulnerabilities(library)
        elif library.name == "okhttp":
            self._check_okhttp_vulnerabilities(library)
        elif library.name == "libjpeg_turbo":
            self._check_libjpeg_vulnerabilities(library)
        elif library.name == "libpng":
            self._check_libpng_vulnerabilities(library)
        elif library.name == "joda_time":
            self._check_joda_vulnerabilities(library)
        elif library.name == "jackson_databind":
            self._check_jackson_vulnerabilities(library)
        elif library.name == "retrofit":
            self._check_retrofit_vulnerabilities(library)
        elif library.name == "gson":
            self._check_gson_vulnerabilities(library)
        
        # Generic vulnerability checking
        self._check_generic_vulnerabilities(library)
    
    def _check_openssl_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check OpenSSL for HeartBleed and other vulnerabilities."""
        # Check for HeartBleed vulnerability
        heartbleed_vuln = self.vulnerability_db.get_vulnerability("openssl_heartbleed")
        if heartbleed_vuln and self._is_version_affected(library.version, heartbleed_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, heartbleed_vuln, "HeartBleed Memory Disclosure"
            )
            self.vulnerabilities.append(vulnerability)
        
        # Check for Change Cipher Spec Injection
        ccs_vuln = self.vulnerability_db.get_vulnerability("openssl_ccs_injection")
        if ccs_vuln and self._is_version_affected(library.version, ccs_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, ccs_vuln, "Change Cipher Spec Injection"
            )
            self.vulnerabilities.append(vulnerability)
    
    def _check_okhttp_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check OkHTTP for certificate pinning and other vulnerabilities."""
        # Check for certificate pinning bypass
        pinning_vuln = self.vulnerability_db.get_vulnerability("okhttp_cert_pinning_bypass")
        if pinning_vuln and self._is_version_affected(library.version, pinning_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, pinning_vuln, "Certificate Pinning Bypass"
            )
            self.vulnerabilities.append(vulnerability)
        
        # Check for HTTP/2 DoS
        http2_vuln = self.vulnerability_db.get_vulnerability("okhttp_http2_dos")
        if http2_vuln and self._is_version_affected(library.version, http2_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, http2_vuln, "HTTP/2 Denial of Service"
            )
            self.vulnerabilities.append(vulnerability)
    
    def _check_libjpeg_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check libjpeg-turbo for buffer overflow vulnerabilities."""
        buffer_overflow_vuln = self.vulnerability_db.get_vulnerability("libjpeg_turbo_buffer_overflow")
        if buffer_overflow_vuln and self._is_version_affected(library.version, buffer_overflow_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, buffer_overflow_vuln, "Buffer Overflow in JPEG Processing"
            )
            self.vulnerabilities.append(vulnerability)
    
    def _check_libpng_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check libpng for integer overflow vulnerabilities."""
        integer_overflow_vuln = self.vulnerability_db.get_vulnerability("libpng_integer_overflow")
        if integer_overflow_vuln and self._is_version_affected(library.version, integer_overflow_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, integer_overflow_vuln, "Integer Overflow in PNG Processing"
            )
            self.vulnerabilities.append(vulnerability)
    
    def _check_joda_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check Joda Time for parsing vulnerabilities."""
        parsing_vuln = self.vulnerability_db.get_vulnerability("joda_time_parsing")
        if parsing_vuln and self._is_version_affected(library.version, parsing_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, parsing_vuln, "Date Parsing Denial of Service"
            )
            self.vulnerabilities.append(vulnerability)
    
    def _check_jackson_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check Jackson Databind for RCE vulnerabilities."""
        rce_vuln = self.vulnerability_db.get_vulnerability("jackson_databind_rce")
        if rce_vuln and self._is_version_affected(library.version, rce_vuln.affected_versions):
            vulnerability = self._create_vulnerability_finding(
                library, rce_vuln, "Remote Code Execution via Deserialization"
            )
            self.vulnerabilities.append(vulnerability)
    
    def _check_retrofit_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check Retrofit for known vulnerabilities."""
        # Retrofit typically inherits vulnerabilities from OkHTTP
        # Check if OkHTTP vulnerabilities apply
        self._check_transitive_vulnerabilities(library, "okhttp")
    
    def _check_gson_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check Gson for known vulnerabilities."""
        # Check for potential deserialization issues
        if self._is_version_potentially_vulnerable(library.version, ["2.8.0", "2.8.1", "2.8.2"]):
            vulnerability = LibraryVulnerability(
                library_name=library.name,
                version=library.version,
                vulnerability_id=f"gson_potential_vuln_{library.version}",
                cve_id="N/A",
                severity=VulnerabilitySeverity.MEDIUM,
                confidence=0.6,
                description="Potential deserialization vulnerability in Gson",
                location=library.location,
                evidence=f"Using potentially vulnerable Gson version {library.version}",
                attack_vectors=["JSON deserialization attacks"],
                remediation="Update to latest Gson version",
                exploitability=ExploitabilityLevel.LOCAL
            )
            self.vulnerabilities.append(vulnerability)
    
    def _check_generic_vulnerabilities(self, library: LibraryInfo) -> None:
        """Check for generic vulnerabilities applicable to library type."""
        applicable_vulns = self.vulnerability_db.get_vulnerabilities_by_library_type(library.library_type)
        
        for vuln_entry in applicable_vulns:
            # Check if any detection patterns match
            for pattern in vuln_entry.detection_patterns:
                if re.search(pattern, library.name, re.IGNORECASE):
                    if self._is_version_affected(library.version, vuln_entry.affected_versions):
                        vulnerability = self._create_vulnerability_finding(
                            library, vuln_entry, f"Generic {library.library_type.value} vulnerability"
                        )
                        self.vulnerabilities.append(vulnerability)
    
    def _check_transitive_vulnerabilities(self, library: LibraryInfo, dependency_name: str) -> None:
        """Check for vulnerabilities in transitive dependencies."""
        # This is a simplified implementation - could be enhanced with dependency graphs
        dependency_vulns = [
            entry for entry in self.vulnerability_db.vulnerability_db.values()
            if dependency_name in entry.vulnerability_id
        ]
        
        for vuln_entry in dependency_vulns:
            vulnerability = LibraryVulnerability(
                library_name=library.name,
                version=library.version,
                vulnerability_id=f"{library.name}_transitive_{vuln_entry.vulnerability_id}",
                cve_id=vuln_entry.cve_id,
                severity=vuln_entry.severity,
                confidence=0.5,  # Lower confidence for transitive vulnerabilities
                description=f"Transitive vulnerability via {dependency_name}: {vuln_entry.description}",
                location=library.location,
                evidence=f"Library {library.name} may use vulnerable {dependency_name}",
                attack_vectors=vuln_entry.attack_vectors,
                remediation=f"Update {library.name} to version that uses secure {dependency_name}",
                exploitability=vuln_entry.exploitability,
                library_type=library.library_type
            )
            self.vulnerabilities.append(vulnerability)
    
    def _create_vulnerability_finding(self, library: LibraryInfo, vuln_entry, title: str) -> LibraryVulnerability:
        """Create a vulnerability finding with evidence-based confidence."""
        # Prepare evidence for confidence calculation
        evidence = ConfidenceEvidence(
            detection_method=library.detection_method,
            pattern_matches=len(library.detection_patterns),
            pattern_quality=0.8,  # Based on pattern reliability
            version_certainty=self._calculate_version_certainty(library.version),
            file_context=library.location,
            location_relevance=0.9,  # Library location is highly relevant
            cross_validation=len(library.evidence_sources) > 1,
            library_popularity=self._get_library_popularity(library.name),
            vendor_reputation=self._get_vendor_reputation(library.vendor),
            update_frequency=0.7,  # Assumption
            cve_validation=bool(vuln_entry.cve_id and vuln_entry.cve_id != "N/A"),
            exploit_availability=self._check_exploit_availability(vuln_entry.cve_id),
            patch_availability=bool(vuln_entry.fixed_version),
            validation_sources=library.evidence_sources
        )
        
        # Calculate professional confidence
        confidence = self.confidence_calculator.calculate_vulnerability_confidence(
            library, vuln_entry, evidence
        )
        
        vulnerability = LibraryVulnerability(
            library_name=library.name,
            version=library.version,
            vulnerability_id=f"{library.name}_{vuln_entry.vulnerability_id}",
            cve_id=vuln_entry.cve_id,
            severity=vuln_entry.severity,
            confidence=confidence,
            description=vuln_entry.description,
            location=library.location,
            evidence=f"Library {library.name} version {library.version} detected via {library.detection_method.value}",
            attack_vectors=vuln_entry.attack_vectors,
            remediation=vuln_entry.remediation,
            affected_versions=vuln_entry.affected_versions,
            fixed_version=vuln_entry.fixed_version,
            references=vuln_entry.references,
            impact=vuln_entry.impact,
            exploitability=vuln_entry.exploitability,
            cvss_score=vuln_entry.cvss_score,
            library_type=library.library_type,
            detection_method=library.detection_method
        )
        
        return vulnerability
    
    def _is_version_affected(self, current_version: str, affected_versions: List[str]) -> bool:
        """Check if current version is in the list of affected versions."""
        if current_version in ["unknown", "detected"]:
            return True  # Conservative approach - assume vulnerable
        
        try:
            # Try semantic version comparison first
            current_ver = pkg_version.parse(current_version)
            
            for affected_ver in affected_versions:
                try:
                    affected_ver_parsed = pkg_version.parse(affected_ver)
                    if current_ver == affected_ver_parsed:
                        return True
                except Exception:
                    # Fall back to string comparison
                    if current_version == affected_ver:
                        return True
            
            return False
            
        except Exception:
            # Fall back to string comparison
            return current_version in affected_versions
    
    def _is_version_potentially_vulnerable(self, current_version: str, vulnerable_versions: List[str]) -> bool:
        """Check if version is potentially vulnerable (more lenient check)."""
        if current_version in ["unknown", "detected"]:
            return True
        
        try:
            current_ver = pkg_version.parse(current_version)
            
            for vuln_ver in vulnerable_versions:
                try:
                    vuln_ver_parsed = pkg_version.parse(vuln_ver)
                    # Check if current version is in potentially vulnerable range
                    if current_ver <= vuln_ver_parsed:
                        return True
                except Exception:
                    continue
                    
        except Exception:
            pass
        
        return False
    
    def _calculate_version_certainty(self, version: str) -> float:
        """Calculate certainty level for version detection."""
        if version in ["unknown", "detected"]:
            return 0.3
        elif re.match(r'^\d+\.\d+\.\d+$', version):
            return 0.9  # Full semantic version
        elif re.match(r'^\d+\.\d+$', version):
            return 0.7  # Major.minor version
        elif re.match(r'^\d+$', version):
            return 0.5  # Major version only
        else:
            return 0.6  # Other version format
    
    def _get_library_popularity(self, library_name: str) -> float:
        """Get library popularity score (simplified)."""
        # Popularity scores based on common usage
        popularity_scores = {
            "openssl": 0.95,
            "okhttp": 0.9,
            "gson": 0.85,
            "retrofit": 0.8,
            "jackson_databind": 0.75,
            "joda_time": 0.7,
            "libjpeg_turbo": 0.6,
            "libpng": 0.65
        }
        
        return popularity_scores.get(library_name, 0.5)
    
    def _get_vendor_reputation(self, vendor: str) -> float:
        """Get vendor reputation score (simplified)."""
        # Reputation scores based on vendor track record
        reputation_scores = {
            "Google": 0.9,
            "Square Inc.": 0.85,
            "OpenSSL Software Foundation": 0.8,
            "FasterXML": 0.75,
            "Joda.org": 0.7
        }
        
        return reputation_scores.get(vendor, 0.6)
    
    def _check_exploit_availability(self, cve_id: str) -> bool:
        """Check if exploits are available for the CVE (simplified)."""
        # This could be enhanced with real exploit database queries
        high_profile_cves = [
            "CVE-2014-0160",  # HeartBleed
            "CVE-2014-0224",  # CCS Injection
            "CVE-2019-12384"  # Jackson RCE
        ]
        
        return cve_id in high_profile_cves 