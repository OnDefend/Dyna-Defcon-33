#!/usr/bin/env python3
"""
Enhanced Vulnerability Filter for AODS
=====================================

Advanced false positive reduction system that accurately distinguishes between
real security vulnerabilities and informational/analysis content.

Addresses the major issue where scan reports, analysis summaries, and 
informational content are incorrectly classified as vulnerabilities.

"""

import re
import logging
from typing import Dict, List, Any, Tuple, Optional
from enum import Enum
from dataclasses import dataclass
from collections import defaultdict

class FilterResult(Enum):
    """Filter decision results"""
    VULNERABILITY = "vulnerability"
    INFORMATIONAL = "informational" 
    FALSE_POSITIVE = "false_positive"
    ANALYSIS_REPORT = "analysis_report"
    SUCCESS_INDICATOR = "success_indicator"

@dataclass
class FilterDecision:
    """Enhanced filter decision with detailed reasoning"""
    result: FilterResult
    confidence: float
    reasoning: List[str]
    original_severity: str
    suggested_severity: str
    evidence: List[str]
    false_positive_indicators: List[str]

class EnhancedVulnerabilityFilter:
    """
    Ultimate accuracy vulnerability filter that eliminates false positives
    by distinguishing between actual vulnerabilities and informational content.
    """
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Enhanced pattern categories for precise filtering
        self.success_patterns = self._initialize_success_patterns()
        self.analysis_report_patterns = self._initialize_analysis_report_patterns() 
        self.informational_patterns = self._initialize_informational_patterns()
        self.false_positive_patterns = self._initialize_false_positive_patterns()
        self.true_vulnerability_patterns = self._initialize_true_vulnerability_patterns()
        
        # Statistics tracking
        self.filter_stats = defaultdict(int)
        
    def _initialize_success_patterns(self) -> List[re.Pattern]:
        """Patterns that indicate successful security checks (not vulnerabilities)"""
        patterns = [
            # Explicit success indicators
            r"(?i)(?:no\s+vulnerabilities?\s+(?:found|detected|identified))",
            r"(?i)(?:vulnerabilities?\s*:\s*(?:0|none|null|\[\]))",
            r"(?i)(?:all\s+)?(?:tests?\s+)?(?:passed|successful|ok|secure)",
            r"(?i)status\s*:\s*(?:pass|passed|success|ok|secure)",
            r"(?i)(?:security\s+)?(?:analysis|check|test)\s+(?:complete|completed|successful)",
            r"(?i)(?:0\s+(?:findings|vulnerabilities|issues)|no\s+(?:findings|issues)\s+(?:found|identified))",
            r"(?i)(?:✅|✓|\[green\]|\[✓\]).*?(?:no\s+(?:vulnerabilities|security\s+concerns|issues))",
            r"(?i)(?:good\s+security\s+practices|indicates\s+good\s+security)",
            r"(?i)(?:compliance\s+score|passed).*?(?:100%|100\.0%)",
            
            # Report generation success (not vulnerabilities)
            r"(?i)report\s+generation\s+(?:complete|successful)",
            r"(?i)generated\s+\d+\s+(?:professional\s+)?reports?",
            r"(?i)(?:executive|technical|compliance)\s+report.*?generated",
            
            # Analysis completion indicators
            r"(?i)analysis\s+(?:complete|completed|summary)",
            r"(?i)(?:total\s+)?endpoints?\s+discovered:\s*0",
            r"(?i)(?:successfully\s+executed|completed\s+in)",
            r"(?i)(?:efficiency|success\s+rate):\s*100%",
        ]
        return [re.compile(pattern, re.IGNORECASE | re.MULTILINE | re.DOTALL) for pattern in patterns]
    
    def _initialize_analysis_report_patterns(self) -> List[re.Pattern]:
        """Patterns that indicate analysis reports/summaries (not vulnerabilities)"""
        patterns = [
            # Report headers and summaries
            r"(?i)(?:executive|technical|compliance|professional)\s+(?:summary|report)",
            r"(?i)(?:analysis|security)\s+(?:report|summary|complete)",
            r"(?i)(?:plugin\s+execution|parallel\s+execution)\s+(?:summary|report)",
            r"(?i)(?:performance\s+report|execution\s+time)",
            r"(?i)(?:mastg|owasp)\s+(?:compliance|integration)\s+(?:report|testing)",
            r"(?i)(?:attack\s+surface|endpoint\s+discovery)\s+analysis",
            r"(?i)(?:enhanced|advanced)\s+(?:static|dynamic|encoding)\s+analysis",
            
            # Metadata and configuration info
            r"(?i)(?:total\s+(?:plugins|tests|endpoints)|completed\s+successfully)",
            r"(?i)(?:file\s+size|path\s*:|generated\s+files)",
            r"(?i)(?:analysis\s+metadata|security\s+recommendations)",
            r"(?i)(?:usage\s+instructions|open\s+html\s+files)",
            
            # Technical details (not vulnerabilities)
            r"(?i)(?:package\s*:|attempting\s+to\s+run|selecting\s+[a-f0-9]+)",
            r"(?i)(?:drozer\s+command|shell\s+module)",
            r"(?i)(?:no\s+(?:exported\s+services|matching\s+receivers|matching\s+providers))",
            r"(?i)(?:encryption\s+patterns|cloud\s+service\s+patterns)\s+analyzed",
        ]
        return [re.compile(pattern, re.IGNORECASE | re.MULTILINE | re.DOTALL) for pattern in patterns]
    
    def _initialize_informational_patterns(self) -> List[re.Pattern]:
        """Patterns that indicate informational content (not vulnerabilities)"""
        patterns = [
            # Security recommendations (not active vulnerabilities)
            r"(?i)(?:security\s+)?recommendations?:",
            r"(?i)(?:consider\s+(?:disabling|implementing|using)|regularly\s+(?:audit|update))",
            r"(?i)(?:follow\s+secure\s+coding\s+practices|owasp\s+guidelines)",
            r"(?i)(?:use\s+(?:strong|proper|established)|implement\s+proper)",
            
            # Configuration advice (not vulnerabilities)
            r"(?i)(?:android\s+keystore|jetpack\s+security|cryptographic\s+libraries)",
            r"(?i)(?:certificate\s+pinning|security\s+rules|access\s+logging)",
            r"(?i)(?:input\s+validation|error\s+handling|code\s+obfuscation)",
            
            # Analysis metadata (not vulnerabilities)
            r"(?i)(?:patterns?\s+analyzed|detection\s+(?:enabled|disabled))",
            r"(?i)(?:live\s+validation|endpoint\s+accessibility)",
            r"(?i)(?:enhanced\s+detection|specific\s+patterns)",
            
            # Development/testing context
            r"(?i)(?:injuredandroid|commercial\/production\s+app)",
            r"(?i)(?:vulnerability\s+patterns\s+not\s+applicable)",
            r"(?i)(?:standard\s+security\s+controls\s+verified)",
        ]
        return [re.compile(pattern, re.IGNORECASE | re.MULTILINE | re.DOTALL) for pattern in patterns]
    
    def _initialize_false_positive_patterns(self) -> List[re.Pattern]:
        """Patterns that strongly indicate false positives"""
        patterns = [
            # Status-based false positives
            r"(?i)status\s*:\s*(?:pass|passed|success|ok)",
            r"(?i)result\s*:\s*(?:pass|passed|success|ok)",
            
            # Zero-finding indicators
            r"(?i)(?:total\s+findings?|security\s+findings?):\s*0",
            r"(?i)(?:vulnerabilities?|issues?):\s*(?:0|none|null|\[\])",
            r"(?i)(?:no\s+(?:immediate\s+)?security\s+concerns?\s+identified)",
            
            # Successful completion indicators  
            r"(?i)(?:all\s+discovered\s+plugins|successfully\s+executed)",
            r"(?i)(?:no\s+failures|excellent\s+(?:performance|efficiency))",
            r"(?i)(?:100%\s+(?:success\s+rate|efficiency))",
            
            # Analysis completion (not vulnerability)
            r"(?i)(?:analysis\s+complete|successfully\s+extracted)",
            r"(?i)(?:compilation\s+successful|integration\s+initialized)",
        ]
        return [re.compile(pattern, re.IGNORECASE | re.MULTILINE | re.DOTALL) for pattern in patterns]
    
    def _initialize_true_vulnerability_patterns(self) -> List[re.Pattern]:
        """Patterns that indicate actual security vulnerabilities"""
        patterns = [
            # Critical vulnerabilities
            r"(?i)(?:exported\s+(?:activity|service|receiver|provider)).*?(?:without\s+permission|permission\s+null)",
            r"(?i)(?:sql\s+injection|code\s+injection|command\s+injection)",
            r"(?i)(?:path\s+traversal|directory\s+traversal)",
            r"(?i)(?:weak\s+(?:encryption|crypto)|insecure\s+(?:random|hash))",
            r"(?i)(?:hardcoded\s+(?:password|key|secret|credential))",
            
            # High severity issues
            r"(?i)(?:cleartext\s+(?:traffic|communication)).*?(?:enabled|allowed)",
            r"(?i)(?:certificate\s+pinning).*?(?:missing|disabled)",
            r"(?i)(?:webview).*?(?:javascript\s+enabled).*?(?:insecure|vulnerable)",
            r"(?i)(?:insecure\s+(?:deserialization|xml\s+parsing))",
            r"(?i)(?:privilege\s+escalation|unauthorized\s+access)",
            
            # Medium severity issues  
            r"(?i)(?:backup\s+enabled).*?(?:data\s+exposure|privacy\s+risk)",
            r"(?i)(?:debug\s+enabled|debugging\s+enabled).*?(?:production|release)",
            r"(?i)(?:sensitive\s+data).*?(?:logged|stored\s+insecurely)",
            r"(?i)(?:insecure\s+(?:storage|communication|configuration))",
            
            # Explicit failure indicators for security controls
            r"(?i)(?:security\s+(?:control|test)).*?(?:failed|failure)",
            r"(?i)(?:vulnerability).*?(?:detected|found|identified).*?(?:critical|high|medium)",
            r"(?i)(?:compliance).*?(?:failed|failure).*?(?:mstg|mastg|owasp)",
        ]
        return [re.compile(pattern, re.IGNORECASE | re.MULTILINE | re.DOTALL) for pattern in patterns]
    
    def filter_finding(self, finding: Dict[str, Any]) -> FilterDecision:
        """
        Apply comprehensive filtering to determine if finding is a real vulnerability.
        """
        # Extract all text content from the finding
        content = self._extract_finding_content(finding)
        title = finding.get("title", "").lower()
        status = finding.get("status", "").upper()
        
        # Initialize decision tracking
        reasoning = []
        evidence = []
        false_positive_indicators = []
        confidence = 0.0
        
        # 1. Check for explicit success indicators (highest priority)
        if self._matches_success_patterns(content):
            reasoning.append("Content explicitly indicates successful security check")
            evidence.extend(self._extract_success_evidence(content))
            return FilterDecision(
                result=FilterResult.SUCCESS_INDICATOR,
                confidence=0.95,
                reasoning=reasoning,
                original_severity=finding.get("severity", "UNKNOWN"),
                suggested_severity="INFO",
                evidence=evidence,
                false_positive_indicators=["explicit_success_indicator"]
            )
        
        # 2. Check for analysis reports/summaries
        if self._matches_analysis_report_patterns(content) or self._is_analysis_report(finding):
            reasoning.append("Content appears to be analysis report or summary")
            evidence.extend(self._extract_analysis_evidence(content))
            return FilterDecision(
                result=FilterResult.ANALYSIS_REPORT,
                confidence=0.90,
                reasoning=reasoning,
                original_severity=finding.get("severity", "UNKNOWN"),
                suggested_severity="INFO",
                evidence=evidence,
                false_positive_indicators=["analysis_report"]
            )
        
        # 3. Check for informational content
        if self._matches_informational_patterns(content):
            reasoning.append("Content is informational/recommendations, not active vulnerability")
            evidence.extend(self._extract_informational_evidence(content))
            return FilterDecision(
                result=FilterResult.INFORMATIONAL,
                confidence=0.85,
                reasoning=reasoning,
                original_severity=finding.get("severity", "UNKNOWN"),
                suggested_severity="INFO",
                evidence=evidence,
                false_positive_indicators=["informational_content"]
            )
        
        # 4. Check for false positive indicators
        false_positive_score, fp_indicators = self._calculate_false_positive_score(finding, content)
        false_positive_indicators.extend(fp_indicators)
        
        if false_positive_score > 0.7:
            reasoning.append(f"High false positive score: {false_positive_score:.2f}")
            return FilterDecision(
                result=FilterResult.FALSE_POSITIVE,
                confidence=false_positive_score,
                reasoning=reasoning,
                original_severity=finding.get("severity", "UNKNOWN"),
                suggested_severity="INFO",
                evidence=evidence,
                false_positive_indicators=false_positive_indicators
            )
        
        # 5. Check for true vulnerability patterns
        vulnerability_score, vuln_evidence = self._calculate_vulnerability_score(content)
        evidence.extend(vuln_evidence)
        
        if vulnerability_score > 0.6:
            reasoning.append(f"Content matches vulnerability patterns: {vulnerability_score:.2f}")
            confidence = vulnerability_score
            
            # Adjust confidence based on false positive indicators
            if false_positive_indicators:
                confidence = confidence * (1 - (false_positive_score * 0.5))
                reasoning.append(f"Confidence adjusted for false positive indicators: {confidence:.2f}")
            
            return FilterDecision(
                result=FilterResult.VULNERABILITY,
                confidence=confidence,
                reasoning=reasoning,
                original_severity=finding.get("severity", "UNKNOWN"),
                suggested_severity=self._determine_severity_from_score(vulnerability_score),
                evidence=evidence,
                false_positive_indicators=false_positive_indicators
            )
        
        # 6. Default: Likely false positive if no clear vulnerability indicators
        reasoning.append("No clear vulnerability indicators found - likely false positive")
        return FilterDecision(
            result=FilterResult.FALSE_POSITIVE,
            confidence=0.80,
            reasoning=reasoning,
            original_severity=finding.get("severity", "UNKNOWN"),
            suggested_severity="INFO",
            evidence=evidence,
            false_positive_indicators=["no_vulnerability_indicators"]
        )
    
    def _extract_finding_content(self, finding: Dict[str, Any]) -> str:
        """Extract all text content from finding for analysis"""
        content_parts = []
        
        for field in ["title", "description", "content", "result"]:
            if field in finding and finding[field]:
                content_parts.append(str(finding[field]))
        
        return " ".join(content_parts).lower()
    
    def _matches_success_patterns(self, content: str) -> bool:
        """Check if content matches success indicator patterns"""
        return any(pattern.search(content) for pattern in self.success_patterns)
    
    def _matches_analysis_report_patterns(self, content: str) -> bool:
        """Check if content matches analysis report patterns"""
        return any(pattern.search(content) for pattern in self.analysis_report_patterns)
    
    def _matches_informational_patterns(self, content: str) -> bool:
        """Check if content matches informational patterns"""
        return any(pattern.search(content) for pattern in self.informational_patterns)
    
    def _is_analysis_report(self, finding: Dict[str, Any]) -> bool:
        """Check if finding is an analysis report based on structure"""
        title = finding.get("title", "").lower()
        
        # Common analysis report titles
        report_indicators = [
            "analysis", "report", "summary", "execution", "performance",
            "compliance", "professional", "testing", "discovery"
        ]
        
        return any(indicator in title for indicator in report_indicators)
    
    def _calculate_false_positive_score(self, finding: Dict[str, Any], content: str) -> Tuple[float, List[str]]:
        """Calculate false positive likelihood score"""
        score = 0.0
        indicators = []
        
        # Status-based indicators
        status = finding.get("status", "").upper()
        if status in ["PASS", "PASSED", "SUCCESS", "OK"]:
            score += 0.4
            indicators.append("status_pass")
        
        # Pattern-based indicators
        for pattern in self.false_positive_patterns:
            if pattern.search(content):
                score += 0.3
                indicators.append("false_positive_pattern")
        
        # Zero findings indicators
        if re.search(r"(?:0|none|null)\s+(?:vulnerabilities|findings|issues)", content):
            score += 0.5
            indicators.append("zero_findings")
        
        # Success language
        success_terms = ["successful", "complete", "passed", "ok", "excellent", "100%"]
        success_count = sum(1 for term in success_terms if term in content)
        if success_count >= 2:
            score += 0.3
            indicators.append("success_language")
        
        return min(score, 1.0), indicators
    
    def _calculate_vulnerability_score(self, content: str) -> Tuple[float, List[str]]:
        """Calculate actual vulnerability likelihood score"""
        score = 0.0
        evidence = []
        
        # Check against true vulnerability patterns
        for pattern in self.true_vulnerability_patterns:
            matches = pattern.findall(content)
            if matches:
                score += 0.4
                evidence.extend(matches[:3])  # Limit evidence
        
        # Look for explicit vulnerability language
        vuln_terms = ["vulnerability", "vulnerable", "insecure", "weak", "exposed", "leaked"]
        vuln_count = sum(1 for term in vuln_terms if term in content)
        if vuln_count >= 2:
            score += 0.3
            evidence.append(f"vulnerability_language_count_{vuln_count}")
        
        # Security failure indicators
        failure_terms = ["failed", "failure", "missing", "disabled", "without"]
        security_terms = ["security", "protection", "encryption", "authentication"]
        
        combined_security_failures = 0
        for failure in failure_terms:
            for security in security_terms:
                if f"{failure}.*{security}" in content or f"{security}.*{failure}" in content:
                    combined_security_failures += 1
        
        if combined_security_failures >= 1:
            score += 0.4
            evidence.append(f"security_failure_combinations_{combined_security_failures}")
        
        return min(score, 1.0), evidence
    
    def _determine_severity_from_score(self, score: float) -> str:
        """Determine severity based on vulnerability score"""
        if score >= 0.9:
            return "HIGH"
        elif score >= 0.7:
            return "MEDIUM"
        elif score >= 0.5:
            return "LOW"
        else:
            return "INFO"
    
    def _extract_success_evidence(self, content: str) -> List[str]:
        """Extract evidence of successful security checks"""
        evidence = []
        
        success_extracts = [
            r"no\s+vulnerabilities?\s+(?:found|detected|identified)",
            r"(?:all\s+)?tests?\s+(?:passed|successful)",
            r"status\s*:\s*(?:pass|success)",
            r"100%\s+(?:success|efficiency)"
        ]
        
        for pattern in success_extracts:
            matches = re.findall(pattern, content, re.IGNORECASE)
            evidence.extend(matches[:2])
        
        return evidence
    
    def _extract_analysis_evidence(self, content: str) -> List[str]:
        """Extract evidence of analysis reports"""
        evidence = []
        
        analysis_extracts = [
            r"(?:analysis|report|summary)\s+(?:complete|generated)",
            r"(?:executive|technical|compliance)\s+(?:report|summary)",
            r"(?:total\s+(?:plugins|tests)|successfully\s+executed)"
        ]
        
        for pattern in analysis_extracts:
            matches = re.findall(pattern, content, re.IGNORECASE)
            evidence.extend(matches[:2])
        
        return evidence
    
    def _extract_informational_evidence(self, content: str) -> List[str]:
        """Extract evidence of informational content"""
        evidence = []
        
        info_extracts = [
            r"(?:security\s+)?recommendations?:",
            r"consider\s+(?:disabling|implementing|using)",
            r"(?:android\s+keystore|certificate\s+pinning)"
        ]
        
        for pattern in info_extracts:
            matches = re.findall(pattern, content, re.IGNORECASE)
            evidence.extend(matches[:2])
        
        return evidence
    
    def filter_findings_batch(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Apply filtering to a batch of findings and return categorized results.
        """
        results = {
            "vulnerabilities": [],
            "informational": [],
            "false_positives": [],
            "analysis_reports": [],
            "success_indicators": [],
            "filter_summary": defaultdict(int)
        }
        
        for finding in findings:
            decision = self.filter_finding(finding)
            
            # Update statistics
            results["filter_summary"][decision.result.value] += 1
            
            # Add enhanced metadata to finding
            enhanced_finding = finding.copy()
            enhanced_finding.update({
                "filter_decision": decision.result.value,
                "filter_confidence": decision.confidence,
                "filter_reasoning": decision.reasoning,
                "suggested_severity": decision.suggested_severity,
                "false_positive_indicators": decision.false_positive_indicators,
                "filter_evidence": decision.evidence
            })
            
            # Categorize based on filter result
            if decision.result == FilterResult.VULNERABILITY:
                results["vulnerabilities"].append(enhanced_finding)
            elif decision.result == FilterResult.INFORMATIONAL:
                results["informational"].append(enhanced_finding)
            elif decision.result == FilterResult.FALSE_POSITIVE:
                results["false_positives"].append(enhanced_finding)
            elif decision.result == FilterResult.ANALYSIS_REPORT:
                results["analysis_reports"].append(enhanced_finding)
            elif decision.result == FilterResult.SUCCESS_INDICATOR:
                results["success_indicators"].append(enhanced_finding)
        
        # Add comprehensive summary
        total_findings = len(findings)
        actual_vulns = len(results["vulnerabilities"])
        false_positives = len(results["false_positives"])
        
        results["accuracy_metrics"] = {
            "total_findings": total_findings,
            "actual_vulnerabilities": actual_vulns,
            "false_positives_removed": false_positives,
            "accuracy_improvement": f"{(false_positives/total_findings)*100:.1f}%" if total_findings > 0 else "N/A",
            "final_vulnerability_count": actual_vulns
        }
        
        return results
    
    def get_filter_statistics(self) -> Dict[str, Any]:
        """Get comprehensive filtering statistics"""
        return dict(self.filter_stats) 