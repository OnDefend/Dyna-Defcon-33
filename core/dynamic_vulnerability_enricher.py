#!/usr/bin/env python3
"""
Dynamic Vulnerability Enricher
=============================

Enriches dynamic vulnerabilities with MITRE ATT&CK mappings, threat intelligence,
and enhanced metadata following the same patterns as static analysis.
"""

import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

from core.shared_data_structures.base_vulnerability import BaseVulnerability


@dataclass
class MitreMapping:
    """MITRE ATT&CK technique mapping."""
    technique_id: str
    technique_name: str
    tactic: str
    description: str
    confidence: float = 0.8


@dataclass
class ThreatIntelligence:
    """Threat intelligence data for a vulnerability."""
    risk_assessment: str = "UNKNOWN"
    correlation_confidence: float = 0.0
    known_exploits: List[str] = field(default_factory=list)
    threat_actors: List[str] = field(default_factory=list)
    mitre_mappings: List[MitreMapping] = field(default_factory=list)
    exploit_availability: str = "UNKNOWN"
    attack_complexity: str = "UNKNOWN"


class DynamicVulnerabilityEnricher:
    """Enriches dynamic vulnerabilities with comprehensive metadata."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # MITRE ATT&CK mappings for mobile vulnerabilities
        self.mitre_mappings = {
            'CWE-89': [  # SQL Injection
                MitreMapping(
                    technique_id="T1190",
                    technique_name="Exploit Public-Facing Application",
                    tactic="Initial Access",
                    description="SQL injection can be used to gain initial access to systems"
                )
            ],
            'CWE-79': [  # XSS
                MitreMapping(
                    technique_id="T1059",
                    technique_name="Command and Scripting Interpreter",
                    tactic="Execution", 
                    description="XSS can execute malicious scripts in WebView contexts"
                )
            ],
            'CWE-200': [  # Information Disclosure
                MitreMapping(
                    technique_id="T1005",
                    technique_name="Data from Local System",
                    tactic="Collection",
                    description="Insecure storage allows unauthorized data collection"
                )
            ],
            'CWE-327': [  # Weak Cryptography
                MitreMapping(
                    technique_id="T1040",
                    technique_name="Network Sniffing",
                    tactic="Credential Access",
                    description="Weak crypto enables credential interception"
                )
            ],
            'CWE-798': [  # Hardcoded Credentials
                MitreMapping(
                    technique_id="T1078",
                    technique_name="Valid Accounts",
                    tactic="Defense Evasion",
                    description="Hardcoded credentials provide persistent access"
                )
            ],
            'CWE-532': [  # Information Exposure Through Log Files
                MitreMapping(
                    technique_id="T1005",
                    technique_name="Data from Local System",
                    tactic="Collection",
                    description="Log exposure enables sensitive data collection"
                )
            ],
            'CWE-489': [  # Debuggable Application
                MitreMapping(
                    technique_id="T1553.006",
                    technique_name="Code Signing Policy Modification",
                    tactic="Defense Evasion",
                    description="Debug mode bypasses code signing protections"
                )
            ],
            'CWE-693': [  # Protection Mechanism Failure
                MitreMapping(
                    technique_id="T1553",
                    technique_name="Subvert Trust Controls", 
                    tactic="Defense Evasion",
                    description="Failed protections enable trust control subversion"
                )
            ],
            'CWE-319': [  # Cleartext Transmission
                MitreMapping(
                    technique_id="T1040",
                    technique_name="Network Sniffing",
                    tactic="Credential Access",
                    description="Cleartext transmission enables credential interception"
                )
            ],
            'CWE-295': [  # Certificate Validation Issues
                MitreMapping(
                    technique_id="T1557",
                    technique_name="Adversary-in-the-Middle",
                    tactic="Credential Access", 
                    description="Invalid certificate validation enables MITM attacks"
                )
            ]
        }
        
        # Threat intelligence rules
        self.threat_intelligence_rules = {
            'sql_injection': {
                'risk_assessment': 'HIGH',
                'known_exploits': ['SQLMap', 'SQL injection frameworks'],
                'threat_actors': ['Script kiddies', 'APT groups'],
                'exploit_availability': 'PUBLIC',
                'attack_complexity': 'LOW'
            },
            'xss': {
                'risk_assessment': 'MEDIUM',
                'known_exploits': ['XSS payloads', 'Browser exploitation'],
                'threat_actors': ['Web attackers', 'Malicious actors'],
                'exploit_availability': 'PUBLIC', 
                'attack_complexity': 'LOW'
            },
            'insecure_storage': {
                'risk_assessment': 'HIGH',
                'known_exploits': ['File system access', 'Root exploits'],
                'threat_actors': ['Malware', 'Local attackers'],
                'exploit_availability': 'HIGH',
                'attack_complexity': 'LOW'
            },
            'weak_crypto': {
                'risk_assessment': 'MEDIUM',
                'known_exploits': ['Crypto attacks', 'Hash collision'],
                'threat_actors': ['Nation-state actors', 'Advanced attackers'],
                'exploit_availability': 'MODERATE',
                'attack_complexity': 'MEDIUM'
            },
            'hardcoded_secret': {
                'risk_assessment': 'CRITICAL',
                'known_exploits': ['Source code analysis', 'Reverse engineering'],
                'threat_actors': ['All threat types'],
                'exploit_availability': 'HIGH',
                'attack_complexity': 'LOW'
            },
            'exported_component': {
                'risk_assessment': 'MEDIUM',
                'known_exploits': ['Intent fuzzing', 'Component hijacking'],
                'threat_actors': ['Malicious apps', 'Local attackers'],
                'exploit_availability': 'MODERATE',
                'attack_complexity': 'MEDIUM'
            },
            'debuggable': {
                'risk_assessment': 'HIGH',
                'known_exploits': ['Debug access', 'Runtime manipulation'],
                'threat_actors': ['Reverse engineers', 'Malware'],
                'exploit_availability': 'HIGH',
                'attack_complexity': 'LOW'
            }
        }
    
    def enrich_vulnerabilities(self, vulnerabilities: List[BaseVulnerability]) -> List[BaseVulnerability]:
        """Enrich vulnerabilities with MITRE, threat intelligence, and enhanced metadata."""
        
        enriched_vulnerabilities = []
        
        for vuln in vulnerabilities:
            try:
                enriched_vuln = self._enrich_single_vulnerability(vuln)
                enriched_vulnerabilities.append(enriched_vuln)
            except Exception as e:
                self.logger.error(f"Failed to enrich vulnerability {vuln.vulnerability_id}: {e}")
                # Add original vulnerability if enrichment fails
                enriched_vulnerabilities.append(vuln)
        
        self.logger.info(f"Enriched {len(enriched_vulnerabilities)} dynamic vulnerabilities")
        return enriched_vulnerabilities
    
    def _enrich_single_vulnerability(self, vuln: BaseVulnerability) -> BaseVulnerability:
        """Enrich a single vulnerability with comprehensive metadata."""
        
        # Create a copy to avoid modifying the original
        enriched_vuln = BaseVulnerability(
            vulnerability_id=vuln.vulnerability_id,
            title=vuln.title,
            description=vuln.description,
            severity=vuln.severity,
            vulnerability_type=vuln.vulnerability_type,
            confidence=vuln.confidence,
            cwe_id=vuln.cwe_id,
            plugin_name=vuln.plugin_name,
            recommendations=vuln.recommendations.copy()
        )
        
        # Copy context and metadata
        enriched_vuln.context = vuln.context
        enriched_vuln.metadata = vuln.metadata.copy()
        
        # Add MITRE ATT&CK mappings
        mitre_mappings = self._get_mitre_mappings_for_cwe(vuln.cwe_id)
        if mitre_mappings:
            enriched_vuln.metadata['mitre_attack'] = [
                {
                    'technique_id': mapping.technique_id,
                    'technique_name': mapping.technique_name,
                    'tactic': mapping.tactic,
                    'description': mapping.description,
                    'confidence': mapping.confidence
                }
                for mapping in mitre_mappings
            ]
        
        # Add threat intelligence
        threat_intel = self._get_threat_intelligence(vuln)
        if threat_intel:
            enriched_vuln.metadata['threat_intelligence'] = {
                'risk_assessment': threat_intel.risk_assessment,
                'correlation_confidence': threat_intel.correlation_confidence,
                'known_exploits': threat_intel.known_exploits,
                'threat_actors': threat_intel.threat_actors,
                'exploit_availability': threat_intel.exploit_availability,
                'attack_complexity': threat_intel.attack_complexity
            }
        
        # Enhance recommendations with MITRE-based guidance
        enhanced_recommendations = self._generate_mitre_based_recommendations(vuln, mitre_mappings)
        if enhanced_recommendations:
            existing_recs = list(enriched_vuln.recommendations)
            existing_recs.extend(enhanced_recommendations)
            enriched_vuln.recommendations = existing_recs
        
        # Add dynamic-specific metadata
        enriched_vuln.metadata['dynamic_analysis'] = {
            'detection_confidence': self._calculate_dynamic_confidence(vuln),
            'runtime_verified': True,
            'analysis_timestamp': vuln.metadata.get('analysis_timestamp', 'unknown'),
            'plugin_execution_context': vuln.plugin_name
        }
        
        return enriched_vuln
    
    def _get_mitre_mappings_for_cwe(self, cwe_id: str) -> List[MitreMapping]:
        """Get MITRE ATT&CK mappings for a CWE ID."""
        return self.mitre_mappings.get(cwe_id, [])
    
    def _get_threat_intelligence(self, vuln: BaseVulnerability) -> Optional[ThreatIntelligence]:
        """Get threat intelligence for a vulnerability."""
        
        # Determine vulnerability category for threat intel lookup
        vuln_category = self._categorize_vulnerability(vuln)
        
        threat_rule = self.threat_intelligence_rules.get(vuln_category)
        if not threat_rule:
            return None
        
        # Calculate correlation confidence based on detection quality
        correlation_confidence = self._calculate_correlation_confidence(vuln)
        
        # Get MITRE mappings for this vulnerability
        mitre_mappings = self._get_mitre_mappings_for_cwe(vuln.cwe_id)
        
        return ThreatIntelligence(
            risk_assessment=threat_rule['risk_assessment'],
            correlation_confidence=correlation_confidence,
            known_exploits=threat_rule['known_exploits'],
            threat_actors=threat_rule['threat_actors'],
            mitre_mappings=mitre_mappings,
            exploit_availability=threat_rule['exploit_availability'],
            attack_complexity=threat_rule['attack_complexity']
        )
    
    def _categorize_vulnerability(self, vuln: BaseVulnerability) -> str:
        """Categorize vulnerability for threat intelligence lookup."""
        
        title_lower = vuln.title.lower()
        plugin_lower = vuln.plugin_name.lower() if vuln.plugin_name else ""
        
        category_keywords = {
            'sql_injection': ['sql', 'injection', 'database'],
            'xss': ['xss', 'cross-site', 'script'],
            'insecure_storage': ['storage', 'data', 'file', 'database', 'shared'],
            'weak_crypto': ['crypto', 'hash', 'cipher', 'encryption'],
            'hardcoded_secret': ['secret', 'password', 'key', 'token', 'credential'],
            'exported_component': ['exported', 'component', 'activity', 'service'],
            'debuggable': ['debug', 'debuggable']
        }
        
        for category, keywords in category_keywords.items():
            if any(keyword in title_lower or keyword in plugin_lower for keyword in keywords):
                return category
        
        return 'generic'  # Default category
    
    def _calculate_correlation_confidence(self, vuln: BaseVulnerability) -> float:
        """Calculate threat intelligence correlation confidence."""
        
        confidence = 0.5  # Base confidence
        
        # Increase confidence for specific CWE IDs
        if vuln.cwe_id and vuln.cwe_id != 'CWE-693':
            confidence += 0.2
        
        # Increase confidence for high-quality evidence
        evidence_quality = vuln.metadata.get('evidence_quality', 'unknown')
        if evidence_quality in ['runtime_detected', 'complete']:
            confidence += 0.15
        
        # Increase confidence based on vulnerability confidence
        if vuln.confidence > 0.8:
            confidence += 0.1
        
        # Increase confidence for known vulnerability types
        if vuln.cwe_id in self.mitre_mappings:
            confidence += 0.15
        
        return min(0.95, confidence)
    
    def _calculate_dynamic_confidence(self, vuln: BaseVulnerability) -> float:
        """Calculate dynamic-specific confidence score."""
        
        base_confidence = vuln.confidence
        
        # Dynamic analysis provides runtime verification
        runtime_bonus = 0.1
        
        # Bonus for specific detection methods
        detection_method = vuln.metadata.get('detection_method', 'unknown')
        if detection_method == 'dynamic_analysis':
            runtime_bonus += 0.05
        
        # Bonus for plugin-specific detection
        if vuln.plugin_name:
            runtime_bonus += 0.05
        
        return min(0.95, base_confidence + runtime_bonus)
    
    def _generate_mitre_based_recommendations(
        self, 
        vuln: BaseVulnerability, 
        mitre_mappings: List[MitreMapping]
    ) -> List[str]:
        """Generate recommendations based on MITRE ATT&CK mappings."""
        
        recommendations = []
        
        for mapping in mitre_mappings:
            tactic_recommendations = {
                'Initial Access': [
                    "Implement input validation and sanitization",
                    "Deploy application firewalls",
                    "Regular security testing and code review"
                ],
                'Execution': [
                    "Implement Content Security Policy (CSP)",
                    "Use secure WebView configurations", 
                    "Validate all user inputs"
                ],
                'Collection': [
                    "Encrypt sensitive data at rest",
                    "Implement proper access controls",
                    "Minimize data exposure and logging"
                ],
                'Credential Access': [
                    "Use strong encryption for data transmission",
                    "Implement certificate pinning",
                    "Avoid storing credentials in logs"
                ],
                'Defense Evasion': [
                    "Remove debug capabilities in production builds",
                    "Implement proper code signing",
                    "Use runtime application self-protection (RASP)"
                ]
            }
            
            tactic_recs = tactic_recommendations.get(mapping.tactic, [])
            for rec in tactic_recs[:2]:  # Limit to 2 recommendations per tactic
                if rec not in recommendations and rec not in vuln.recommendations:
                    recommendations.append(rec)
        
        return recommendations