#!/usr/bin/env python3
"""
Cryptographic Exploitation Coordinator
Advanced cryptographic attack vector analysis and testing
"""

import logging
import hashlib
import asyncio
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import re
import base64

class CryptoAttackType(Enum):
    """Types of cryptographic attacks"""
    WEAK_ENCRYPTION = "weak_encryption"
    KEY_MANAGEMENT = "key_management"
    HASH_COLLISION = "hash_collision"
    RANDOM_NUMBER_GENERATION = "random_number_generation"
    CERTIFICATE_VALIDATION = "certificate_validation"
    PROTOCOL_DOWNGRADE = "protocol_downgrade"
    SIDE_CHANNEL = "side_channel"
    QUANTUM_RESISTANCE = "quantum_resistance"

class CryptoSeverity(Enum):
    """Severity levels for cryptographic attacks"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class CryptographicAttackVector:
    """Represents a cryptographic attack vector"""
    vector_id: str
    attack_type: CryptoAttackType
    severity: CryptoSeverity
    technique: str
    target_algorithm: str
    description: str
    exploit_payload: str
    mitigation: str
    evidence: Dict[str, Any]

@dataclass
class CryptoAnalysisResult:
    """Results of cryptographic attack analysis"""
    analysis_id: str
    attack_vectors_found: List[CryptographicAttackVector]
    crypto_vulnerabilities: List[Dict[str, Any]]
    weak_implementations: List[str]
    security_recommendations: List[str]
    crypto_risk_score: float

class CryptographicExploitationCoordinator:
    """Coordinates cryptographic attack vector analysis"""
    
    def __init__(self, logger_name: str = __name__):
        self.logger = logging.getLogger(logger_name)
        
        # Cryptographic attack techniques and payloads
        self.crypto_attack_techniques = {
            'weak_ciphers': [
                'DES encryption with 56-bit key',  # Deprecated encryption
                'RC4 stream cipher exploitation',  # Biased keystream
                '3DES with meet-in-the-middle attack',  # Triple DES weakness
                'AES with ECB mode pattern analysis',  # Electronic codebook mode
                'RSA with PKCS#1 v1.5 padding oracle',  # Padding oracle attack
                'MD5 hash collision generation',  # Collision-prone hash
                'SHA-1 chosen-prefix collision',  # SHA-1 weakness
                'Blowfish weak key detection',  # Algorithm weakness
                'IDEA key schedule attack',  # International Data Encryption
                'Camellia reduced round attack',  # Block cipher analysis
                'ChaCha20 nonce reuse attack',  # Stream cipher nonce issue
                'Salsa20 differential cryptanalysis'  # Stream cipher attack
            ],
            'key_management_flaws': [
                'Hardcoded encryption keys in APK',  # Static key storage
                'Weak key derivation function (PBKDF2 < 10000)',  # Insufficient iterations
                'RSA private key without proper protection',  # Unprotected private key
                'Symmetric key transmitted in plaintext',  # Insecure key exchange
                'Key reuse across multiple sessions',  # Key management issue
                'Insufficient key entropy generation',  # Weak randomness
                'Public key without certificate validation',  # PKI bypass
                'Master key derived from user password',  # Weak key derivation
                'Encryption key stored in SharedPreferences',  # Insecure storage
                'Key material in application logs',  # Information leakage
                'Biometric key without secure enclave',  # Hardware security bypass
                'Keystore bypass using reflection'  # Android keystore exploitation
            ],
            'hash_vulnerabilities': [
                'MD5 rainbow table attack vector',  # Pre-computed hash attack
                'SHA-1 collision attack implementation',  # Collision vulnerability
                'Custom hash function with known weakness',  # Proprietary weakness
                'Hash length extension attack (SHA-256)',  # Length extension
                'HMAC key recovery through timing attack',  # Side-channel timing
                'bcrypt cost factor below 12',  # Insufficient work factor
                'scrypt parameter insufficiency',  # Memory-hard function weakness
                'Argon2 parameter misconfiguration',  # Modern hash function issue
                'PBKDF2 salt reuse vulnerability',  # Salt management issue
                'Hash function downgrade attack',  # Algorithm negotiation
                'Merkle-DamgÃ¥rd construction weakness',  # Construction vulnerability
                'BLAKE2 parameter manipulation'  # BLAKE2 algorithm issue
            ],
            'random_number_attacks': [
                'Predictable PRNG seed exploitation',  # Pseudo-random weakness
                'Java SecureRandom state prediction',  # Platform-specific issue
                'Linear congruential generator attack',  # Basic PRNG weakness
                'Mersenne Twister state recovery',  # MT19937 exploitation
                'Android /dev/urandom depletion',  # Entropy source attack
                'Timestamp-based seed prediction',  # Weak seed source
                'DUAL_EC_DRBG backdoor exploitation',  # NSA backdoor
                'ChaCha20 RNG state correlation',  # Stream cipher RNG
                'Fortuna pool manipulation',  # Entropy pool attack
                'Yarrow RNG bias exploitation',  # Yarrow algorithm weakness
                'Intel RDRAND instruction bypass',  # Hardware RNG issue
                'ECDSA nonce reuse key recovery'  # Elliptic curve signature issue
            ],
            'certificate_attacks': [
                'X.509 certificate chain validation bypass',  # PKI bypass
                'Self-signed certificate acceptance',  # Trust validation issue
                'Certificate pinning bypass techniques',  # Pinning circumvention
                'Weak signature algorithm (SHA-1)',  # Deprecated signature
                'Certificate transparency log evasion',  # CT bypass
                'Extended validation certificate spoofing',  # EV cert attack
                'Certificate authority compromise simulation',  # CA attack
                'OCSP stapling bypass attack',  # Revocation bypass
                'Certificate name constraint bypass',  # Name constraint issue
                'Key usage extension violation',  # Certificate misuse
                'Certificate validity period manipulation',  # Time-based attack
                'Cross-certificate attack vector'  # Cross-certification issue
            ],
            'protocol_attacks': [
                'TLS protocol downgrade to SSL 3.0',  # Version downgrade
                'TLS cipher suite downgrade attack',  # Cipher negotiation
                'BEAST CBC attack on TLS 1.0',  # Block cipher attack
                'CRIME TLS compression attack',  # Compression vulnerability
                'BREACH HTTP compression attack',  # HTTP-level compression
                'POODLE SSL 3.0 padding oracle',  # Padding oracle
                'Heartbleed OpenSSL memory disclosure',  # Implementation bug
                'FREAK export cipher downgrade',  # Export-grade cipher
                'Logjam DHE parameter attack',  # Diffie-Hellman weakness
                'DROWN SSLv2 cross-protocol attack',  # Cross-protocol
                'ROBOT RSA PKCS#1 attack',  # RSA padding attack
                'Raccoon DH timing attack'  # Diffie-Hellman timing
            ],
            'side_channel_attacks': [
                'AES T-table cache timing attack',  # Cache-based timing
                'RSA CRT fault injection attack',  # Chinese remainder theorem
                'ECC scalar multiplication timing',  # Elliptic curve timing
                'Power analysis on AES operations',  # Power consumption
                'Electromagnetic emanation analysis',  # EM side-channel
                'Acoustic cryptanalysis attack',  # Sound-based attack
                'Memory access pattern analysis',  # Memory side-channel
                'Branch prediction attack vector',  # CPU prediction
                'Instruction cache side-channel',  # CPU cache attack
                'TLB miss timing analysis',  # Translation lookaside buffer
                'Spectre variant cryptographic leak',  # Speculative execution
                'Meltdown memory disclosure'  # Memory protection bypass
            ],
            'quantum_readiness': [
                'RSA-2048 quantum vulnerability assessment',  # Quantum threat
                'ECDSA P-256 Shor algorithm susceptibility',  # Elliptic curve quantum
                'Discrete log quantum attack vector',  # DLP quantum vulnerability
                'Grover algorithm symmetric key reduction',  # Symmetric key quantum
                'Post-quantum migration assessment',  # PQC readiness
                'Lattice-based cryptography evaluation',  # PQC alternative
                'Hash-based signature analysis',  # Quantum-resistant signature
                'Code-based cryptography assessment',  # PQC code-based
                'Multivariate cryptography evaluation',  # PQC multivariate
                'Isogeny-based cryptography analysis'  # PQC isogeny-based
            ]
        }
        
        # Cryptographic vulnerability patterns
        self.crypto_patterns = {
            'weak_algorithms': [
                r'DES\.getInstance|TripleDES',
                r'RC4|ARC4|ARCFOUR',
                r'MD5\.getInstance|MessageDigest\.getInstance\("MD5"\)',
                r'SHA1\.getInstance|MessageDigest\.getInstance\("SHA-1"\)',
                r'ECB.*mode|AES/ECB',
                r'PKCS1Padding',
                r'NoPadding.*AES'
            ],
            'hardcoded_secrets': [
                r'private.*key.*=.*"[A-Za-z0-9+/=]{20,}"',
                r'api.*key.*=.*"[A-Za-z0-9]{16,}"',
                r'secret.*=.*"[A-Za-z0-9]{12,}"',
                r'password.*=.*"[^"]{8,}"',
                r'keystore.*password.*=',
                r'javax\.crypto\.spec\.SecretKeySpec.*"[^"]+".getBytes'
            ],
            'insecure_random': [
                r'Math\.random\(\)',
                r'Random\(\)\.next',
                r'System\.currentTimeMillis\(\).*seed',
                r'new.*Random\(.*System\.currentTimeMillis',
                r'SecureRandom.*setSeed\(',
                r'Random.*setSeed\('
            ]
        }
        
        # Security assessments
        self.security_assessments = [
            'Encryption algorithm strength analysis',
            'Key management security evaluation',
            'Random number generation quality',
            'Certificate validation implementation',
            'Cryptographic protocol security',
            'Side-channel resistance assessment',
            'Quantum readiness evaluation',
            'Implementation vulnerability scan'
        ]
    
    async def analyze_cryptographic_attack_surface(self, app_context: Dict[str, Any]) -> CryptoAnalysisResult:
        """Analyze application's cryptographic attack surface"""
        analysis_id = hashlib.md5(f"crypto_analysis_{app_context.get('package_name', 'unknown')}".encode()).hexdigest()[:12]
        
        # Generate attack vectors for each category
        attack_vectors = []
        
        for category, techniques in self.crypto_attack_techniques.items():
            category_vectors = await self._generate_crypto_attack_vectors(category, techniques)
            attack_vectors.extend(category_vectors)
        
        # Analyze cryptographic vulnerabilities
        vulnerabilities = await self._analyze_crypto_vulnerabilities(app_context)
        
        # Identify weak implementations
        weak_implementations = self._identify_weak_implementations(app_context)
        
        # Generate security recommendations
        recommendations = self._generate_crypto_recommendations(attack_vectors, vulnerabilities)
        
        # Calculate cryptographic risk score
        risk_score = self._calculate_crypto_risk_score(attack_vectors, vulnerabilities)
        
        return CryptoAnalysisResult(
            analysis_id=analysis_id,
            attack_vectors_found=attack_vectors,
            crypto_vulnerabilities=vulnerabilities,
            weak_implementations=weak_implementations,
            security_recommendations=recommendations,
            crypto_risk_score=risk_score
        )
    
    async def _generate_crypto_attack_vectors(self, category: str, techniques: List[str]) -> List[CryptographicAttackVector]:
        """Generate cryptographic attack vectors for a category"""
        vectors = []
        
        for i, technique in enumerate(techniques):
            vector_id = hashlib.md5(f"{category}_{i}_{technique}".encode()).hexdigest()[:12]
            
            # Determine attack type and severity
            attack_type = self._map_category_to_crypto_attack_type(category)
            severity = self._assess_crypto_severity(technique, category)
            
            # Extract target algorithm
            target_algorithm = self._extract_target_algorithm(technique)
            
            # Generate exploit payload
            exploit_payload = self._generate_exploit_payload(technique, category)
            
            # Generate description and mitigation
            description = f"Cryptographic attack: {technique}"
            mitigation = self._generate_crypto_mitigation(category, technique)
            
            vector = CryptographicAttackVector(
                vector_id=vector_id,
                attack_type=attack_type,
                severity=severity,
                technique=technique,
                target_algorithm=target_algorithm,
                description=description,
                exploit_payload=exploit_payload,
                mitigation=mitigation,
                evidence={
                    'category': category,
                    'attack_complexity': self._assess_attack_complexity(technique),
                    'exploitability': self._assess_crypto_exploitability(technique),
                    'impact_level': self._assess_crypto_impact(technique),
                    'quantum_threat': self._assess_quantum_threat(technique)
                }
            )
            
            vectors.append(vector)
        
        return vectors
    
    def _map_category_to_crypto_attack_type(self, category: str) -> CryptoAttackType:
        """Map category to cryptographic attack type"""
        mapping = {
            'weak_ciphers': CryptoAttackType.WEAK_ENCRYPTION,
            'key_management_flaws': CryptoAttackType.KEY_MANAGEMENT,
            'hash_vulnerabilities': CryptoAttackType.HASH_COLLISION,
            'random_number_attacks': CryptoAttackType.RANDOM_NUMBER_GENERATION,
            'certificate_attacks': CryptoAttackType.CERTIFICATE_VALIDATION,
            'protocol_attacks': CryptoAttackType.PROTOCOL_DOWNGRADE,
            'side_channel_attacks': CryptoAttackType.SIDE_CHANNEL,
            'quantum_readiness': CryptoAttackType.QUANTUM_RESISTANCE
        }
        return mapping.get(category, CryptoAttackType.WEAK_ENCRYPTION)
    
    def _assess_crypto_severity(self, technique: str, category: str) -> CryptoSeverity:
        """Assess severity of cryptographic attack technique"""
        critical_indicators = ['DES', 'MD5', 'hardcoded', 'plaintext', 'heartbleed']
        high_indicators = ['SHA-1', 'RC4', 'collision', 'oracle', 'timing']
        medium_indicators = ['weak', 'insufficient', 'deprecated']
        
        technique_lower = technique.lower()
        
        if any(indicator in technique_lower for indicator in critical_indicators):
            return CryptoSeverity.CRITICAL
        elif any(indicator in technique_lower for indicator in high_indicators):
            return CryptoSeverity.HIGH
        elif any(indicator in technique_lower for indicator in medium_indicators):
            return CryptoSeverity.MEDIUM
        else:
            return CryptoSeverity.LOW
    
    def _extract_target_algorithm(self, technique: str) -> str:
        """Extract target algorithm from technique"""
        algorithms = ['AES', 'DES', 'RSA', 'ECC', 'SHA-1', 'SHA-256', 'MD5', 'HMAC', 
                     'PBKDF2', 'bcrypt', 'scrypt', 'ChaCha20', 'TLS', 'SSL']
        
        technique_upper = technique.upper()
        for algorithm in algorithms:
            if algorithm in technique_upper:
                return algorithm
        
        return 'Unknown'
    
    def _generate_exploit_payload(self, technique: str, category: str) -> str:
        """Generate exploit payload for the technique"""
        if 'DES' in technique:
            return 'DES_KEY_BRUTE_FORCE_PAYLOAD'
        elif 'MD5' in technique:
            return 'MD5_COLLISION_PAYLOAD'
        elif 'hardcoded' in technique.lower():
            return 'STATIC_KEY_EXTRACTION_PAYLOAD'
        elif 'timing' in technique.lower():
            return 'TIMING_ANALYSIS_PAYLOAD'
        elif 'oracle' in technique.lower():
            return 'PADDING_ORACLE_PAYLOAD'
        else:
            return f'{category.upper()}_EXPLOIT_PAYLOAD'
    
    def _assess_attack_complexity(self, technique: str) -> str:
        """Assess complexity of cryptographic attack"""
        low_complexity = ['hardcoded', 'plaintext', 'md5', 'des']
        high_complexity = ['side.channel', 'quantum', 'fault injection', 'timing']
        
        technique_lower = technique.lower()
        
        if any(indicator in technique_lower for indicator in low_complexity):
            return 'Low'
        elif any(indicator in technique_lower for indicator in high_complexity):
            return 'High'
        else:
            return 'Medium'
    
    def _assess_crypto_exploitability(self, technique: str) -> str:
        """Assess exploitability of cryptographic attack"""
        easy_exploits = ['hardcoded key', 'md5 collision', 'des encryption']
        hard_exploits = ['quantum attack', 'side-channel', 'fault injection']
        
        technique_lower = technique.lower()
        
        if any(exploit in technique_lower for exploit in easy_exploits):
            return 'Easy'
        elif any(exploit in technique_lower for exploit in hard_exploits):
            return 'Hard'
        else:
            return 'Medium'
    
    def _assess_crypto_impact(self, technique: str) -> str:
        """Assess impact level of cryptographic attack"""
        if any(keyword in technique.lower() for keyword in ['key recovery', 'private key', 'master key']):
            return 'High'
        elif any(keyword in technique.lower() for keyword in ['collision', 'forgery', 'bypass']):
            return 'Medium'
        else:
            return 'Low'
    
    def _assess_quantum_threat(self, technique: str) -> bool:
        """Assess if technique is quantum-vulnerable"""
        quantum_vulnerable = ['rsa', 'ecc', 'ecdsa', 'discrete log', 'factoring']
        return any(vuln in technique.lower() for vuln in quantum_vulnerable)
    
    def _generate_crypto_mitigation(self, category: str, technique: str) -> str:
        """Generate mitigation advice for cryptographic attack"""
        mitigations = {
            'weak_ciphers': 'Use AES-256 with GCM mode and strong key derivation',
            'key_management_flaws': 'Implement secure key storage with hardware security module',
            'hash_vulnerabilities': 'Use SHA-256 or SHA-3 with proper salting',
            'random_number_attacks': 'Use cryptographically secure random number generators',
            'certificate_attacks': 'Implement certificate pinning and validation',
            'protocol_attacks': 'Use TLS 1.3 with strong cipher suites',
            'side_channel_attacks': 'Implement constant-time algorithms and masking',
            'quantum_readiness': 'Plan migration to post-quantum cryptographic algorithms'
        }
        
        return mitigations.get(category, 'Follow cryptographic best practices')
    
    async def _analyze_crypto_vulnerabilities(self, app_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze cryptographic vulnerabilities in application"""
        vulnerabilities = []
        
        # Simulate cryptographic vulnerability analysis
        for i, assessment in enumerate(self.security_assessments):
            vulnerability = {
                'id': f"crypto_vuln_{i:03d}",
                'type': assessment,
                'severity': self._assess_assessment_severity(assessment),
                'description': f"Assessment of {assessment.lower()}",
                'recommendation': self._get_assessment_recommendation(assessment),
                'compliance_impact': self._assess_compliance_impact(assessment)
            }
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _assess_assessment_severity(self, assessment: str) -> str:
        """Assess severity of security assessment"""
        critical_assessments = ['Encryption algorithm strength', 'Key management security']
        high_assessments = ['Random number generation', 'Certificate validation']
        
        if assessment in critical_assessments:
            return 'Critical'
        elif assessment in high_assessments:
            return 'High'
        else:
            return 'Medium'
    
    def _get_assessment_recommendation(self, assessment: str) -> str:
        """Get recommendation for security assessment"""
        recommendations = {
            'Encryption algorithm strength analysis': 'Use NIST-approved encryption algorithms',
            'Key management security evaluation': 'Implement hardware-backed key storage',
            'Random number generation quality': 'Use SecureRandom with proper seeding',
            'Certificate validation implementation': 'Validate entire certificate chain',
            'Cryptographic protocol security': 'Use TLS 1.3 with forward secrecy',
            'Side-channel resistance assessment': 'Implement countermeasures against timing attacks',
            'Quantum readiness evaluation': 'Plan post-quantum cryptography migration',
            'Implementation vulnerability scan': 'Regular security audits and updates'
        }
        
        return recommendations.get(assessment, 'Follow industry security standards')
    
    def _assess_compliance_impact(self, assessment: str) -> str:
        """Assess compliance impact of assessment"""
        if 'encryption' in assessment.lower() or 'key management' in assessment.lower():
            return 'FIPS 140-2, Common Criteria'
        elif 'quantum' in assessment.lower():
            return 'NIST Post-Quantum Cryptography'
        else:
            return 'Industry Standards'
    
    def _identify_weak_implementations(self, app_context: Dict[str, Any]) -> List[str]:
        """Identify weak cryptographic implementations"""
        weak_implementations = [
            'Custom cryptographic algorithms without peer review',
            'Deprecated SSL/TLS protocol versions',
            'Weak random number generation',
            'Insufficient key derivation parameters',
            'Missing certificate validation',
            'Hardcoded cryptographic secrets',
            'Insecure cryptographic mode usage',
            'Weak password-based encryption'
        ]
        
        return weak_implementations
    
    def _generate_crypto_recommendations(self, attack_vectors: List[CryptographicAttackVector], 
                                       vulnerabilities: List[Dict[str, Any]]) -> List[str]:
        """Generate cryptographic security recommendations"""
        recommendations = [
            'Use AES-256 with GCM mode for symmetric encryption',
            'Implement RSA-4096 or ECDSA P-384 for asymmetric operations',
            'Use SHA-256 or SHA-3 for cryptographic hashing',
            'Implement proper key derivation with PBKDF2/scrypt/Argon2',
            'Use cryptographically secure random number generators',
            'Implement certificate pinning for HTTPS connections',
            'Use TLS 1.3 with forward secrecy cipher suites',
            'Implement constant-time cryptographic operations',
            'Plan migration to post-quantum cryptographic algorithms',
            'Conduct regular cryptographic security audits',
            'Implement hardware security module for key storage',
            'Use authenticated encryption modes (GCM, CCM, ChaCha20-Poly1305)'
        ]
        
        return recommendations
    
    def _calculate_crypto_risk_score(self, attack_vectors: List[CryptographicAttackVector], 
                                   vulnerabilities: List[Dict[str, Any]]) -> float:
        """Calculate overall cryptographic risk score"""
        # Base score calculation
        vector_score = len(attack_vectors) * 0.08
        vuln_score = len(vulnerabilities) * 0.12
        
        # Severity adjustments
        critical_vectors = sum(1 for v in attack_vectors if v.severity == CryptoSeverity.CRITICAL)
        high_vectors = sum(1 for v in attack_vectors if v.severity == CryptoSeverity.HIGH)
        
        # Quantum threat adjustment
        quantum_vulnerable = sum(1 for v in attack_vectors if v.evidence.get('quantum_threat', False))
        
        severity_multiplier = 1.0 + (critical_vectors * 0.4) + (high_vectors * 0.25) + (quantum_vulnerable * 0.1)
        
        risk_score = (vector_score + vuln_score) * severity_multiplier
        
        # Cap at 10.0
        return min(risk_score, 10.0)

# Integration function
async def integrate_cryptographic_exploitation_with_aods(app_context: Dict[str, Any]) -> Dict[str, Any]:
    """Integrate cryptographic exploitation analysis with AODS framework"""
    coordinator = CryptographicExploitationCoordinator()
    
    try:
        # Perform cryptographic attack analysis
        crypto_analysis = await coordinator.analyze_cryptographic_attack_surface(app_context)
        
        return {
            'cryptographic_exploitation_analysis': {
                'analysis_id': crypto_analysis.analysis_id,
                'attack_vectors_count': len(crypto_analysis.attack_vectors_found),
                'vulnerabilities_count': len(crypto_analysis.crypto_vulnerabilities),
                'weak_implementations_count': len(crypto_analysis.weak_implementations),
                'crypto_risk_score': crypto_analysis.crypto_risk_score,
                'attack_vectors': [
                    {
                        'vector_id': vector.vector_id,
                        'attack_type': vector.attack_type.value,
                        'severity': vector.severity.value,
                        'technique': vector.technique,
                        'target_algorithm': vector.target_algorithm,
                        'exploit_payload': vector.exploit_payload[:50] + '...' if len(vector.exploit_payload) > 50 else vector.exploit_payload,
                        'evidence': vector.evidence
                    }
                    for vector in crypto_analysis.attack_vectors_found[:25]  # Limit for performance
                ],
                'security_recommendations': crypto_analysis.security_recommendations,
                'analysis_summary': {
                    'total_attack_techniques': sum(len(techniques) for techniques in coordinator.crypto_attack_techniques.values()),
                    'categories_analyzed': len(coordinator.crypto_attack_techniques),
                    'security_assessments_performed': len(coordinator.security_assessments),
                    'crypto_patterns_checked': sum(len(patterns) for patterns in coordinator.crypto_patterns.values())
                }
            }
        }
        
    except Exception as e:
        return {
            'cryptographic_exploitation_analysis': {
                'status': 'error',
                'error_message': str(e),
                'analysis_id': 'failed'
            }
        } 