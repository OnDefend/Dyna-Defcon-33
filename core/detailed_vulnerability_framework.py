#!/usr/bin/env python3
"""
Vulnerability reporting framework for AODS.

This module provides vulnerability reporting with WHAT/WHERE/WHY/HOW details.
"""

import json
import logging
import re
import traceback
from datetime import datetime
from dataclasses import dataclass, asdict
from typing import Any, Dict, List, Optional, Union
from pathlib import Path

logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityLocation:
    """Precise location information for vulnerability tracking."""
    
    file_path: str
    line_number: int
    method_name: str
    class_name: str
    component_type: str  # e.g., 'WebView', 'Network', 'Native Binary', 'Runtime API Call'
    stack_trace: Optional[str] = None
    
    def __post_init__(self):
        """Validate and normalize location data."""
        # Ensure line number is non-negative
        if self.line_number < 0:
            self.line_number = 0
            
        # Normalize file path (remove common prefixes)
        if self.file_path.startswith('./'):
            self.file_path = self.file_path[2:]
            
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return asdict(self)
        
    def format_display(self) -> str:
        """Format location for human-readable display."""
        if self.line_number > 0:
            return f"{self.file_path}:{self.line_number} in {self.class_name}.{self.method_name}()"
        else:
            return f"{self.file_path} in {self.class_name}.{self.method_name}()"

@dataclass
class RemediationGuidance:
    """Actionable remediation guidance with secure code examples."""
    
    fix_description: str
    code_example: str
    references: List[str]
    difficulty_level: str = "MEDIUM"  # LOW, MEDIUM, HIGH
    estimated_time: str = "1-2 hours"
    
    def __post_init__(self):
        """Validate remediation guidance."""
        if not self.fix_description.strip():
            raise ValueError("Fix description cannot be empty")
            
        if not self.code_example.strip():
            logger.warning("Code example is empty - providing generic guidance")
            self.code_example = "// Implement secure coding practices as described above"
            
        # Ensure references is a list
        if isinstance(self.references, str):
            self.references = [self.references]
            
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return asdict(self)
        
    def format_for_report(self) -> Dict[str, Any]:
        """Format remediation for report generation."""
        return {
            'description': self.fix_description,
            'steps': self._extract_steps(),
            'code_example': self.code_example,
            'references': self.references,
            'difficulty': self.difficulty_level,
            'estimated_time': self.estimated_time,
            'formatted_code': self._format_code()
        }
        
    def _extract_steps(self) -> List[str]:
        """Extract step-by-step instructions from description."""
        # Simple extraction of numbered or bulleted lists
        steps = []
        lines = self.fix_description.split('\n')
        
        for line in lines:
            line = line.strip()
            # Match numbered steps (1., 2., etc.) or bullet points (•, -, *)
            if re.match(r'^(\d+\.|[•\-*])\s+', line):
                steps.append(re.sub(r'^(\d+\.|[•\-*])\s+', '', line))
        
        # If no structured steps found, split by sentences
        if not steps and self.fix_description:
            steps = [s.strip() + '.' for s in self.fix_description.split('.') if s.strip()]
            
        return steps
        
    def _format_code(self) -> str:
        """Apply basic formatting to code example."""
        # Remove excessive whitespace while preserving indentation
        lines = self.code_example.split('\n')
        formatted_lines = []
        
        for line in lines:
            if line.strip():  # Non-empty lines
                formatted_lines.append(line.rstrip())
            elif formatted_lines and formatted_lines[-1].strip():  # Empty line after content
                formatted_lines.append('')
                
        return '\n'.join(formatted_lines)

@dataclass
class VulnerabilityEvidence:
    """Evidence supporting vulnerability detection."""
    
    matched_pattern: str
    detection_method: str
    confidence_score: float  # 0.0-1.0
    timestamp: Optional[float] = None
    additional_context: Dict[str, Any] = None
    
    def __post_init__(self):
        """Validate evidence data."""
        # Ensure confidence score is in valid range
        self.confidence_score = max(0.0, min(1.0, self.confidence_score))
        
        # Set timestamp if not provided
        if self.timestamp is None and 'dynamic' in self.detection_method.lower():
            self.timestamp = datetime.now().timestamp()
            
        # Initialize additional context if None
        if self.additional_context is None:
            self.additional_context = {}
            
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return asdict(self)
        
    def format_for_verification(self) -> str:
        """Format evidence for manual verification."""
        parts = [f"Detection Method: {self.detection_method}"]
        parts.append(f"Confidence: {self.confidence_score:.1%}")
        
        if self.matched_pattern:
            parts.append(f"Pattern: {self.matched_pattern}")
            
        if self.timestamp:
            dt = datetime.fromtimestamp(self.timestamp)
            parts.append(f"Detected: {dt.strftime('%Y-%m-%d %H:%M:%S')}")
            
        return " | ".join(parts)

@dataclass
class VulnerabilityPattern:
    """Enhanced pattern with detailed reporting information."""
    
    pattern: str
    severity: str
    cwe_id: str
    what_description: str
    why_explanation: str
    remediation_guidance: str
    confidence_level: float = 0.9
    category: str = "GENERAL_SECURITY"
    
    def __post_init__(self):
        """Validate pattern data."""
        # Validate severity
        valid_severities = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']
        if self.severity not in valid_severities:
            logger.warning(f"Invalid severity '{self.severity}', defaulting to MEDIUM")
            self.severity = 'MEDIUM'
            
        # Validate confidence level
        self.confidence_level = max(0.0, min(1.0, self.confidence_level))
        
        # Ensure CWE ID format
        if self.cwe_id and not self.cwe_id.startswith('CWE-'):
            self.cwe_id = f"CWE-{self.cwe_id}"
            
    def matches(self, signature: str) -> bool:
        """Check if signature matches vulnerability pattern."""
        try:
            return re.search(self.pattern, signature, re.IGNORECASE) is not None
        except re.error as e:
            logger.error(f"Invalid regex pattern '{self.pattern}': {e}")
            return False
            
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return asdict(self)

class DetailedVulnerability:
    """Comprehensive vulnerability with WHAT/WHERE/WHY/HOW reporting."""
    
    def __init__(self, vulnerability_type: str, severity: str, cwe_id: str,
                 location: VulnerabilityLocation, security_impact: str,
                 remediation: RemediationGuidance, evidence: VulnerabilityEvidence):
        self.vulnerability_type = vulnerability_type  # WHAT
        self.severity = severity
        self.cwe_id = cwe_id
        self.location = location                      # WHERE
        self.security_impact = security_impact        # WHY
        self.remediation = remediation               # HOW TO FIX
        self.evidence = evidence                     # PROOF
        
        # Additional metadata
        self.detection_date = datetime.now()
        self.unique_id = self._generate_unique_id()
        self.risk_score = self._calculate_risk_score()
        
    def _generate_unique_id(self) -> str:
        """Generate unique identifier for this vulnerability."""
        import hashlib
        
        # Create hash from key vulnerability attributes
        hash_input = f"{self.vulnerability_type}:{self.location.file_path}:{self.location.line_number}:{self.cwe_id}"
        return hashlib.sha256(hash_input.encode()).hexdigest()[:16]
        
    def _calculate_risk_score(self) -> float:
        """Calculate risk score based on severity and confidence."""
        severity_weights = {
            'CRITICAL': 1.0,
            'HIGH': 0.8,
            'MEDIUM': 0.6,
            'LOW': 0.4,
            'INFO': 0.2
        }
        
        base_score = severity_weights.get(self.severity, 0.6)
        confidence_modifier = self.evidence.confidence_score
        
        return base_score * confidence_modifier
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'unique_id': self.unique_id,
            'vulnerability_type': self.vulnerability_type,
            'severity': self.severity,
            'cwe_id': self.cwe_id,
            'location': self.location.to_dict(),
            'security_impact': self.security_impact,
            'remediation': self.remediation.to_dict(),
            'evidence': self.evidence.to_dict(),
            'detection_date': self.detection_date.isoformat(),
            'risk_score': self.risk_score
        }
        
    def generate_attack_scenarios(self) -> List[str]:
        """Generate realistic attack scenarios based on vulnerability type."""
        scenarios = []
        
        vuln_type_lower = self.vulnerability_type.lower()
        
        if 'xss' in vuln_type_lower or 'cross-site scripting' in vuln_type_lower:
            scenarios.extend([
                "Attacker injects malicious script via vulnerable input field",
                "Script executes in WebView context, accessing sensitive data",
                "Malicious code calls JavaScript bridge methods for privilege escalation"
            ])
        elif 'sql injection' in vuln_type_lower:
            scenarios.extend([
                "Attacker modifies request parameters to inject SQL commands",
                "Database query executes with malicious SQL, exposing sensitive data",
                "Attacker potentially gains full database access"
            ])
        elif 'cryptographic' in vuln_type_lower or 'crypto' in vuln_type_lower:
            scenarios.extend([
                "Attacker intercepts encrypted data transmission",
                "Weak encryption algorithm is broken using available tools",
                "Sensitive data is exposed in plaintext"
            ])
        elif 'storage' in vuln_type_lower:
            scenarios.extend([
                "Attacker gains access to device file system",
                "Sensitive data is read from insecurely stored files",
                "Credentials or personal information is compromised"
            ])
        elif 'network' in vuln_type_lower:
            scenarios.extend([
                "Attacker performs man-in-the-middle attack",
                "Network traffic is intercepted and analyzed",
                "Sensitive data is exposed during transmission"
            ])
        else:
            # Generic scenarios
            scenarios.extend([
                "Attacker exploits vulnerability to gain unauthorized access",
                "Security controls are bypassed through vulnerability",
                "Sensitive application data may be compromised"
            ])
            
        return scenarios
        
    def format_for_legacy_report(self) -> Dict[str, Any]:
        """Format vulnerability for integration with existing ReportGenerator."""
        return {
            'title': f"{self.severity}: {self.vulnerability_type}",
            'severity': self.severity,
            'description': f"{self.security_impact}\n\nLocation: {self.location.format_display()}",
            'category': self._categorize_vulnerability(),
            'risk_level': self.severity,
            'attack_scenarios': self.generate_attack_scenarios(),
            'manual_verification': self._generate_verification_steps(),
            'security_recommendations': [self.remediation.fix_description],
            'impact_analysis': self._analyze_impact(),
            'cwe_id': self.cwe_id,
            'confidence': self.evidence.confidence_score,
            'location_details': {
                'file_path': self.location.file_path,
                'line_number': self.location.line_number,
                'method_name': self.location.method_name,
                'class_name': self.location.class_name,
                'component_type': self.location.component_type
            }
        }
        
    def _categorize_vulnerability(self) -> str:
        """Categorize vulnerability for legacy compatibility."""
        vuln_type_lower = self.vulnerability_type.lower()
        
        if 'webview' in vuln_type_lower or 'javascript' in vuln_type_lower or 'xss' in vuln_type_lower:
            return 'WEBVIEW_SECURITY'
        elif 'network' in vuln_type_lower or 'certificate' in vuln_type_lower or 'ssl' in vuln_type_lower:
            return 'NETWORK_SECURITY'
        elif 'crypto' in vuln_type_lower or 'encryption' in vuln_type_lower:
            return 'CRYPTOGRAPHIC'
        elif 'storage' in vuln_type_lower or 'file' in vuln_type_lower:
            return 'DATA_STORAGE'
        elif 'native' in vuln_type_lower or 'binary' in vuln_type_lower:
            return 'NATIVE_CODE'
        elif 'intent' in vuln_type_lower or 'activity' in vuln_type_lower:
            return 'COMPONENT_SECURITY'
        else:
            return 'GENERAL_SECURITY'
            
    def _generate_verification_steps(self) -> List[str]:
        """Generate manual verification steps."""
        steps = [
            f"Navigate to {self.location.format_display()}",
            f"Verify the presence of: {self.evidence.matched_pattern}",
            f"Check if {self.vulnerability_type.lower()} can be exploited"
        ]
        
        # Add component-specific verification steps
        if self.location.component_type == 'WebView':
            steps.append("Test with XSS payloads if applicable")
            steps.append("Check JavaScript bridge security")
        elif self.location.component_type == 'Network':
            steps.append("Monitor network traffic during testing")
            steps.append("Verify certificate validation")
        elif self.location.component_type == 'Native Binary':
            steps.append("Disassemble binary for manual analysis")
            steps.append("Check for buffer overflow conditions")
            
        return steps
        
    def _analyze_impact(self) -> Dict[str, str]:
        """Analyze security impact across different dimensions."""
        # Basic impact analysis based on severity and type
        impact_levels = {
            'CRITICAL': 'HIGH',
            'HIGH': 'MEDIUM',
            'MEDIUM': 'LOW',
            'LOW': 'MINIMAL',
            'INFO': 'MINIMAL'
        }
        
        base_impact = impact_levels.get(self.severity, 'LOW')
        
        return {
            'confidentiality': base_impact,
            'integrity': base_impact,
            'availability': 'LOW' if base_impact != 'MINIMAL' else 'MINIMAL',
            'business_impact': f"Security vulnerability may impact {self.location.component_type.lower()} functionality"
        }

class DetailedVulnerabilityReporter:
    """Comprehensive vulnerability reporting engine."""
    
    def __init__(self):
        self.report_formats = ['json', 'html', 'pdf', 'sarif']
        self.severity_mapping = {
            'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1, 'INFO': 0
        }
        
    def integrate_with_legacy_reporter(self, vulnerabilities: List[DetailedVulnerability], 
                                    legacy_reporter) -> None:
        """Integrate detailed vulnerabilities with existing ReportGenerator."""
        try:
            # Convert detailed vulnerabilities to legacy format
            legacy_vulnerabilities = []
            
            for vuln in vulnerabilities:
                legacy_format = vuln.format_for_legacy_report()
                legacy_vulnerabilities.append(legacy_format)
                
            # Set external vulnerabilities in legacy reporter
            if hasattr(legacy_reporter, 'set_external_vulnerabilities'):
                legacy_reporter.set_external_vulnerabilities(legacy_vulnerabilities)
                logger.info(f"Integrated {len(legacy_vulnerabilities)} detailed vulnerabilities with ReportGenerator")
            else:
                # Fallback: add as report sections
                for vuln in vulnerabilities:
                    title = f"{vuln.severity}: {vuln.vulnerability_type}"
                    content = self._format_vulnerability_content(vuln)
                    legacy_reporter.add_section(title, content)
                    
        except Exception as e:
            logger.error(f"Error integrating with legacy reporter: {e}")
            logger.error(traceback.format_exc())
            
    def _format_vulnerability_content(self, vuln: DetailedVulnerability) -> str:
        """Format vulnerability for legacy report content."""
        content_parts = [
            f"**Vulnerability Type**: {vuln.vulnerability_type}",
            f"**Severity**: {vuln.severity}",
            f"**CWE**: {vuln.cwe_id}",
            "",
            "**Location**:",
            f"• File: {vuln.location.file_path}",
            f"• Line: {vuln.location.line_number}",
            f"• Method: {vuln.location.method_name}",
            f"• Class: {vuln.location.class_name}",
            f"• Component: {vuln.location.component_type}",
            "",
            "**Security Impact**:",
            vuln.security_impact,
            "",
            "**Remediation**:",
            vuln.remediation.fix_description,
            "",
            "**Secure Code Example**:",
            "```",
            vuln.remediation.code_example,
            "```",
            "",
            "**References**:",
        ]
        
        for ref in vuln.remediation.references:
            content_parts.append(f"• {ref}")
            
        content_parts.extend([
            "",
            "**Evidence**:",
            f"• Detection Method: {vuln.evidence.detection_method}",
            f"• Confidence: {vuln.evidence.confidence_score:.1%}",
            f"• Pattern: {vuln.evidence.matched_pattern}"
        ])
        
        return "\n".join(content_parts)

# Factory functions for easy integration
def create_detailed_vulnerability(vulnerability_type: str, severity: str, cwe_id: str,
                                file_path: str, line_number: int, method_name: str,
                                class_name: str, component_type: str,
                                security_impact: str, fix_description: str,
                                code_example: str, references: List[str],
                                matched_pattern: str, detection_method: str,
                                confidence_score: float) -> DetailedVulnerability:
    """Factory function to create DetailedVulnerability with validation."""
    
    location = VulnerabilityLocation(
        file_path=file_path,
        line_number=line_number,
        method_name=method_name,
        class_name=class_name,
        component_type=component_type
    )
    
    remediation = RemediationGuidance(
        fix_description=fix_description,
        code_example=code_example,
        references=references
    )
    
    evidence = VulnerabilityEvidence(
        matched_pattern=matched_pattern,
        detection_method=detection_method,
        confidence_score=confidence_score
    )
    
    return DetailedVulnerability(
        vulnerability_type=vulnerability_type,
        severity=severity,
        cwe_id=cwe_id,
        location=location,
        security_impact=security_impact,
        remediation=remediation,
        evidence=evidence
    )

def load_vulnerability_patterns() -> Dict[str, VulnerabilityPattern]:
    """Load standard vulnerability patterns for organic detection."""
    return {
        'crypto_weakness': VulnerabilityPattern(
            pattern=r'(DES|MD5|SHA1)\.getInstance',
            severity='HIGH',
            cwe_id='CWE-327',
            what_description='Weak cryptographic algorithm detected',
            why_explanation='Using deprecated algorithms like DES, MD5, or SHA1 makes data vulnerable to cryptographic attacks',
            remediation_guidance='Replace with AES-256, SHA-256, or SHA-3 for secure encryption'
        ),
        'data_leakage': VulnerabilityPattern(
            pattern=r'(Log\.|System\.out\.print)',
            severity='MEDIUM',
            cwe_id='CWE-532',
            what_description='Sensitive data logging detected',
            why_explanation='Logging sensitive information can expose data in system logs accessible to other apps',
            remediation_guidance='Remove sensitive data from logs or use secure logging mechanisms'
        ),
        'insecure_storage': VulnerabilityPattern(
            pattern=r'(MODE_WORLD_READABLE|openFileOutput)',
            severity='HIGH',
            cwe_id='CWE-732',
            what_description='Insecure file storage permissions',
            why_explanation='World-readable files can be accessed by any application on the device',
            remediation_guidance='Use MODE_PRIVATE or implement proper access controls'
        ),
        'javascript_interface': VulnerabilityPattern(
            pattern=r'@JavascriptInterface',
            severity='HIGH',
            cwe_id='CWE-79',
            what_description='JavaScript bridge method detected',
            why_explanation='JavaScript interfaces allow web content to access native functionality, potentially enabling XSS attacks',
            remediation_guidance='Add proper input validation and restrict to trusted origins'
        ),
        'sql_injection': VulnerabilityPattern(
            pattern=r'(SELECT|INSERT|UPDATE|DELETE).*\+.*["\']',
            severity='CRITICAL',
            cwe_id='CWE-89',
            what_description='Potential SQL injection vulnerability',
            why_explanation='String concatenation in SQL queries allows attackers to inject malicious SQL commands',
            remediation_guidance='Use parameterized queries or prepared statements'
        )
    } 
 
 
 
 