#!/usr/bin/env python3
"""
Universal Vulnerability Reporter for AODS Plugin Modularization

This module provides standardized vulnerability reporting across all plugins,
ensuring consistent output formats and professional presentation.

Features:
- Standardized vulnerability reporting format
- Multi-format output (JSON, CSV, TXT, Rich console)
- styling with color coding
- MASVS control mapping display
- Comprehensive vulnerability aggregation
- Performance metrics reporting
"""

import logging
import json
import csv
import time
from typing import Dict, List, Optional, Any, Union
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass, field, asdict

from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.text import Text
from rich.progress import Progress, BarColumn, TextColumn

from core.shared_data_structures import (
    BaseVulnerability,
    VulnerabilityType,
    VulnerabilitySeverity,
    VulnerabilityFinding
)

logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityReport:
    """Comprehensive vulnerability report structure."""
    
    # Report metadata
    report_id: str
    package_name: str
    analysis_timestamp: datetime
    analysis_version: str
    
    # Vulnerability findings
    vulnerabilities: List[BaseVulnerability] = field(default_factory=list)
    
    # Summary statistics
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    info_count: int = 0
    
    # Analysis metadata
    analysis_duration: float = 0.0
    plugins_executed: List[str] = field(default_factory=list)
    files_analyzed: int = 0
    
    # Quality metrics
    avg_confidence: float = 0.0
    min_confidence: float = 1.0
    max_confidence: float = 0.0
    
    # Compliance mapping
    masvs_coverage: Dict[str, List[str]] = field(default_factory=dict)
    mstg_coverage: Dict[str, List[str]] = field(default_factory=dict)
    
    def __post_init__(self):
        """Calculate derived metrics."""
        self._calculate_statistics()
        self._calculate_compliance_coverage()
    
    def _calculate_statistics(self):
        """Calculate vulnerability statistics."""
        self.total_vulnerabilities = len(self.vulnerabilities)
        
        if not self.vulnerabilities:
            return
        
        # Count by severity
        severity_counts = {}
        confidences = []
        
        for vuln in self.vulnerabilities:
            severity = vuln.severity.value if hasattr(vuln.severity, 'value') else str(vuln.severity)
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            if hasattr(vuln, 'confidence') and vuln.confidence is not None:
                confidences.append(vuln.confidence)
        
        # Update counts
        self.critical_count = severity_counts.get('CRITICAL', 0)
        self.high_count = severity_counts.get('HIGH', 0)
        self.medium_count = severity_counts.get('MEDIUM', 0)
        self.low_count = severity_counts.get('LOW', 0)
        self.info_count = severity_counts.get('INFO', 0)
        
        # Calculate confidence metrics
        if confidences:
            self.avg_confidence = sum(confidences) / len(confidences)
            self.min_confidence = min(confidences)
            self.max_confidence = max(confidences)
    
    def _calculate_compliance_coverage(self):
        """Calculate MASVS and MSTG coverage."""
        for vuln in self.vulnerabilities:
            if hasattr(vuln, 'masvs_refs') and vuln.masvs_refs:
                for ref in vuln.masvs_refs:
                    if ref not in self.masvs_coverage:
                        self.masvs_coverage[ref] = []
                    self.masvs_coverage[ref].append(vuln.vulnerability_id)
            
            if hasattr(vuln, 'mstg_refs') and vuln.mstg_refs:
                for ref in vuln.mstg_refs:
                    if ref not in self.mstg_coverage:
                        self.mstg_coverage[ref] = []
                    self.mstg_coverage[ref].append(vuln.vulnerability_id)

class VulnerabilityReporter:
    """
    Universal vulnerability reporter providing standardized output
    formats and professional presentation across all AODS plugins.
    """
    
    def __init__(self, console: Optional[Console] = None):
        """
        Initialize vulnerability reporter.
        
        Args:
            console: Rich console for output (optional)
        """
        self.console = console or Console()
        self.logger = logging.getLogger(__name__)
        
        # Output configuration
        self.enable_color = True
        self.enable_rich_formatting = True
        self.max_description_length = 200
        
        # Severity styling
        self.severity_styles = {
            'CRITICAL': 'bold red',
            'HIGH': 'red',
            'MEDIUM': 'yellow',
            'LOW': 'blue',
            'INFO': 'green'
        }
        
        # Confidence styling
        self.confidence_styles = {
            'high': 'bold green',      # >= 0.8
            'medium': 'yellow',        # >= 0.5
            'low': 'red'               # < 0.5
        }
    
    def create_report(self, 
                     package_name: str,
                     vulnerabilities: List[BaseVulnerability],
                     analysis_metadata: Optional[Dict[str, Any]] = None) -> VulnerabilityReport:
        """
        Create a comprehensive vulnerability report.
        
        Args:
            package_name: Package name being analyzed
            vulnerabilities: List of vulnerability findings
            analysis_metadata: Additional analysis metadata
            
        Returns:
            VulnerabilityReport: Comprehensive report structure
        """
        metadata = analysis_metadata or {}
        
        report = VulnerabilityReport(
            report_id=f"AODS-{package_name}-{int(time.time())}",
            package_name=package_name,
            analysis_timestamp=datetime.now(),
            analysis_version=metadata.get('analysis_version', '2.0.0'),
            vulnerabilities=vulnerabilities,
            analysis_duration=metadata.get('analysis_duration', 0.0),
            plugins_executed=metadata.get('plugins_executed', []),
            files_analyzed=metadata.get('files_analyzed', 0)
        )
        
        self.logger.info(f"Created vulnerability report: {report.report_id}")
        return report
    
    def display_console_report(self, report: VulnerabilityReport) -> None:
        """
        Display vulnerability report in Rich console format.
        
        Args:
            report: Vulnerability report to display
        """
        self.logger.info("Displaying console vulnerability report")
        
        # Display header
        self._display_report_header(report)
        
        # Display summary statistics
        self._display_summary_table(report)
        
        # Display vulnerability details
        self._display_vulnerability_details(report)
        
        # Display compliance coverage
        self._display_compliance_coverage(report)
        
        # Display recommendations
        self._display_recommendations(report)
    
    def _display_report_header(self, report: VulnerabilityReport) -> None:
        """Display report header."""
        header_content = [
            f"[bold]Package:[/bold] {report.package_name}",
            f"[bold]Report ID:[/bold] {report.report_id}",
            f"[bold]Analysis Time:[/bold] {report.analysis_timestamp.strftime('%Y-%m-%d %H:%M:%S')}",
            f"[bold]Duration:[/bold] {report.analysis_duration:.2f}s",
            f"[bold]Files Analyzed:[/bold] {report.files_analyzed}",
            f"[bold]Plugins:[/bold] {', '.join(report.plugins_executed) if report.plugins_executed else 'N/A'}"
        ]
        
        self.console.print(Panel(
            "\n".join(header_content),
            title="[bold blue]AODS Vulnerability Analysis Report[/bold blue]",
            border_style="blue"
        ))
    
    def _display_summary_table(self, report: VulnerabilityReport) -> None:
        """Display summary statistics table."""
        table = Table(title="Vulnerability Summary")
        table.add_column("Severity", style="bold")
        table.add_column("Count", justify="right")
        table.add_column("Percentage", justify="right")
        
        total = report.total_vulnerabilities or 1
        
        severities = [
            ("CRITICAL", report.critical_count, "bold red"),
            ("HIGH", report.high_count, "red"),
            ("MEDIUM", report.medium_count, "yellow"),
            ("LOW", report.low_count, "blue"),
            ("INFO", report.info_count, "green")
        ]
        
        for severity, count, style in severities:
            percentage = (count / total) * 100
            table.add_row(
                Text(severity, style=style),
                str(count),
                f"{percentage:.1f}%"
            )
        
        table.add_row("", "", "")
        table.add_row(
            Text("TOTAL", style="bold"),
            str(report.total_vulnerabilities),
            "100.0%"
        )
        
        self.console.print(table)
    
    def _display_vulnerability_details(self, report: VulnerabilityReport) -> None:
        """Display detailed vulnerability information."""
        if not report.vulnerabilities:
            self.console.print("[yellow]No vulnerabilities found[/yellow]")
            return
        
        # Group vulnerabilities by severity
        grouped_vulns = {}
        for vuln in report.vulnerabilities:
            severity = vuln.severity.value if hasattr(vuln.severity, 'value') else str(vuln.severity)
            if severity not in grouped_vulns:
                grouped_vulns[severity] = []
            grouped_vulns[severity].append(vuln)
        
        # Display each severity group
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
            if severity in grouped_vulns:
                self._display_severity_group(severity, grouped_vulns[severity])
    
    def _display_severity_group(self, severity: str, vulnerabilities: List[BaseVulnerability]) -> None:
        """Display vulnerabilities for a specific severity level."""
        style = self.severity_styles.get(severity, 'white')
        
        self.console.print(f"\n[{style}]== {severity} VULNERABILITIES ({len(vulnerabilities)}) ==[/{style}]")
        
        for i, vuln in enumerate(vulnerabilities, 1):
            self._display_single_vulnerability(vuln, i)
    
    def _display_single_vulnerability(self, vuln: BaseVulnerability, index: int) -> None:
        """Display a single vulnerability."""
        # Get confidence styling
        confidence_style = self._get_confidence_style(getattr(vuln, 'confidence', 0.0))
        
        # Create vulnerability info
        info_lines = [
            f"[bold]{index}. {vuln.title}[/bold]",
            f"[dim]ID:[/dim] {vuln.vulnerability_id}",
            f"[dim]Location:[/dim] {getattr(vuln, 'location', 'N/A')}",
            f"[dim]Confidence:[/dim] [{confidence_style}]{getattr(vuln, 'confidence', 0.0):.2f}[/{confidence_style}]",
        ]
        
        # Add description (truncated if too long)
        description = vuln.description
        if len(description) > self.max_description_length:
            description = description[:self.max_description_length] + "..."
        info_lines.append(f"[dim]Description:[/dim] {description}")
        
        # Add MASVS references if available
        if hasattr(vuln, 'masvs_refs') and vuln.masvs_refs:
            info_lines.append(f"[dim]MASVS:[/dim] {', '.join(vuln.masvs_refs)}")
        
        # Add remediation if available
        if hasattr(vuln, 'remediation') and vuln.remediation:
            remediation = vuln.remediation
            if len(remediation) > self.max_description_length:
                remediation = remediation[:self.max_description_length] + "..."
            info_lines.append(f"[dim]Remediation:[/dim] {remediation}")
        
        self.console.print("\n".join(info_lines))
        self.console.print()
    
    def _display_compliance_coverage(self, report: VulnerabilityReport) -> None:
        """Display compliance coverage."""
        if not report.masvs_coverage and not report.mstg_coverage:
            return
        
        self.console.print("\n[bold blue]== COMPLIANCE COVERAGE ==[/bold blue]")
        
        if report.masvs_coverage:
            table = Table(title="MASVS Controls Coverage")
            table.add_column("Control", style="bold")
            table.add_column("Vulnerabilities", justify="right")
            
            for control, vuln_ids in sorted(report.masvs_coverage.items()):
                table.add_row(control, str(len(vuln_ids)))
            
            self.console.print(table)
    
    def _display_recommendations(self, report: VulnerabilityReport) -> None:
        """Display security recommendations."""
        recommendations = []
        
        if report.critical_count > 0:
            recommendations.append("🔴 CRITICAL: Address critical vulnerabilities immediately")
        
        if report.high_count > 0:
            recommendations.append("🟠 HIGH: Review and fix high-severity vulnerabilities")
        
        if report.avg_confidence < 0.5:
            recommendations.append("⚠️  WARNING: Low average confidence - consider manual review")
        
        if not recommendations:
            recommendations.append("✅ Good security posture - continue monitoring")
        
        if recommendations:
            self.console.print("\n[bold blue]== RECOMMENDATIONS ==[/bold blue]")
            for rec in recommendations:
                self.console.print(f"• {rec}")
    
    def _get_confidence_style(self, confidence: float) -> str:
        """Get confidence color styling."""
        if confidence >= 0.8:
            return 'bold green'
        elif confidence >= 0.5:
            return 'yellow'
        else:
            return 'red'
    
    def export_json(self, report: VulnerabilityReport, output_path: Path) -> None:
        """
        Export vulnerability report to JSON format.
        
        Args:
            report: Vulnerability report
            output_path: Output file path
        """
        try:
            # Convert report to dictionary
            report_dict = asdict(report)
            
            # Convert datetime objects to ISO format
            report_dict['analysis_timestamp'] = report.analysis_timestamp.isoformat()
            
            # Convert vulnerabilities to dict format
            vulnerabilities_dict = []
            for vuln in report.vulnerabilities:
                vuln_dict = asdict(vuln) if hasattr(vuln, '__dict__') else vars(vuln)
                vulnerabilities_dict.append(vuln_dict)
            
            report_dict['vulnerabilities'] = vulnerabilities_dict
            
            # Write to file
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(report_dict, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Exported JSON report to: {output_path}")
            
        except Exception as e:
            self.logger.error(f"Failed to export JSON report: {e}")
    
    def export_csv(self, report: VulnerabilityReport, output_path: Path) -> None:
        """
        Export vulnerability report to CSV format.
        
        Args:
            report: Vulnerability report
            output_path: Output file path
        """
        try:
            with open(output_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                
                # Write header
                writer.writerow([
                    'ID', 'Title', 'Severity', 'Confidence', 'Location', 
                    'Description', 'MASVS', 'Remediation'
                ])
                
                # Write vulnerability rows
                for vuln in report.vulnerabilities:
                    writer.writerow([
                        vuln.vulnerability_id,
                        vuln.title,
                        vuln.severity.value if hasattr(vuln.severity, 'value') else str(vuln.severity),
                        getattr(vuln, 'confidence', 0.0),
                        getattr(vuln, 'location', ''),
                        vuln.description,
                        ', '.join(getattr(vuln, 'masvs_refs', [])),
                        getattr(vuln, 'remediation', '')
                    ])
            
            self.logger.info(f"Exported CSV report to: {output_path}")
            
        except Exception as e:
            self.logger.error(f"Failed to export CSV report: {e}")
    
    def export_txt(self, report: VulnerabilityReport, output_path: Path) -> None:
        """
        Export vulnerability report to plain text format.
        
        Args:
            report: Vulnerability report
            output_path: Output file path
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                # Write header
                f.write("="*80 + "\n")
                f.write("AODS VULNERABILITY ANALYSIS REPORT\n")
                f.write("="*80 + "\n\n")
                
                # Write report metadata
                f.write(f"Package: {report.package_name}\n")
                f.write(f"Report ID: {report.report_id}\n")
                f.write(f"Analysis Time: {report.analysis_timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Duration: {report.analysis_duration:.2f}s\n")
                f.write(f"Files Analyzed: {report.files_analyzed}\n")
                f.write(f"Plugins: {', '.join(report.plugins_executed) if report.plugins_executed else 'N/A'}\n\n")
                
                # Write summary
                f.write("VULNERABILITY SUMMARY\n")
                f.write("-"*40 + "\n")
                f.write(f"Total Vulnerabilities: {report.total_vulnerabilities}\n")
                f.write(f"Critical: {report.critical_count}\n")
                f.write(f"High: {report.high_count}\n")
                f.write(f"Medium: {report.medium_count}\n")
                f.write(f"Low: {report.low_count}\n")
                f.write(f"Info: {report.info_count}\n\n")
                
                # Write vulnerability details
                f.write("VULNERABILITY DETAILS\n")
                f.write("-"*40 + "\n")
                
                for i, vuln in enumerate(report.vulnerabilities, 1):
                    f.write(f"\n{i}. {vuln.title}\n")
                    f.write(f"   ID: {vuln.vulnerability_id}\n")
                    f.write(f"   Severity: {vuln.severity.value if hasattr(vuln.severity, 'value') else str(vuln.severity)}\n")
                    f.write(f"   Confidence: {getattr(vuln, 'confidence', 0.0):.2f}\n")
                    f.write(f"   Location: {getattr(vuln, 'location', 'N/A')}\n")
                    f.write(f"   Description: {vuln.description}\n")
                    
                    if hasattr(vuln, 'masvs_refs') and vuln.masvs_refs:
                        f.write(f"   MASVS: {', '.join(vuln.masvs_refs)}\n")
                    
                    if hasattr(vuln, 'remediation') and vuln.remediation:
                        f.write(f"   Remediation: {vuln.remediation}\n")
            
            self.logger.info(f"Exported TXT report to: {output_path}")
            
        except Exception as e:
            self.logger.error(f"Failed to export TXT report: {e}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get reporter statistics."""
        return {
            'enable_color': self.enable_color,
            'enable_rich_formatting': self.enable_rich_formatting,
            'max_description_length': self.max_description_length,
            'supported_formats': ['console', 'json', 'csv', 'txt']
        } 