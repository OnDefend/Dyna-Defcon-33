#!/usr/bin/env python3
"""
Smart Code Location Mapper

Intelligent system that maps vulnerability findings to actual source code locations
and extracts meaningful code context instead of compiler metadata or bytecode annotations.
"""

import logging
import re
import json
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class CodeLocation:
    """Represents an exact code location with context."""
    file_path: str
    line_number: int
    column_number: Optional[int]
    method_name: Optional[str]
    class_name: Optional[str]
    actual_code: str
    context_before: List[str]
    context_after: List[str]
    vulnerability_context: str
    confidence_score: float

@dataclass
class CodeExtractionResult:
    """Result of code extraction operation."""
    success: bool
    locations: List[CodeLocation]
    errors: List[str]
    warnings: List[str]
    metadata: Dict[str, Any]

class SmartCodeLocationMapper:
    """
    Intelligent code location mapper that finds actual vulnerable code
    instead of compiler artifacts or metadata.
    """
    
    def __init__(self):
        """Initialize the smart code location mapper."""
        
        # Patterns for identifying compiler metadata vs actual code
        self.metadata_patterns = [
            r'@Metadata\(',
            r'/\*\s*compiled\s+from:',
            r'/\*\s*loaded\s+from:',
            r'^\s*package\s+',
            r'^\s*import\s+',
            r'@\w+\(',  # Annotations
            r'//\s*Auto-generated',
            r'//\s*Generated by',
            r'#\s*generated\s+by',
            r'^\s*#\s*line\s+\d+',  # Preprocessor directives
        ]
        
        # Patterns for actual vulnerable code constructs
        self.vulnerable_code_patterns = {
            'sql_injection': [
                r'\.execute\s*\(\s*["\'].*\+.*["\']',
                r'Statement\s*\.\s*execute',
                r'query\s*\(\s*["\'].*\+.*["\']',
                r'prepareStatement\s*\(\s*["\'].*\+.*["\']'
            ],
            'hardcoded_secret': [
                r'["\'][a-zA-Z0-9+/]{20,}["\']',  # Base64-like strings
                r'password\s*=\s*["\'][^"\']+["\']',
                r'key\s*=\s*["\'][^"\']+["\']',
                r'secret\s*=\s*["\'][^"\']+["\']',
                r'token\s*=\s*["\'][^"\']+["\']'
            ],
            'cleartext_communication': [
                r'http://[^"\'>\s]+',
                r'HttpURLConnection',
                r'setDefaultHttpClient',
                r'allowAllHostnameVerifier'
            ],
            'insecure_storage': [
                r'SharedPreferences\.Editor',
                r'openFileOutput\s*\(',
                r'MODE_WORLD_READABLE',
                r'MODE_WORLD_WRITABLE',
                r'getExternalStorage'
            ],
            'debug_enabled': [
                r'setDebuggingEnabled\s*\(\s*true',
                r'\.setDebugMode\s*\(\s*true',
                r'DEBUG\s*=\s*true',
                r'Log\.[dv]\(',
                r'System\.out\.print'
            ]
        }
        
        # File extensions to process
        self.supported_extensions = {
            '.java', '.kt', '.js', '.ts', '.py', '.cpp', '.c', '.h',
            '.cs', '.php', '.rb', '.go', '.swift', '.m', '.mm'
        }
        
        self.statistics = {
            'total_processed': 0,
            'successful_mappings': 0,
            'metadata_filtered': 0,
            'code_extracted': 0,
            'context_enhanced': 0
        }
    
    def map_vulnerability_locations(self, vulnerabilities: List[Dict[str, Any]], 
                                  source_roots: List[str] = None) -> List[Dict[str, Any]]:
        """
        Map vulnerabilities to actual source code locations with proper context.
        
        Args:
            vulnerabilities: List of vulnerability findings
            source_roots: Optional list of source code root directories
            
        Returns:
            Enhanced vulnerabilities with accurate code locations
        """
        logger.info(f"ðŸŽ¯ Mapping {len(vulnerabilities)} vulnerabilities to source code locations...")
        
        self.statistics['total_processed'] = len(vulnerabilities)
        enhanced_vulnerabilities = []
        
        # Discover source files if roots provided
        source_files = {}
        if source_roots:
            source_files = self._discover_source_files(source_roots)
        
        for vuln in vulnerabilities:
            try:
                enhanced_vuln = self._enhance_vulnerability_location(vuln, source_files)
                enhanced_vulnerabilities.append(enhanced_vuln)
                
                if enhanced_vuln.get('_code_mapping_success'):
                    self.statistics['successful_mappings'] += 1
                
            except Exception as e:
                logger.warning(f"Failed to map location for vulnerability '{vuln.get('title', 'Unknown')}': {e}")
                enhanced_vulnerabilities.append(vuln)
        
        logger.info(f"âœ… Code location mapping complete:")
        logger.info(f"   Successful mappings: {self.statistics['successful_mappings']}")
        logger.info(f"   Metadata filtered: {self.statistics['metadata_filtered']}")
        logger.info(f"   Code extracted: {self.statistics['code_extracted']}")
        
        return enhanced_vulnerabilities
    
    def _discover_source_files(self, source_roots: List[str]) -> Dict[str, str]:
        """Discover source files in the provided root directories."""
        source_files = {}
        
        for root in source_roots:
            root_path = Path(root)
            if root_path.exists():
                for file_path in root_path.rglob('*'):
                    if file_path.is_file() and file_path.suffix in self.supported_extensions:
                        # Use relative path as key for matching
                        relative_path = str(file_path.relative_to(root_path))
                        source_files[relative_path] = str(file_path)
        
        logger.debug(f"Discovered {len(source_files)} source files")
        return source_files
    
    def _enhance_vulnerability_location(self, vuln: Dict[str, Any], 
                                      source_files: Dict[str, str]) -> Dict[str, Any]:
        """Enhance a single vulnerability with accurate location information."""
        
        enhanced_vuln = vuln.copy()
        
        # Check if this vulnerability has location information
        file_path = vuln.get('file_path', '').strip()
        line_number = vuln.get('line_number', 0)
        
        if not file_path:
            # Try to extract from other fields
            file_path = self._extract_file_path_from_content(vuln)
        
        if file_path:
            # Clean and normalize file path
            cleaned_path = self._clean_file_path(file_path)
            enhanced_vuln['file_path'] = cleaned_path
            
            # Try to find actual source file
            actual_source_path = self._find_actual_source_file(cleaned_path, source_files)
            
            if actual_source_path:
                # Extract actual code context
                code_result = self._extract_code_context(actual_source_path, line_number, vuln)
                
                if code_result.success and code_result.locations:
                    best_location = code_result.locations[0]  # Use best match
                    
                    # Update vulnerability with actual code information
                    enhanced_vuln.update({
                        'actual_source_path': actual_source_path,
                        'line_number': best_location.line_number,
                        'column_number': best_location.column_number,
                        'method_name': best_location.method_name,
                        'class_name': best_location.class_name,
                        'matching_code': best_location.actual_code,
                        'context_before': best_location.context_before,
                        'context_after': best_location.context_after,
                        'vulnerability_context': best_location.vulnerability_context,
                        'code_confidence': best_location.confidence_score,
                        '_code_mapping_success': True
                    })
                    
                    self.statistics['code_extracted'] += 1
                    
                    # Remove metadata if present
                    if self._is_metadata_content(enhanced_vuln.get('matching_code', '')):
                        enhanced_vuln['matching_code'] = best_location.actual_code
                        self.statistics['metadata_filtered'] += 1
                
                # Add warnings if any
                if code_result.warnings:
                    enhanced_vuln['_code_mapping_warnings'] = code_result.warnings
            else:
                # Try to clean existing code content
                existing_code = vuln.get('matching_code', '')
                if existing_code and self._is_metadata_content(existing_code):
                    # Try to find actual vulnerable code in the content
                    cleaned_code = self._extract_vulnerable_code_from_metadata(existing_code, vuln)
                    if cleaned_code:
                        enhanced_vuln['matching_code'] = cleaned_code
                        enhanced_vuln['_code_mapping_success'] = True
                        self.statistics['metadata_filtered'] += 1
        
        return enhanced_vuln
    
    def _extract_file_path_from_content(self, vuln: Dict[str, Any]) -> str:
        """Try to extract file path from vulnerability content."""
        
        # Check various fields for file path information
        potential_sources = [
            vuln.get('file_name', ''),
            vuln.get('location', ''),
            vuln.get('evidence', {}).get('file_path', ''),
            vuln.get('raw_data', {}).get('file_path', '')
        ]
        
        for source in potential_sources:
            if source and isinstance(source, str):
                # Look for Java/Kotlin file patterns
                file_match = re.search(r'([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)/([a-zA-Z_][a-zA-Z0-9_]*\.(java|kt|js|py|cpp|c|h|cs|php|rb|go|swift|m))', source)
                if file_match:
                    return file_match.group(0)
                
                # Look for simple filename
                filename_match = re.search(r'([a-zA-Z_][a-zA-Z0-9_]*\.(java|kt|js|py|cpp|c|h|cs|php|rb|go|swift|m))', source)
                if filename_match:
                    return filename_match.group(0)
        
        return ''
    
    def _clean_file_path(self, file_path: str) -> str:
        """Clean and normalize file path."""
        
        # Remove common prefixes and suffixes
        cleaned = file_path.strip()
        
        # Remove protocol prefixes
        cleaned = re.sub(r'^(file://|jar://)', '', cleaned)
        
        # Remove query parameters and fragments
        cleaned = re.sub(r'[?#].*$', '', cleaned)
        
        # Normalize path separators
        cleaned = cleaned.replace('\\', '/')
        
        # Remove duplicate slashes
        cleaned = re.sub(r'/+', '/', cleaned)
        
        return cleaned
    
    def _find_actual_source_file(self, file_path: str, source_files: Dict[str, str]) -> Optional[str]:
        """Find the actual source file corresponding to the file path."""
        
        if not source_files:
            return None
        
        # Try exact match first
        if file_path in source_files:
            return source_files[file_path]
        
        # Try filename-only match
        filename = Path(file_path).name
        for relative_path, full_path in source_files.items():
            if Path(relative_path).name == filename:
                return full_path
        
        # Try partial path match
        path_parts = Path(file_path).parts
        if len(path_parts) > 1:
            for relative_path, full_path in source_files.items():
                rel_parts = Path(relative_path).parts
                # Check if the last few parts match
                if len(rel_parts) >= len(path_parts):
                    if rel_parts[-len(path_parts):] == path_parts:
                        return full_path
        
        return None
    
    def _extract_code_context(self, file_path: str, target_line: int, 
                             vuln: Dict[str, Any]) -> CodeExtractionResult:
        """Extract actual code context from source file."""
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            # If no specific line, try to find vulnerable code
            if target_line <= 0:
                target_line = self._find_vulnerable_line(lines, vuln)
            
            if target_line <= 0 or target_line > len(lines):
                return CodeExtractionResult(
                    success=False,
                    locations=[],
                    errors=[f"Invalid line number {target_line} for file with {len(lines)} lines"],
                    warnings=[],
                    metadata={}
                )
            
            # Extract context around the target line
            context_size = 5
            start_line = max(0, target_line - context_size - 1)
            end_line = min(len(lines), target_line + context_size)
            
            # Get the actual code line
            actual_code = lines[target_line - 1].strip()
            
            # Filter out metadata lines
            if self._is_metadata_content(actual_code):
                # Try to find nearby non-metadata code
                for offset in range(1, context_size + 1):
                    # Check lines after
                    if target_line + offset <= len(lines):
                        candidate = lines[target_line + offset - 1].strip()
                        if not self._is_metadata_content(candidate) and candidate:
                            actual_code = candidate
                            target_line = target_line + offset
                            break
                    
                    # Check lines before
                    if target_line - offset > 0:
                        candidate = lines[target_line - offset - 1].strip()
                        if not self._is_metadata_content(candidate) and candidate:
                            actual_code = candidate
                            target_line = target_line - offset
                            break
            
            # Get context lines, filtering metadata
            context_before = []
            context_after = []
            
            for i in range(start_line, target_line - 1):
                line = lines[i].strip()
                if line and not self._is_metadata_content(line):
                    context_before.append(line)
            
            for i in range(target_line, end_line):
                line = lines[i].strip()
                if line and not self._is_metadata_content(line):
                    context_after.append(line)
            
            # Analyze the code for method and class context
            method_name = self._extract_method_name(lines, target_line)
            class_name = self._extract_class_name(lines, target_line)
            
            # Generate vulnerability-specific context
            vuln_context = self._generate_vulnerability_context(actual_code, vuln)
            
            # Calculate confidence based on code quality
            confidence = self._calculate_code_confidence(actual_code, vuln)
            
            location = CodeLocation(
                file_path=file_path,
                line_number=target_line,
                column_number=None,  # Could be enhanced with AST parsing
                method_name=method_name,
                class_name=class_name,
                actual_code=actual_code,
                context_before=context_before[-3:],  # Keep last 3 lines
                context_after=context_after[:3],     # Keep first 3 lines
                vulnerability_context=vuln_context,
                confidence_score=confidence
            )
            
            return CodeExtractionResult(
                success=True,
                locations=[location],
                errors=[],
                warnings=[],
                metadata={'total_lines': len(lines), 'context_size': context_size}
            )
            
        except Exception as e:
            return CodeExtractionResult(
                success=False,
                locations=[],
                errors=[f"Failed to read file {file_path}: {e}"],
                warnings=[],
                metadata={}
            )
    
    def _find_vulnerable_line(self, lines: List[str], vuln: Dict[str, Any]) -> int:
        """Find the line containing the actual vulnerable code."""
        
        vuln_type = vuln.get('vulnerability_type', '').lower()
        title = vuln.get('title', '').lower()
        description = vuln.get('description', '').lower()
        
        # Determine vulnerability type
        detected_type = None
        for vtype, patterns in self.vulnerable_code_patterns.items():
            if vtype in vuln_type or vtype in title or vtype in description:
                detected_type = vtype
                break
        
        if not detected_type:
            # Try to infer from content
            content = f"{title} {description}".lower()
            if any(word in content for word in ['sql', 'injection', 'query']):
                detected_type = 'sql_injection'
            elif any(word in content for word in ['hardcoded', 'secret', 'key', 'password']):
                detected_type = 'hardcoded_secret'
            elif any(word in content for word in ['cleartext', 'http', 'insecure']):
                detected_type = 'cleartext_communication'
            elif any(word in content for word in ['storage', 'file', 'preferences']):
                detected_type = 'insecure_storage'
            elif any(word in content for word in ['debug', 'log']):
                detected_type = 'debug_enabled'
        
        if detected_type and detected_type in self.vulnerable_code_patterns:
            patterns = self.vulnerable_code_patterns[detected_type]
            
            for i, line in enumerate(lines, 1):
                line_content = line.strip()
                if not self._is_metadata_content(line_content):
                    for pattern in patterns:
                        if re.search(pattern, line_content, re.IGNORECASE):
                            return i
        
        # Fallback: find first non-metadata line with actual code
        for i, line in enumerate(lines, 1):
            line_content = line.strip()
            if (line_content and 
                not self._is_metadata_content(line_content) and
                not line_content.startswith('//') and
                not line_content.startswith('#') and
                len(line_content) > 10):  # Some meaningful content
                return i
        
        return 0
    
    def _is_metadata_content(self, content: str) -> bool:
        """Check if content is compiler metadata rather than actual code."""
        
        if not content or not content.strip():
            return True
        
        content_stripped = content.strip()
        
        for pattern in self.metadata_patterns:
            if re.search(pattern, content_stripped, re.IGNORECASE):
                return True
        
        # Additional checks for specific metadata patterns
        if (content_stripped.startswith('/*') and 'compiled from' in content_stripped.lower()):
            return True
        
        if (content_stripped.startswith('@') and content_stripped.endswith(')')):
            return True
        
        if re.match(r'^[a-f0-9\s\\\"\{\}]+$', content_stripped):  # Hex/encoded data
            return True
        
        return False
    
    def _extract_vulnerable_code_from_metadata(self, metadata_content: str, 
                                             vuln: Dict[str, Any]) -> str:
        """Try to extract actual vulnerable code from metadata content."""
        
        # Look for embedded code in comments or strings
        code_patterns = [
            r'//\s*(.+)',  # Single line comments with code
            r'/\*\s*(.+?)\s*\*/',  # Multi-line comments
            r'"([^"]*(?:password|key|secret|token)[^"]*)"',  # Quoted strings with secrets
            r"'([^']*(?:password|key|secret|token)[^']*)'",  # Single quoted strings
        ]
        
        for pattern in code_patterns:
            matches = re.findall(pattern, metadata_content, re.IGNORECASE | re.DOTALL)
            for match in matches:
                if not self._is_metadata_content(match) and len(match.strip()) > 5:
                    return match.strip()
        
        return ''
    
    def _extract_method_name(self, lines: List[str], target_line: int) -> Optional[str]:
        """Extract method name containing the target line."""
        
        # Look backwards for method definition
        for i in range(target_line - 1, max(0, target_line - 20), -1):
            line = lines[i].strip()
            
            # Java/Kotlin method patterns
            method_match = re.search(r'(?:public|private|protected|static)?\s*(?:static)?\s*\w+\s+(\w+)\s*\(', line)
            if method_match:
                return method_match.group(1)
            
            # Function patterns for other languages
            func_match = re.search(r'(?:def|function|func)\s+(\w+)', line)
            if func_match:
                return func_match.group(1)
        
        return None
    
    def _extract_class_name(self, lines: List[str], target_line: int) -> Optional[str]:
        """Extract class name containing the target line."""
        
        # Look backwards for class definition
        for i in range(target_line - 1, max(0, target_line - 50), -1):
            line = lines[i].strip()
            
            # Java/Kotlin class patterns
            class_match = re.search(r'(?:public|private|protected)?\s*(?:static)?\s*(?:class|interface|object)\s+(\w+)', line)
            if class_match:
                return class_match.group(1)
        
        return None
    
    def _generate_vulnerability_context(self, code: str, vuln: Dict[str, Any]) -> str:
        """Generate vulnerability-specific context explanation."""
        
        vuln_type = vuln.get('vulnerability_type', '').lower()
        
        if 'injection' in vuln_type:
            return f"SQL injection vulnerability in code: {code[:50]}..."
        elif 'hardcoded' in vuln_type:
            return f"Hardcoded secret detected in: {code[:50]}..."
        elif 'cleartext' in vuln_type:
            return f"Cleartext communication in: {code[:50]}..."
        elif 'storage' in vuln_type:
            return f"Insecure storage usage: {code[:50]}..."
        elif 'debug' in vuln_type:
            return f"Debug functionality enabled: {code[:50]}..."
        else:
            return f"Security vulnerability in: {code[:50]}..."
    
    def _calculate_code_confidence(self, code: str, vuln: Dict[str, Any]) -> float:
        """Calculate confidence that this is the actual vulnerable code."""
        
        confidence = 0.5  # Base confidence
        
        # Higher confidence if code contains vulnerability-related keywords
        vuln_keywords = ['password', 'key', 'secret', 'token', 'execute', 'query', 'http', 'debug', 'log']
        for keyword in vuln_keywords:
            if keyword.lower() in code.lower():
                confidence += 0.1
        
        # Higher confidence if it's not metadata
        if not self._is_metadata_content(code):
            confidence += 0.2
        
        # Higher confidence if it has meaningful code constructs
        if re.search(r'[=\(\)\{\};]', code):  # Contains code punctuation
            confidence += 0.1
        
        # Lower confidence if too short or generic
        if len(code.strip()) < 10:
            confidence -= 0.2
        
        return min(1.0, max(0.1, confidence))

def enhance_vulnerabilities_with_code_mapping(vulnerabilities: List[Dict[str, Any]], 
                                            source_roots: List[str] = None) -> List[Dict[str, Any]]:
    """Convenience function for enhancing vulnerabilities with smart code mapping."""
    mapper = SmartCodeLocationMapper()
    return mapper.map_vulnerability_locations(vulnerabilities, source_roots) 