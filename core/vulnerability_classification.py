#!/usr/bin/env python3
"""
Vulnerability Source Classification

Provides accurate classification of vulnerability sources to distinguish between
runtime dynamic analysis, static analysis, and configuration analysis.

Author: AODS Team
Date: January 2025
"""

import logging
import time
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import json
import hashlib


class VulnerabilitySource(Enum):
    """Accurate vulnerability source classifications."""
    RUNTIME_DYNAMIC_ANALYSIS = "runtime_dynamic_analysis"
    STATIC_ANALYSIS = "static_analysis"
    CONFIGURATION_ANALYSIS = "configuration_analysis"
    HYBRID_ANALYSIS = "hybrid_analysis"
    UNKNOWN_SOURCE = "unknown_source"


class DetectionMethod(Enum):
    """Detection methods for vulnerabilities."""
    FRIDA_RUNTIME_INSTRUMENTATION = "frida_runtime_instrumentation"
    FRIDA_STATIC_HOOKS = "frida_static_hooks"
    JADX_STATIC_ANALYSIS = "jadx_static_analysis"
    MANIFEST_ANALYSIS = "manifest_analysis"
    APK_STRUCTURE_ANALYSIS = "apk_structure_analysis"
    CONFIGURATION_REVIEW = "configuration_review"
    HYBRID_STATIC_DYNAMIC = "hybrid_static_dynamic"
    UNKNOWN_METHOD = "unknown_method"


class AnalysisPhase(Enum):
    """Analysis phases where vulnerabilities are detected."""
    RUNTIME_MONITORING = "runtime_monitoring"
    STATIC_CODE_ANALYSIS = "static_code_analysis"
    MANIFEST_INSPECTION = "manifest_inspection"
    CONFIGURATION_REVIEW = "configuration_review"
    HYBRID_CORRELATION = "hybrid_correlation"
    UNKNOWN_PHASE = "unknown_phase"


class EvidenceType(Enum):
    """Types of evidence supporting vulnerability detection."""
    RUNTIME_HOOK_DATA = "runtime_hook_data"
    CALL_STACK_TRACE = "call_stack_trace"
    STATIC_CODE_PATTERN = "static_code_pattern"
    MANIFEST_DECLARATION = "manifest_declaration"
    CONFIGURATION_SETTING = "configuration_setting"
    HYBRID_CORRELATION = "hybrid_correlation"
    NO_EVIDENCE = "no_evidence"


@dataclass
class VulnerabilityClassification:
    """Complete vulnerability classification result."""
    source: VulnerabilitySource
    detection_method: DetectionMethod
    analysis_phase: AnalysisPhase
    evidence_type: EvidenceType
    confidence_score: float
    runtime_evidence: Optional[Dict[str, Any]] = None
    classification_metadata: Dict[str, Any] = field(default_factory=dict)
    classification_timestamp: float = field(default_factory=time.time)


@dataclass
class RuntimeEvidence:
    """Runtime evidence for vulnerability detection."""
    hook_timestamp: float
    hook_name: str
    stack_trace: List[str]
    execution_context: Dict[str, Any]
    runtime_parameters: Dict[str, Any]
    frida_session_id: Optional[str] = None
    evidence_hash: str = field(default="")
    
    def __post_init__(self):
        """Calculate evidence hash for integrity."""
        if not self.evidence_hash:
            evidence_data = {
                'hook_timestamp': self.hook_timestamp,
                'hook_name': self.hook_name,
                'stack_trace': self.stack_trace,
                'execution_context': self.execution_context,
                'runtime_parameters': self.runtime_parameters
            }
            evidence_str = json.dumps(evidence_data, sort_keys=True, default=str)
            self.evidence_hash = hashlib.sha256(evidence_str.encode()).hexdigest()[:16]


class VulnerabilitySourceClassifier:
    """
    Accurate classification of vulnerability sources to distinguish between
    runtime dynamic analysis, static analysis, and configuration analysis.
    """
    
    def __init__(self):
        """Initialize vulnerability source classifier."""
        self.logger = logging.getLogger(__name__)
        
        # Runtime evidence indicators
        self.runtime_indicators = {
            'required_fields': ['hook_timestamp', 'stack_trace', 'runtime_context'],
            'runtime_plugins': ['frida_dynamic_analysis', 'runtime_hooks'],
            'runtime_keywords': ['hook', 'frida', 'runtime', 'instrumentation', 'execution'],
            'runtime_evidence_types': ['call_stack', 'hook_data', 'execution_trace']
        }
        
        # Static analysis indicators
        self.static_indicators = {
            'static_plugins': ['jadx_static_analysis', 'static_analysis'],
            'static_keywords': ['decompiled', 'static', 'source_code', 'bytecode'],
            'static_evidence_types': ['code_pattern', 'method_signature', 'class_analysis']
        }
        
        # Configuration analysis indicators
        self.config_indicators = {
            'config_plugins': ['manifest_analysis', 'configuration_analysis'],
            'config_keywords': ['manifest', 'permissions', 'intent_filter', 'configuration'],
            'config_evidence_types': ['manifest_entry', 'permission_declaration', 'configuration_setting']
        }
        
        self.logger.info("🔍 VulnerabilitySourceClassifier initialized")
    
    def classify_vulnerability_source(self, vulnerability: Union[Dict[str, Any], Any]) -> VulnerabilityClassification:
        """
        Accurately classify vulnerability source.
        
        Args:
            vulnerability: Vulnerability object or dictionary
            
        Returns:
            VulnerabilityClassification with accurate source classification
        """
        try:
            # Convert to dictionary if needed
            vuln_data = self._normalize_vulnerability_data(vulnerability)
            
            # Perform multi-level classification
            runtime_classification = self._classify_runtime_source(vuln_data)
            static_classification = self._classify_static_source(vuln_data)
            config_classification = self._classify_config_source(vuln_data)
            
            # Determine final classification based on evidence strength
            final_classification = self._determine_final_classification(
                runtime_classification,
                static_classification,
                config_classification,
                vuln_data
            )
            
            # Add classification metadata
            final_classification.classification_metadata = {
                'classifier_version': '1.0',
                'classification_algorithm': 'multi_level_evidence_analysis',
                'runtime_score': runtime_classification.confidence_score,
                'static_score': static_classification.confidence_score,
                'config_score': config_classification.confidence_score,
                'vulnerability_id': vuln_data.get('id', 'unknown'),
                'plugin_source': vuln_data.get('plugin_name', 'unknown')
            }
            
            self.logger.debug(f"🔍 Classified vulnerability: {final_classification.source.value} "
                            f"(confidence: {final_classification.confidence_score:.2f})")
            
            return final_classification
            
        except Exception as e:
            self.logger.error(f"❌ Classification failed: {e}")
            return VulnerabilityClassification(
                source=VulnerabilitySource.UNKNOWN_SOURCE,
                detection_method=DetectionMethod.UNKNOWN_METHOD,
                analysis_phase=AnalysisPhase.UNKNOWN_PHASE,
                evidence_type=EvidenceType.NO_EVIDENCE,
                confidence_score=0.0,
                classification_metadata={'error': str(e)}
            )
    
    def _normalize_vulnerability_data(self, vulnerability: Union[Dict[str, Any], Any]) -> Dict[str, Any]:
        """Normalize vulnerability data to dictionary format."""
        if isinstance(vulnerability, dict):
            return vulnerability
        elif hasattr(vulnerability, 'to_dict'):
            return vulnerability.to_dict()
        elif hasattr(vulnerability, '__dict__'):
            return vulnerability.__dict__
        else:
            # Try to extract common attributes
            vuln_data = {}
            for attr in ['title', 'description', 'severity', 'confidence', 'source', 'plugin_name']:
                if hasattr(vulnerability, attr):
                    vuln_data[attr] = getattr(vulnerability, attr)
            return vuln_data
    
    def _classify_runtime_source(self, vuln_data: Dict[str, Any]) -> VulnerabilityClassification:
        """Classify as runtime dynamic analysis source."""
        confidence_score = 0.0
        runtime_evidence = None
        detection_method = DetectionMethod.UNKNOWN_METHOD
        evidence_type = EvidenceType.NO_EVIDENCE
        
        # Check for runtime evidence
        if self._has_runtime_evidence(vuln_data):
            confidence_score += 0.4
            runtime_evidence = self._extract_runtime_evidence(vuln_data)
            evidence_type = EvidenceType.RUNTIME_HOOK_DATA
            
        # Check for runtime context
        if self._has_runtime_context(vuln_data):
            confidence_score += 0.3
            if evidence_type == EvidenceType.NO_EVIDENCE:
                evidence_type = EvidenceType.CALL_STACK_TRACE
        
        # Check for Frida indicators
        if self._has_frida_indicators(vuln_data):
            confidence_score += 0.2
            detection_method = DetectionMethod.FRIDA_RUNTIME_INSTRUMENTATION
        
        # Check for runtime plugin source
        if self._from_runtime_plugin(vuln_data):
            confidence_score += 0.1
        
        return VulnerabilityClassification(
            source=VulnerabilitySource.RUNTIME_DYNAMIC_ANALYSIS,
            detection_method=detection_method,
            analysis_phase=AnalysisPhase.RUNTIME_MONITORING,
            evidence_type=evidence_type,
            confidence_score=min(confidence_score, 1.0),
            runtime_evidence=runtime_evidence
        )
    
    def _classify_static_source(self, vuln_data: Dict[str, Any]) -> VulnerabilityClassification:
        """Classify as static analysis source."""
        confidence_score = 0.0
        detection_method = DetectionMethod.UNKNOWN_METHOD
        evidence_type = EvidenceType.NO_EVIDENCE
        
        # Check for static analysis indicators
        if self._has_static_indicators(vuln_data):
            confidence_score += 0.4
            evidence_type = EvidenceType.STATIC_CODE_PATTERN
        
        # Check for decompiled code evidence
        if self._has_decompiled_evidence(vuln_data):
            confidence_score += 0.3
            detection_method = DetectionMethod.JADX_STATIC_ANALYSIS
        
        # Check for static plugin source
        if self._from_static_plugin(vuln_data):
            confidence_score += 0.2
        
        # Check for code pattern evidence
        if self._has_code_pattern_evidence(vuln_data):
            confidence_score += 0.1
            if evidence_type == EvidenceType.NO_EVIDENCE:
                evidence_type = EvidenceType.STATIC_CODE_PATTERN
        
        return VulnerabilityClassification(
            source=VulnerabilitySource.STATIC_ANALYSIS,
            detection_method=detection_method,
            analysis_phase=AnalysisPhase.STATIC_CODE_ANALYSIS,
            evidence_type=evidence_type,
            confidence_score=min(confidence_score, 1.0)
        )
    
    def _classify_config_source(self, vuln_data: Dict[str, Any]) -> VulnerabilityClassification:
        """Classify as configuration analysis source."""
        confidence_score = 0.0
        detection_method = DetectionMethod.UNKNOWN_METHOD
        evidence_type = EvidenceType.NO_EVIDENCE
        
        # Check for manifest indicators
        if self._has_manifest_indicators(vuln_data):
            confidence_score += 0.4
            evidence_type = EvidenceType.MANIFEST_DECLARATION
            detection_method = DetectionMethod.MANIFEST_ANALYSIS
        
        # Check for configuration indicators
        if self._has_config_indicators(vuln_data):
            confidence_score += 0.3
            if evidence_type == EvidenceType.NO_EVIDENCE:
                evidence_type = EvidenceType.CONFIGURATION_SETTING
        
        # Check for permission-related evidence
        if self._has_permission_evidence(vuln_data):
            confidence_score += 0.2
        
        # Check for APK structure evidence
        if self._has_apk_structure_evidence(vuln_data):
            confidence_score += 0.1
            if detection_method == DetectionMethod.UNKNOWN_METHOD:
                detection_method = DetectionMethod.APK_STRUCTURE_ANALYSIS
        
        return VulnerabilityClassification(
            source=VulnerabilitySource.CONFIGURATION_ANALYSIS,
            detection_method=detection_method,
            analysis_phase=AnalysisPhase.CONFIGURATION_REVIEW,
            evidence_type=evidence_type,
            confidence_score=min(confidence_score, 1.0)
        )
    
    def _determine_final_classification(self, runtime_class: VulnerabilityClassification,
                                      static_class: VulnerabilityClassification,
                                      config_class: VulnerabilityClassification,
                                      vuln_data: Dict[str, Any]) -> VulnerabilityClassification:
        """Determine final classification based on evidence strength."""
        
        classifications = [
            (runtime_class, 'runtime'),
            (static_class, 'static'),
            (config_class, 'config')
        ]
        
        # Sort by confidence score
        classifications.sort(key=lambda x: x[0].confidence_score, reverse=True)
        
        best_classification = classifications[0][0]
        best_type = classifications[0][1]
        
        # If confidence is too low, mark as unknown
        if best_classification.confidence_score < 0.3:
            return VulnerabilityClassification(
                source=VulnerabilitySource.UNKNOWN_SOURCE,
                detection_method=DetectionMethod.UNKNOWN_METHOD,
                analysis_phase=AnalysisPhase.UNKNOWN_PHASE,
                evidence_type=EvidenceType.NO_EVIDENCE,
                confidence_score=0.0
            )
        
        # Check for hybrid scenarios
        if (classifications[0][0].confidence_score > 0.5 and 
            classifications[1][0].confidence_score > 0.3):
            # Potential hybrid analysis
            return VulnerabilityClassification(
                source=VulnerabilitySource.HYBRID_ANALYSIS,
                detection_method=DetectionMethod.HYBRID_STATIC_DYNAMIC,
                analysis_phase=AnalysisPhase.HYBRID_CORRELATION,
                evidence_type=EvidenceType.HYBRID_CORRELATION,
                confidence_score=(classifications[0][0].confidence_score + 
                                classifications[1][0].confidence_score) / 2,
                runtime_evidence=runtime_class.runtime_evidence
            )
        
        return best_classification
    
    def _has_runtime_evidence(self, vuln_data: Dict[str, Any]) -> bool:
        """Check if vulnerability has runtime evidence."""
        return (
            vuln_data.get('runtime_context') is not None or
            vuln_data.get('hook_timestamp') is not None or
            vuln_data.get('stack_trace') is not None or
            vuln_data.get('execution_context') is not None or
            vuln_data.get('frida_session_id') is not None
        )
    
    def _has_runtime_context(self, vuln_data: Dict[str, Any]) -> bool:
        """Check if vulnerability has runtime execution context."""
        runtime_context = vuln_data.get('runtime_context', {})
        if isinstance(runtime_context, dict):
            return (
                'hook_timestamp' in runtime_context or
                'stack_trace' in runtime_context or
                'execution_context' in runtime_context or
                'runtime_parameters' in runtime_context
            )
        return False
    
    def _has_frida_indicators(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for Frida-specific indicators."""
        text_content = str(vuln_data).lower()
        return any(keyword in text_content for keyword in self.runtime_indicators['runtime_keywords'])
    
    def _from_runtime_plugin(self, vuln_data: Dict[str, Any]) -> bool:
        """Check if vulnerability originates from runtime plugin."""
        plugin_name = vuln_data.get('plugin_name', '').lower()
        source = vuln_data.get('source', '').lower()
        
        return (
            any(plugin in plugin_name for plugin in self.runtime_indicators['runtime_plugins']) or
            any(plugin in source for plugin in self.runtime_indicators['runtime_plugins'])
        )
    
    def _has_static_indicators(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for static analysis indicators."""
        text_content = str(vuln_data).lower()
        return any(keyword in text_content for keyword in self.static_indicators['static_keywords'])
    
    def _has_decompiled_evidence(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for decompiled code evidence."""
        text_content = str(vuln_data).lower()
        return 'decompiled' in text_content or 'jadx' in text_content
    
    def _from_static_plugin(self, vuln_data: Dict[str, Any]) -> bool:
        """Check if vulnerability originates from static plugin."""
        plugin_name = vuln_data.get('plugin_name', '').lower()
        source = vuln_data.get('source', '').lower()
        
        return (
            any(plugin in plugin_name for plugin in self.static_indicators['static_plugins']) or
            any(plugin in source for plugin in self.static_indicators['static_plugins'])
        )
    
    def _has_code_pattern_evidence(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for code pattern evidence."""
        return (
            vuln_data.get('code_location') is not None or
            vuln_data.get('method_signature') is not None or
            vuln_data.get('class_name') is not None
        )
    
    def _has_manifest_indicators(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for manifest-related indicators."""
        text_content = str(vuln_data).lower()
        return any(keyword in text_content for keyword in self.config_indicators['config_keywords'])
    
    def _has_config_indicators(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for configuration analysis indicators."""
        return (
            vuln_data.get('manifest_entry') is not None or
            vuln_data.get('permission') is not None or
            vuln_data.get('intent_filter') is not None
        )
    
    def _has_permission_evidence(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for permission-related evidence."""
        text_content = str(vuln_data).lower()
        return 'permission' in text_content or 'uses-permission' in text_content
    
    def _has_apk_structure_evidence(self, vuln_data: Dict[str, Any]) -> bool:
        """Check for APK structure evidence."""
        return (
            vuln_data.get('file_path') is not None or
            vuln_data.get('apk_component') is not None
        )
    
    def _extract_runtime_evidence(self, vuln_data: Dict[str, Any]) -> Optional[RuntimeEvidence]:
        """Extract runtime evidence from vulnerability data."""
        try:
            runtime_context = vuln_data.get('runtime_context', {})
            
            if not runtime_context and not any(key in vuln_data for key in ['hook_timestamp', 'stack_trace']):
                return None
            
            return RuntimeEvidence(
                hook_timestamp=vuln_data.get('hook_timestamp', runtime_context.get('timestamp', time.time())),
                hook_name=vuln_data.get('hook_name', runtime_context.get('hook_name', 'unknown_hook')),
                stack_trace=vuln_data.get('stack_trace', runtime_context.get('stack_trace', [])),
                execution_context=vuln_data.get('execution_context', runtime_context.get('context', {})),
                runtime_parameters=vuln_data.get('runtime_parameters', runtime_context.get('parameters', {})),
                frida_session_id=vuln_data.get('frida_session_id', runtime_context.get('session_id'))
            )
            
        except Exception as e:
            self.logger.debug(f"Failed to extract runtime evidence: {e}")
            return None
    
    def is_runtime_detected(self, vulnerability: Union[Dict[str, Any], Any]) -> bool:
        """Check if vulnerability was detected during runtime (legacy compatibility)."""
        classification = self.classify_vulnerability_source(vulnerability)
        return classification.source == VulnerabilitySource.RUNTIME_DYNAMIC_ANALYSIS
    
    def is_static_analysis(self, vulnerability: Union[Dict[str, Any], Any]) -> bool:
        """Check if vulnerability was detected via static analysis."""
        classification = self.classify_vulnerability_source(vulnerability)
        return classification.source == VulnerabilitySource.STATIC_ANALYSIS
    
    def is_configuration_analysis(self, vulnerability: Union[Dict[str, Any], Any]) -> bool:
        """Check if vulnerability was detected via configuration analysis."""
        classification = self.classify_vulnerability_source(vulnerability)
        return classification.source == VulnerabilitySource.CONFIGURATION_ANALYSIS
    
    def get_classification_summary(self, vulnerabilities: List[Union[Dict[str, Any], Any]]) -> Dict[str, Any]:
        """Get classification summary for a list of vulnerabilities."""
        classifications = []
        
        for vuln in vulnerabilities:
            classification = self.classify_vulnerability_source(vuln)
            classifications.append(classification)
        
        # Generate summary statistics
        source_counts = {}
        method_counts = {}
        total_confidence = 0.0
        
        for classification in classifications:
            source = classification.source.value
            method = classification.detection_method.value
            
            source_counts[source] = source_counts.get(source, 0) + 1
            method_counts[method] = method_counts.get(method, 0) + 1
            total_confidence += classification.confidence_score
        
        return {
            'total_vulnerabilities': len(vulnerabilities),
            'source_distribution': source_counts,
            'method_distribution': method_counts,
            'average_confidence': total_confidence / max(1, len(vulnerabilities)),
            'runtime_count': source_counts.get(VulnerabilitySource.RUNTIME_DYNAMIC_ANALYSIS.value, 0),
            'static_count': source_counts.get(VulnerabilitySource.STATIC_ANALYSIS.value, 0),
            'config_count': source_counts.get(VulnerabilitySource.CONFIGURATION_ANALYSIS.value, 0),
            'unknown_count': source_counts.get(VulnerabilitySource.UNKNOWN_SOURCE.value, 0),
            'hybrid_count': source_counts.get(VulnerabilitySource.HYBRID_ANALYSIS.value, 0)
        }


# Convenience functions
def classify_vulnerability(vulnerability: Union[Dict[str, Any], Any]) -> VulnerabilityClassification:
    """Classify a single vulnerability source."""
    classifier = VulnerabilitySourceClassifier()
    return classifier.classify_vulnerability_source(vulnerability)


def is_runtime_vulnerability(vulnerability: Union[Dict[str, Any], Any]) -> bool:
    """Check if vulnerability is from runtime dynamic analysis."""
    classification = classify_vulnerability(vulnerability)
    return classification.source == VulnerabilitySource.RUNTIME_DYNAMIC_ANALYSIS


def get_vulnerability_source_label(vulnerability: Union[Dict[str, Any], Any]) -> str:
    """Get accurate source label for vulnerability."""
    classification = classify_vulnerability(vulnerability)
    return classification.source.value


if __name__ == "__main__":
    # Demo usage
    print("🔍 Vulnerability Source Classification Demo")
    print("=" * 45)
    
    # Create classifier
    classifier = VulnerabilitySourceClassifier()
    
    print("✅ VulnerabilitySourceClassifier initialized")
    print("🎯 Source Types:")
    sources = list(VulnerabilitySource)
    for source in sources:
        print(f"   • {source.value}")
    
    print("\n🔧 Detection Methods:")
    methods = list(DetectionMethod)
    for method in methods:
        print(f"   • {method.value}")
    
    print("\n✅ Classifier ready for accurate source classification!")