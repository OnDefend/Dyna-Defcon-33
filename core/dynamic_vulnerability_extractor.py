#!/usr/bin/env python3
"""
Dynamic Vulnerability Extractor
==============================

Extracts structured vulnerabilities from dynamic plugin outputs, applying the same 
quality standards and data enrichment as static analysis.

This module addresses the core issue where dynamic analysis produces rich plugin
outputs but only extracts generic text entries rather than structured vulnerabilities.
"""

import re
import json
import logging
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime

from core.shared_data_structures.base_vulnerability import (
    BaseVulnerability, VulnerabilitySeverity, VulnerabilityType
)


class PluginOutputParser:
    """Parses plugin text outputs to extract structured vulnerability data."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Pattern mappings for extracting CWE IDs from plugin outputs
        self.cwe_patterns = {
            'sql_injection': 'CWE-89',
            'xss': 'CWE-79',
            'injection': 'CWE-94',
            'insecure_storage': 'CWE-200',
            'weak_crypto': 'CWE-327',
            'hardcoded_secret': 'CWE-798',
            'insecure_logging': 'CWE-532',
            'path_traversal': 'CWE-22',
            'command_injection': 'CWE-78',
            'exported_component': 'CWE-200',
            'debuggable': 'CWE-489',
            'root_detection': 'CWE-693',
            'emulator_detection': 'CWE-693',
            'network_cleartext': 'CWE-319',
            'certificate_pinning': 'CWE-295',
            'intent_scheme': 'CWE-200',
            'webview_security': 'CWE-79'
        }
        
        # MASVS control mappings
        self.masvs_mappings = {
            'CWE-89': 'MASVS-CODE-1',    # Code Quality
            'CWE-79': 'MASVS-CODE-1',    # Code Quality  
            'CWE-94': 'MASVS-CODE-1',    # Code Quality
            'CWE-200': 'MASVS-STORAGE-1', # Data Storage
            'CWE-327': 'MASVS-CRYPTO-1', # Cryptography
            'CWE-798': 'MASVS-CODE-1',   # Code Quality
            'CWE-532': 'MASVS-PRIVACY-1', # Privacy
            'CWE-22': 'MASVS-CODE-1',    # Code Quality
            'CWE-78': 'MASVS-CODE-1',    # Code Quality
            'CWE-489': 'MASVS-RESILIENCE-1', # Resilience
            'CWE-693': 'MASVS-RESILIENCE-1', # Resilience
            'CWE-319': 'MASVS-NETWORK-1', # Network Communication
            'CWE-295': 'MASVS-NETWORK-1', # Network Communication
        }
        
        # Severity extraction patterns
        self.severity_patterns = [
            (r'HIGH:|High:|high risk|high severity', VulnerabilitySeverity.HIGH),
            (r'MEDIUM:|Medium:|medium risk|medium severity', VulnerabilitySeverity.MEDIUM),
            (r'LOW:|Low:|low risk|low severity', VulnerabilitySeverity.LOW),
            (r'CRITICAL:|Critical:|critical risk|critical severity', VulnerabilitySeverity.CRITICAL)
        ]
    
    def extract_vulnerabilities_from_plugin_output(
        self, 
        plugin_name: str, 
        plugin_title: str, 
        plugin_output: str,
        apk_context = None
    ) -> List[BaseVulnerability]:
        """Extract structured vulnerabilities from plugin text output."""
        
        vulnerabilities = []
        
        try:
            # Skip non-vulnerability plugins
            if self._is_non_vulnerability_plugin(plugin_name, plugin_output):
                return []
            
            # Try to extract structured vulnerabilities first
            structured_vulns = self._extract_structured_vulnerabilities(
                plugin_name, plugin_title, plugin_output, apk_context
            )
            
            if structured_vulns:
                vulnerabilities.extend(structured_vulns)
            else:
                # Fallback: Create a single vulnerability from plugin output
                fallback_vuln = self._create_fallback_vulnerability(
                    plugin_name, plugin_title, plugin_output, apk_context
                )
                if fallback_vuln:
                    vulnerabilities.append(fallback_vuln)
        
        except Exception as e:
            self.logger.error(f"Failed to extract vulnerabilities from {plugin_name}: {e}")
        
        return vulnerabilities
    
    def _is_non_vulnerability_plugin(self, plugin_name: str, output: str) -> bool:
        """Check if plugin output represents non-vulnerability information."""
        
        non_vuln_indicators = [
            "No vulnerabilities found",
            "Analysis completed successfully",
            "No issues detected",
            "Secure configuration",
            "No security concerns",
            "Total Findings: 0",
            "Total vulnerabilities: 0"
        ]
        
        output_lower = output.lower()
        return any(indicator.lower() in output_lower for indicator in non_vuln_indicators)
    
    def _extract_structured_vulnerabilities(
        self, 
        plugin_name: str, 
        plugin_title: str, 
        plugin_output: str,
        apk_context = None
    ) -> List[BaseVulnerability]:
        """Extract multiple structured vulnerabilities from plugin output."""
        
        vulnerabilities = []
        
        # Look for vulnerability sections in the output
        vulnerability_sections = self._parse_vulnerability_sections(plugin_output)
        
        for section in vulnerability_sections:
            vuln = self._create_vulnerability_from_section(
                plugin_name, plugin_title, section, apk_context
            )
            if vuln:
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _parse_vulnerability_sections(self, output: str) -> List[Dict[str, str]]:
        """Parse plugin output to find individual vulnerability sections."""
        
        sections = []
        
        # Pattern 1: Look for severity-prefixed findings
        severity_pattern = r'(HIGH|MEDIUM|LOW|CRITICAL):\s*([^\n]+(?:\n(?!\s*(?:HIGH|MEDIUM|LOW|CRITICAL):)[^\n]*)*)'
        severity_matches = re.finditer(severity_pattern, output, re.MULTILINE | re.IGNORECASE)
        
        for match in severity_matches:
            sections.append({
                'severity': match.group(1),
                'content': match.group(2).strip(),
                'type': 'severity_based'
            })
        
        # Pattern 2: Look for numbered vulnerability entries
        numbered_pattern = r'(\d+\.\s*[^\n]+(?:\n(?!\s*\d+\.)[^\n]*)*)'
        numbered_matches = re.finditer(numbered_pattern, output, re.MULTILINE)
        
        for match in numbered_matches:
            content = match.group(1).strip()
            if any(vuln_word in content.lower() for vuln_word in ['vulnerability', 'insecure', 'weakness', 'risk', 'issue']):
                sections.append({
                    'content': content,
                    'type': 'numbered'
                })
        
        # Pattern 3: Look for vulnerability summary blocks
        summary_pattern = r'VULNERABILITY SUMMARY[^\n]*\n(.*?)(?=\n\n|\Z)'
        summary_matches = re.finditer(summary_pattern, output, re.MULTILINE | re.DOTALL | re.IGNORECASE)
        
        for match in summary_matches:
            sections.append({
                'content': match.group(1).strip(),
                'type': 'summary_block'
            })
        
        return sections
    
    def _create_vulnerability_from_section(
        self, 
        plugin_name: str, 
        plugin_title: str, 
        section: Dict[str, str],
        apk_context = None
    ) -> Optional[BaseVulnerability]:
        """Create a BaseVulnerability from a parsed section."""
        
        content = section['content']
        
        # Extract title
        title = self._extract_title_from_content(content, plugin_title)
        
        # Extract severity
        severity = self._extract_severity_from_content(content, section.get('severity'))
        
        # Extract CWE and MASVS
        cwe_id = self._extract_cwe_from_content(content, plugin_name)
        masvs_control = self.masvs_mappings.get(cwe_id, 'MASVS-GENERAL')
        
        # Extract file path and line number if available
        file_path, line_number = self._extract_location_from_content(content, apk_context)
        
        # Extract code snippet/evidence
        evidence = self._extract_evidence_from_content(content)
        
        # Generate description
        description = self._generate_description(content, title, plugin_name)
        
        # Extract recommendations
        recommendations = self._extract_recommendations_from_content(content)
        
        try:
            vulnerability = BaseVulnerability(
                vulnerability_id=f"dynamic_{plugin_name}_{hash(content) % 100000:05d}",
                title=title,
                description=description,
                severity=severity,
                vulnerability_type=self._determine_vulnerability_type(plugin_name, content),
                confidence=self._calculate_confidence(content, plugin_name),
                cwe_id=cwe_id,
                plugin_name=plugin_name,
                recommendations=recommendations
            )
            
            # Set additional fields after creation
            vulnerability.context.file_path = file_path or "Runtime Analysis"
            vulnerability.context.line_number = line_number
            vulnerability.context.code_snippet = evidence
            vulnerability.metadata['detection_method'] = "dynamic_analysis"
            vulnerability.metadata['source_classification'] = "dynamic_analysis"
            vulnerability.metadata['evidence_quality'] = "runtime_detected" if evidence else "no_evidence"
            
            # Add MASVS control to metadata for now
            vulnerability.metadata['masvs_control'] = masvs_control
            
            return vulnerability
            
        except Exception as e:
            self.logger.error(f"Failed to create vulnerability from section: {e}")
            return None
    
    def _create_fallback_vulnerability(
        self, 
        plugin_name: str, 
        plugin_title: str, 
        plugin_output: str,
        apk_context = None
    ) -> Optional[BaseVulnerability]:
        """Create a fallback vulnerability when structured extraction fails."""
        
        # Only create fallback if output contains vulnerability indicators
        vuln_indicators = ['vulnerability', 'insecure', 'risk', 'weakness', 'HIGH:', 'MEDIUM:', 'issue']
        output_lower = plugin_output.lower()
        
        if not any(indicator in output_lower for indicator in vuln_indicators):
            return None
        
        # Extract basic information
        title = plugin_title or f"{plugin_name} Analysis"
        severity = self._extract_severity_from_content(plugin_output)
        cwe_id = self._extract_cwe_from_content(plugin_output, plugin_name)
        masvs_control = self.masvs_mappings.get(cwe_id, 'MASVS-GENERAL')
        
        # Create a concise description
        description = self._generate_fallback_description(plugin_output, plugin_name)
        
        try:
            vulnerability = BaseVulnerability(
                vulnerability_id=f"dynamic_{plugin_name}_fallback_{hash(plugin_output) % 100000:05d}",
                title=title,
                description=description,
                severity=severity,
                vulnerability_type=self._determine_vulnerability_type(plugin_name, plugin_output),
                confidence=self._calculate_confidence(plugin_output, plugin_name),
                cwe_id=cwe_id,
                plugin_name=plugin_name,
                recommendations=self._extract_recommendations_from_content(plugin_output)
            )
            
            # Set additional fields after creation
            vulnerability.context.file_path = "Runtime Analysis"
            vulnerability.context.line_number = None
            vulnerability.context.code_snippet = "Runtime analysis - detailed code attribution pending"
            vulnerability.metadata['detection_method'] = "dynamic_analysis"
            vulnerability.metadata['source_classification'] = "dynamic_analysis"
            vulnerability.metadata['evidence_quality'] = "plugin_output"
            vulnerability.metadata['masvs_control'] = masvs_control
            
            return vulnerability
            
        except Exception as e:
            self.logger.error(f"Failed to create fallback vulnerability: {e}")
            return None
    
    def _extract_title_from_content(self, content: str, default_title: str) -> str:
        """Extract vulnerability title from content."""
        
        # Look for title patterns
        title_patterns = [
            r'(?:Title|TITLE):\s*([^\n]+)',
            r'(?:Vulnerability|VULNERABILITY):\s*([^\n]+)',
            r'(?:Issue|ISSUE):\s*([^\n]+)',
            r'^([^\n:]+):',  # First line before colon
            r'^\d+\.\s*([^\n]+)'  # Numbered item
        ]
        
        for pattern in title_patterns:
            match = re.search(pattern, content, re.MULTILINE | re.IGNORECASE)
            if match:
                title = match.group(1).strip()
                if len(title) > 10 and len(title) < 100:  # Reasonable title length
                    return title
        
        # Use first meaningful line as title
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            if len(line) > 10 and len(line) < 100 and ':' not in line[-10:]:
                return line
        
        return default_title
    
    def _extract_severity_from_content(self, content: str, hint_severity: str = None) -> VulnerabilitySeverity:
        """Extract severity from content."""
        
        if hint_severity:
            severity_map = {
                'CRITICAL': VulnerabilitySeverity.CRITICAL,
                'HIGH': VulnerabilitySeverity.HIGH,
                'MEDIUM': VulnerabilitySeverity.MEDIUM,
                'LOW': VulnerabilitySeverity.LOW
            }
            return severity_map.get(hint_severity.upper(), VulnerabilitySeverity.MEDIUM)
        
        for pattern, severity in self.severity_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return severity
        
        # Default based on content analysis
        high_risk_indicators = ['critical', 'injection', 'insecure', 'vulnerability', 'exposed']
        content_lower = content.lower()
        
        if any(indicator in content_lower for indicator in high_risk_indicators):
            return VulnerabilitySeverity.HIGH
        
        return VulnerabilitySeverity.MEDIUM
    
    def _extract_cwe_from_content(self, content: str, plugin_name: str) -> str:
        """Extract or infer CWE ID from content."""
        
        # Look for explicit CWE references
        cwe_match = re.search(r'CWE-(\d+)', content, re.IGNORECASE)
        if cwe_match:
            return f"CWE-{cwe_match.group(1)}"
        
        # Infer from plugin name
        plugin_lower = plugin_name.lower()
        for keyword, cwe in self.cwe_patterns.items():
            if keyword in plugin_lower:
                return cwe
        
        # Infer from content keywords
        content_lower = content.lower()
        for keyword, cwe in self.cwe_patterns.items():
            if keyword in content_lower:
                return cwe
        
        return 'CWE-693'  # Default: Protection Mechanism Failure
    
    def _extract_location_from_content(self, content: str, apk_context = None) -> Tuple[Optional[str], Optional[int]]:
        """Extract file path and line number from content."""
        
        # Look for file path patterns
        file_patterns = [
            r'(?:File|file|PATH|path):\s*([^\s\n]+\.(?:java|kt|xml|js))',
            r'(?:in|at)\s+([^\s\n]+\.(?:java|kt|xml|js))',
            r'([a-zA-Z0-9_/]+\.(?:java|kt|xml|js))',
        ]
        
        for pattern in file_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                file_path = match.group(1)
                
                # Look for line number near file path
                line_pattern = r'(?:line|Line|LINE)\s*(\d+)'
                line_match = re.search(line_pattern, content[max(0, match.start()-50):match.end()+50])
                line_number = int(line_match.group(1)) if line_match else None
                
                return file_path, line_number
        
        return None, None
    
    def _extract_evidence_from_content(self, content: str) -> str:
        """Extract code evidence from content."""
        
        # Look for code blocks or evidence patterns
        evidence_patterns = [
            r'(?:Code|code|Evidence|evidence):\s*([^\n]+)',
            r'```([^`]+)```',
            r'`([^`]+)`',
            r'(?:Found|found):\s*([^\n]+)',
        ]
        
        for pattern in evidence_patterns:
            match = re.search(pattern, content, re.MULTILINE | re.DOTALL)
            if match:
                evidence = match.group(1).strip()
                if len(evidence) > 5 and len(evidence) < 200:
                    return evidence
        
        # Use first meaningful code-like line
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            if any(indicator in line for indicator in ['.', '(', ')', '{', '}', ';']) and len(line) > 10:
                return line
        
        return "Runtime analysis evidence - detailed extraction pending"
    
    def _generate_description(self, content: str, title: str, plugin_name: str) -> str:
        """Generate vulnerability description."""
        
        # Extract first meaningful paragraph
        paragraphs = content.split('\n\n')
        for paragraph in paragraphs:
            clean_para = paragraph.strip().replace('\n', ' ')
            if len(clean_para) > 20 and len(clean_para) < 500:
                return clean_para
        
        # Fallback description
        return f"Dynamic analysis by {plugin_name} identified security issues that require investigation. {title}"
    
    def _generate_fallback_description(self, content: str, plugin_name: str) -> str:
        """Generate fallback description for simple plugin outputs."""
        
        # Extract summary or first meaningful content
        summary_lines = []
        for line in content.split('\n')[:5]:  # First 5 lines
            line = line.strip()
            if line and not line.startswith('=') and len(line) > 10:
                summary_lines.append(line)
                if len(' '.join(summary_lines)) > 100:
                    break
        
        if summary_lines:
            return ' '.join(summary_lines)
        
        return f"Dynamic security analysis completed by {plugin_name} with findings requiring review."
    
    def _extract_recommendations_from_content(self, content: str) -> List[str]:
        """Extract recommendations from content."""
        
        recommendations = []
        
        # Look for recommendation sections
        rec_patterns = [
            r'(?:Recommendations?|RECOMMENDATIONS?):\s*\n(.*?)(?=\n\n|\Z)',
            r'(?:Remediation|REMEDIATION):\s*\n(.*?)(?=\n\n|\Z)',
            r'(?:Fix|FIX):\s*\n(.*?)(?=\n\n|\Z)',
        ]
        
        for pattern in rec_patterns:
            match = re.search(pattern, content, re.MULTILINE | re.DOTALL | re.IGNORECASE)
            if match:
                rec_text = match.group(1).strip()
                # Split by bullet points or lines
                for line in rec_text.split('\n'):
                    line = line.strip().lstrip('â€¢-*').strip()
                    if line and len(line) > 10:
                        recommendations.append(line)
        
        return recommendations[:5]  # Limit to 5 recommendations
    
    def _determine_vulnerability_type(self, plugin_name: str, content: str) -> VulnerabilityType:
        """Determine vulnerability type from plugin name and content."""
        
        type_mappings = {
            'injection': VulnerabilityType.CODE_INJECTION,
            'sql': VulnerabilityType.SQL_INJECTION,
            'xss': VulnerabilityType.XSS_VULNERABILITY,
            'storage': VulnerabilityType.INSECURE_STORAGE,
            'crypto': VulnerabilityType.WEAK_CRYPTOGRAPHY,
            'secret': VulnerabilityType.HARDCODED_SECRETS,
            'network': VulnerabilityType.CLEARTEXT_TRAFFIC,
            'logging': VulnerabilityType.INSECURE_STORAGE,
            'webview': VulnerabilityType.WEBVIEW_SECURITY,
            'exported': VulnerabilityType.EXPORTED_COMPONENTS,
            'debug': VulnerabilityType.DEBUGGING_ENABLED,
        }
        
        plugin_lower = plugin_name.lower()
        content_lower = content.lower()
        
        for keyword, vuln_type in type_mappings.items():
            if keyword in plugin_lower or keyword in content_lower:
                return vuln_type
        
        return VulnerabilityType.RUNTIME_MANIPULATION
    
    def _calculate_confidence(self, content: str, plugin_name: str) -> float:
        """Calculate confidence score based on content quality."""
        
        confidence = 0.7  # Base confidence for dynamic analysis
        
        # Increase confidence for detailed outputs
        if len(content) > 500:
            confidence += 0.1
        
        # Increase confidence for structured outputs
        if any(pattern in content for pattern in ['CWE-', 'File:', 'Line:', 'Evidence:']):
            confidence += 0.15
        
        # Increase confidence for specific vulnerability types
        specific_patterns = ['injection', 'insecure', 'vulnerability', 'weakness']
        if any(pattern in content.lower() for pattern in specific_patterns):
            confidence += 0.1
        
        return min(0.95, confidence)


class DynamicVulnerabilityExtractor:
    """Main extractor for converting dynamic plugin outputs to structured vulnerabilities."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.parser = PluginOutputParser()
        
        # Initialize enricher for MITRE ATT&CK and threat intelligence
        try:
            from core.dynamic_vulnerability_enricher import DynamicVulnerabilityEnricher
            self.enricher = DynamicVulnerabilityEnricher()
        except ImportError:
            self.logger.warning("Dynamic vulnerability enricher not available")
            self.enricher = None
        
        # Initialize code attribution system
        try:
            from core.dynamic_code_attribution import DynamicCodeAttribution
            self.code_attributor = DynamicCodeAttribution()
        except ImportError:
            self.logger.warning("Dynamic code attribution not available")
            self.code_attributor = None
    
    def extract_vulnerabilities_from_scan_results(
        self, 
        scan_results: Dict[str, Any],
        apk_context = None
    ) -> List[BaseVulnerability]:
        """Extract all vulnerabilities from dynamic scan results."""
        
        vulnerabilities = []
        
        try:
            # Extract from different result structures
            plugin_results = self._extract_plugin_results(scan_results)
            
            for plugin_name, plugin_data in plugin_results.items():
                title = plugin_data.get('title', plugin_name)
                output = str(plugin_data.get('result', ''))
                
                if output:
                    plugin_vulns = self.parser.extract_vulnerabilities_from_plugin_output(
                        plugin_name, title, output, apk_context
                    )
                    vulnerabilities.extend(plugin_vulns)
            
            # ENHANCEMENT: Add code attribution for better location mapping
            if vulnerabilities and self.code_attributor:
                try:
                    attributed_vulnerabilities = self.code_attributor.enhance_vulnerabilities_with_code_attribution(
                        vulnerabilities, apk_context
                    )
                    self.logger.info(f"Enhanced {len(attributed_vulnerabilities)} vulnerabilities with code attribution")
                    vulnerabilities = attributed_vulnerabilities
                except Exception as e:
                    self.logger.warning(f"Code attribution failed: {e}")
            
            # ENHANCEMENT: Enrich vulnerabilities with MITRE ATT&CK and threat intelligence
            if vulnerabilities and self.enricher:
                try:
                    enriched_vulnerabilities = self.enricher.enrich_vulnerabilities(vulnerabilities)
                    self.logger.info(f"Enriched {len(enriched_vulnerabilities)} vulnerabilities with MITRE ATT&CK and threat intelligence")
                    vulnerabilities = enriched_vulnerabilities
                except Exception as e:
                    self.logger.warning(f"Vulnerability enrichment failed: {e}")
            
            self.logger.info(f"Extracted {len(vulnerabilities)} structured vulnerabilities from {len(plugin_results)} plugins")
            
        except Exception as e:
            self.logger.error(f"Failed to extract vulnerabilities from scan results: {e}")
        
        return vulnerabilities
    
    def _extract_plugin_results(self, scan_results: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
        """Extract plugin results from various scan result structures."""
        
        plugin_results = {}
        
        # Handle nested scan result structures
        if 'dynamic_scan' in scan_results:
            dynamic_data = scan_results['dynamic_scan']
            
            # Look for findings array
            if 'findings' in dynamic_data and isinstance(dynamic_data['findings'], list):
                for finding in dynamic_data['findings']:
                    if isinstance(finding, dict) and 'results' in finding:
                        plugin_results.update(finding['results'])
        
        # Handle direct results structure
        if 'results' in scan_results:
            plugin_results.update(scan_results['results'])
        
        return plugin_results