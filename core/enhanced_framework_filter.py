"""
Enhanced Framework Filter for False Positive Reduction
Addresses the 73.1% false positive rate by filtering framework and auto-generated files
"""

import re
import logging
from typing import List, Set, Dict, Any
from pathlib import Path

logger = logging.getLogger(__name__)

class EnhancedFrameworkFilter:
    """Advanced framework file filtering system to reduce false positives."""
    
    def __init__(self):
        self.framework_patterns = self._get_framework_patterns()
        self.auto_generated_patterns = self._get_auto_generated_patterns()
        self.filter_statistics = {
            "processed_files": 0,
            "filtered_files": 0,
            "framework_files": 0,
            "auto_generated_files": 0,
            "large_files": 0
        }
    
    def _get_framework_patterns(self) -> Set[str]:
        """Get comprehensive framework patterns for filtering."""
        return {
            # Android Framework
            'android/support/',
            'androidx/',
            'android/arch/',
            'com/android/',
            'android/content/',
            'android/app/',
            
            # Kotlin Framework
            'kotlin/',
            'kotlinx/',
            'kotlin/jvm/',
            'kotlin/reflect/',
            'kotlin/collections/',
            
            # Popular Libraries
            'okhttp3/',
            'okio/',
            'retrofit2/',
            'gson/',
            'jackson/',
            'glide/',
            'picasso/',
            'volley/',
            
            # Google Libraries
            'com/google/android/',
            'com/google/gson/',
            'com/google/common/',
            'com/google/firebase/',
            'com/google/play/',
            
            # Apache Libraries
            'org/apache/',
            
            # Build/Generated Paths
            'build/',
            'generated/',
            '.gradle/',
            'META-INF/',
            
            # Test Frameworks
            'junit/',
            'org/junit/',
            'org/mockito/',
            'androidx/test/',
        }
    
    def _get_auto_generated_patterns(self) -> List[str]:
        """Get patterns for auto-generated files."""
        return [
            r'.*\$\d+\.java$',  # Inner classes
            r'.*\$\w+\.java$',  # Named inner classes
            r'.*Parcelable\.java$',  # Parcelable implementations
            r'.*\$\$.*\.java$',  # Generated classes
            r'.*_Factory\.java$',  # Dagger factories
            r'.*_MembersInjector\.java$',  # Dagger injectors
            r'BuildConfig\.java$',  # Build configurations
            r'R\.java$',  # Resource files
            r'.*\.aidl\.java$',  # AIDL generated files
        ]
    
    def is_framework_file(self, file_path: str) -> bool:
        """Check if a file is a framework file that should be filtered."""
        if not file_path:
            return False
        
        # Normalize path
        normalized_path = file_path.replace('\\', '/').lower()
        
        # Check framework patterns
        for pattern in self.framework_patterns:
            if pattern in normalized_path:
                return True
        
        return False
    
    def is_auto_generated_file(self, file_path: str) -> bool:
        """Check if a file is auto-generated and should be filtered."""
        if not file_path:
            return False
        
        file_name = Path(file_path).name
        
        # Check auto-generated patterns
        for pattern in self.auto_generated_patterns:
            if re.match(pattern, file_name):
                return True
        
        # Additional heuristics
        auto_generated_indicators = [
            'generated by', 'auto-generated', 'do not edit',
            'automatically created', 'build system generated'
        ]
        
        # This would require file content analysis in practice
        # For now, use filename patterns
        return False
    
    def is_large_framework_file(self, file_path: str, file_size: int = 0) -> bool:
        """Check if file is a large framework file (likely auto-generated)."""
        # Files larger than 1MB are likely framework or generated
        if file_size > 1024 * 1024:
            return True
        
        # Check for framework indicators in large files
        if file_size > 100 * 1024:  # 100KB
            normalized_path = file_path.replace('\\', '/').lower()
            large_framework_indicators = [
                'exception', 'error', 'util', 'helper', 
                'support', 'compat', 'framework'
            ]
            
            for indicator in large_framework_indicators:
                if indicator in normalized_path:
                    return True
        
        return False
    
    def should_filter_file(self, file_path: str, file_size: int = 0, 
                          content_preview: str = None) -> Dict[str, Any]:
        """Comprehensive filtering decision with reasoning."""
        
        filter_result = {
            "should_filter": False,
            "reason": "application_code",
            "confidence": 1.0,
            "filter_type": None
        }
        
        # Check framework patterns
        if self.is_framework_file(file_path):
            filter_result.update({
                "should_filter": True,
                "reason": "framework_library",
                "confidence": 0.9,
                "filter_type": "framework"
            })
            return filter_result
        
        # Check auto-generated patterns
        if self.is_auto_generated_file(file_path):
            filter_result.update({
                "should_filter": True,
                "reason": "auto_generated",
                "confidence": 0.95,
                "filter_type": "auto_generated"
            })
            return filter_result
        
        # Check large framework files
        if self.is_large_framework_file(file_path, file_size):
            filter_result.update({
                "should_filter": True,
                "reason": "large_framework_file",
                "confidence": 0.8,
                "filter_type": "large_framework"
            })
            return filter_result
        
        # Content-based filtering (if content available)
        if content_preview:
            if self._is_framework_content(content_preview):
                filter_result.update({
                    "should_filter": True,
                    "reason": "framework_content",
                    "confidence": 0.85,
                    "filter_type": "content_based"
                })
                return filter_result
        
        return filter_result
    
    def _is_framework_content(self, content: str) -> bool:
        """Analyze content to determine if it's framework code."""
        framework_content_indicators = [
            'Copyright (C) 20', 'Licensed under the Apache License',
            'This file was automatically generated',
            'Do not modify this file',
            'Generated by the protocol buffer compiler',
            'Auto-generated file. Do not modify!',
            'package android.', 'package androidx.',
            'package kotlin.', 'package kotlinx.',
            'package com.google.android.',
            'package okhttp3.', 'package okio.'
        ]
        
        for indicator in framework_content_indicators:
            if indicator in content:
                return True
        
        return False
    
    def filter_file_list(self, file_paths: List[str], file_sizes: Dict[str, int] = None) -> Dict[str, Any]:
        """Filter a list of files and return results with statistics."""
        
        filtered_files = []
        application_files = []
        filter_details = []
        
        file_sizes = file_sizes or {}
        
        for file_path in file_paths:
            self.filter_statistics["processed_files"] += 1
            
            file_size = file_sizes.get(file_path, 0)
            filter_decision = self.should_filter_file(file_path, file_size)
            
            if filter_decision["should_filter"]:
                filtered_files.append(file_path)
                self.filter_statistics["filtered_files"] += 1
                
                # Update specific counters
                filter_type = filter_decision["filter_type"]
                if filter_type == "framework":
                    self.filter_statistics["framework_files"] += 1
                elif filter_type == "auto_generated":
                    self.filter_statistics["auto_generated_files"] += 1
                elif filter_type == "large_framework":
                    self.filter_statistics["large_files"] += 1
                
                logger.debug(f"Filtered {filter_type}: {file_path} - {filter_decision['reason']}")
            else:
                application_files.append(file_path)
            
            filter_details.append({
                "file_path": file_path,
                "filtered": filter_decision["should_filter"],
                "reason": filter_decision["reason"],
                "confidence": filter_decision["confidence"]
            })
        
        # Log filtering statistics
        total_files = len(file_paths)
        filtered_count = len(filtered_files)
        filtering_rate = filtered_count / max(total_files, 1)
        
        logger.info(f"ðŸš« Framework Filtering Results:")
        logger.info(f"   Total files: {total_files}")
        logger.info(f"   Filtered files: {filtered_count} ({filtering_rate:.1%})")
        logger.info(f"   Application files: {len(application_files)}")
        logger.info(f"   Framework files: {self.filter_statistics['framework_files']}")
        logger.info(f"   Auto-generated: {self.filter_statistics['auto_generated_files']}")
        
        return {
            "original_files": file_paths,
            "application_files": application_files,
            "filtered_files": filtered_files,
            "filter_details": filter_details,
            "statistics": {
                "total_files": total_files,
                "filtered_count": filtered_count,
                "application_count": len(application_files),
                "filtering_rate": filtering_rate
            }
        }
    
    def get_filter_statistics(self) -> Dict[str, Any]:
        """Get comprehensive filtering statistics."""
        total = self.filter_statistics["processed_files"]
        filtered = self.filter_statistics["filtered_files"]
        
        return {
            **self.filter_statistics,
            "filtering_rate": filtered / max(total, 1),
            "application_files": total - filtered
        }

# Global framework filter instance
enhanced_framework_filter = EnhancedFrameworkFilter()

def filter_framework_files(file_paths: List[str], file_sizes: Dict[str, int] = None) -> List[str]:
    """Global function for framework file filtering."""
    result = enhanced_framework_filter.filter_file_list(file_paths, file_sizes)
    return result["application_files"]
