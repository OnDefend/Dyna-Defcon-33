#!/usr/bin/env python3
"""
Vulnerability Origin Tracker

Tracks the exact origin and detection method of vulnerabilities to provide
complete audit trail and ensure accurate source attribution.

Author: AODS Team
Date: January 2025
"""

import logging
import time
import uuid
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import json
import hashlib
from pathlib import Path


class OriginType(Enum):
    """Types of vulnerability origins."""
    RUNTIME_HOOK = "runtime_hook"
    STATIC_ANALYSIS = "static_analysis"
    MANIFEST_ANALYSIS = "manifest_analysis"
    CONFIGURATION_REVIEW = "configuration_review"
    HYBRID_DETECTION = "hybrid_detection"
    UNKNOWN_ORIGIN = "unknown_origin"


class TrackingStatus(Enum):
    """Status of origin tracking."""
    TRACKED = "tracked"
    PARTIAL = "partial"
    UNTRACKED = "untracked"
    ERROR = "error"


@dataclass
class OriginMetadata:
    """Metadata about vulnerability origin."""
    origin_id: str
    tracking_timestamp: float
    detection_method: str
    analysis_phase: str
    evidence_type: str
    confidence_source: str
    plugin_name: str
    plugin_version: str
    analysis_session_id: str
    source_file: Optional[str] = None
    source_line: Optional[int] = None
    detection_context: Dict[str, Any] = field(default_factory=dict)
    validation_status: str = "unvalidated"
    audit_trail: List[Dict[str, Any]] = field(default_factory=list)


@dataclass
class OriginAuditTrail:
    """Complete audit trail for vulnerability origin."""
    origin_id: str
    vulnerability_id: str
    creation_timestamp: float
    last_updated: float
    tracking_events: List[Dict[str, Any]] = field(default_factory=list)
    validation_events: List[Dict[str, Any]] = field(default_factory=list)
    classification_history: List[Dict[str, Any]] = field(default_factory=list)
    metadata_changes: List[Dict[str, Any]] = field(default_factory=list)


class VulnerabilityOriginTracker:
    """
    Tracks the exact origin and detection method of vulnerabilities to provide
    complete audit trail and ensure accurate source attribution.
    """
    
    def __init__(self, session_id: str = None):
        """Initialize vulnerability origin tracker."""
        self.logger = logging.getLogger(__name__)
        self.session_id = session_id or f"origin_session_{int(time.time())}"
        
        # Origin tracking storage
        self.tracked_origins: Dict[str, OriginMetadata] = {}
        self.audit_trails: Dict[str, OriginAuditTrail] = {}
        
        # Tracking configuration
        self.track_all_sources = True
        self.detailed_audit_trail = True
        self.auto_validation = True
        
        # Detection method mapping
        self.method_mapping = {
            'frida_dynamic_analysis': 'frida_runtime_instrumentation',
            'runtime_hooks': 'frida_runtime_instrumentation',
            'jadx_static_analysis': 'jadx_static_analysis',
            'static_analysis': 'static_code_analysis',
            'manifest_analysis': 'manifest_inspection',
            'configuration_analysis': 'configuration_review'
        }
        
        self.logger.info(f"🕵️ VulnerabilityOriginTracker initialized (session: {self.session_id})")
    
    def track_vulnerability_origin(self, vulnerability: Union[Dict[str, Any], Any], 
                                 plugin_context: Dict[str, Any] = None) -> OriginMetadata:
        """
        Track the exact origin and detection method of a vulnerability.
        
        Args:
            vulnerability: Vulnerability object or dictionary
            plugin_context: Additional context from the detecting plugin
            
        Returns:
            OriginMetadata with complete tracking information
        """
        try:
            # Normalize vulnerability data
            vuln_data = self._normalize_vulnerability_data(vulnerability)
            plugin_context = plugin_context or {}
            
            # Generate unique origin ID
            origin_id = self._generate_origin_id(vuln_data)
            
            # Extract detection metadata
            detection_metadata = self._extract_detection_metadata(vuln_data, plugin_context)
            
            # Create origin metadata
            origin_metadata = OriginMetadata(
                origin_id=origin_id,
                tracking_timestamp=time.time(),
                detection_method=detection_metadata['method'],
                analysis_phase=detection_metadata['phase'],
                evidence_type=detection_metadata['evidence_type'],
                confidence_source=detection_metadata['confidence_source'],
                plugin_name=detection_metadata['plugin_name'],
                plugin_version=detection_metadata['plugin_version'],
                analysis_session_id=self.session_id,
                source_file=detection_metadata.get('source_file'),
                source_line=detection_metadata.get('source_line'),
                detection_context=detection_metadata['context']
            )
            
            # Validate origin if auto-validation is enabled
            if self.auto_validation:
                origin_metadata.validation_status = self._validate_origin(origin_metadata, vuln_data)
            
            # Store origin metadata
            self.tracked_origins[origin_id] = origin_metadata
            
            # Create audit trail
            self._create_audit_trail(origin_metadata, vuln_data)
            
            # Add tracking event
            self._add_tracking_event(origin_id, 'origin_tracked', {
                'detection_method': origin_metadata.detection_method,
                'confidence_source': origin_metadata.confidence_source,
                'validation_status': origin_metadata.validation_status
            })
            
            self.logger.debug(f"🕵️ Tracked vulnerability origin: {origin_id} "
                            f"({origin_metadata.detection_method})")
            
            return origin_metadata
            
        except Exception as e:
            self.logger.error(f"❌ Origin tracking failed: {e}")
            # Return minimal tracking information
            return OriginMetadata(
                origin_id=f"error_{int(time.time())}",
                tracking_timestamp=time.time(),
                detection_method="unknown_method",
                analysis_phase="unknown_phase",
                evidence_type="no_evidence",
                confidence_source="error",
                plugin_name="unknown",
                plugin_version="unknown",
                analysis_session_id=self.session_id,
                validation_status="error",
                detection_context={'error': str(e)}
            )
    
    def _normalize_vulnerability_data(self, vulnerability: Union[Dict[str, Any], Any]) -> Dict[str, Any]:
        """Normalize vulnerability data to dictionary format."""
        if isinstance(vulnerability, dict):
            return vulnerability
        elif hasattr(vulnerability, 'to_dict'):
            return vulnerability.to_dict()
        elif hasattr(vulnerability, '__dict__'):
            return vulnerability.__dict__
        else:
            # Extract common attributes
            vuln_data = {}
            for attr in ['id', 'title', 'description', 'severity', 'source', 'plugin_name']:
                if hasattr(vulnerability, attr):
                    vuln_data[attr] = getattr(vulnerability, attr)
            return vuln_data
    
    def _generate_origin_id(self, vuln_data: Dict[str, Any]) -> str:
        """Generate unique origin ID for vulnerability."""
        # Create hash based on vulnerability characteristics
        id_components = [
            vuln_data.get('title', ''),
            vuln_data.get('plugin_name', ''),
            vuln_data.get('source', ''),
            str(time.time())
        ]
        
        id_string = '|'.join(str(comp) for comp in id_components)
        id_hash = hashlib.md5(id_string.encode()).hexdigest()[:12]
        
        return f"origin_{id_hash}"
    
    def _extract_detection_metadata(self, vuln_data: Dict[str, Any], 
                                  plugin_context: Dict[str, Any]) -> Dict[str, Any]:
        """Extract comprehensive detection metadata."""
        
        # Determine detection method
        plugin_name = vuln_data.get('plugin_name', plugin_context.get('plugin_name', 'unknown'))
        detection_method = self.method_mapping.get(plugin_name, 'unknown_method')
        
        # Determine analysis phase
        analysis_phase = self._determine_analysis_phase(vuln_data, plugin_context)
        
        # Determine evidence type
        evidence_type = self._determine_evidence_type(vuln_data, plugin_context)
        
        # Determine confidence source
        confidence_source = self._determine_confidence_source(vuln_data, plugin_context)
        
        # Extract context information
        detection_context = {
            'vulnerability_data': {
                'title': vuln_data.get('title', 'unknown'),
                'severity': vuln_data.get('severity', 'unknown'),
                'confidence': vuln_data.get('confidence', 0.0)
            },
            'plugin_context': plugin_context,
            'runtime_indicators': self._extract_runtime_indicators(vuln_data),
            'static_indicators': self._extract_static_indicators(vuln_data),
            'config_indicators': self._extract_config_indicators(vuln_data)
        }
        
        return {
            'method': detection_method,
            'phase': analysis_phase,
            'evidence_type': evidence_type,
            'confidence_source': confidence_source,
            'plugin_name': plugin_name,
            'plugin_version': plugin_context.get('plugin_version', 'unknown'),
            'source_file': vuln_data.get('source_file'),
            'source_line': vuln_data.get('source_line'),
            'context': detection_context
        }
    
    def _determine_analysis_phase(self, vuln_data: Dict[str, Any], 
                                plugin_context: Dict[str, Any]) -> str:
        """Determine the analysis phase where vulnerability was detected."""
        
        # Check for runtime phase indicators
        if (vuln_data.get('runtime_context') or 
            vuln_data.get('hook_timestamp') or
            'runtime' in str(vuln_data).lower()):
            return 'runtime_monitoring'
        
        # Check for static phase indicators
        if (vuln_data.get('source_code') or
            vuln_data.get('decompiled_code') or
            'static' in str(vuln_data).lower()):
            return 'static_code_analysis'
        
        # Check for manifest phase indicators
        if (vuln_data.get('manifest_entry') or
            'manifest' in str(vuln_data).lower()):
            return 'manifest_inspection'
        
        # Check for configuration phase indicators
        if (vuln_data.get('configuration') or
            'permission' in str(vuln_data).lower()):
            return 'configuration_review'
        
        return 'unknown_phase'
    
    def _determine_evidence_type(self, vuln_data: Dict[str, Any], 
                               plugin_context: Dict[str, Any]) -> str:
        """Determine the type of evidence supporting the detection."""
        
        # Check for runtime evidence
        if (vuln_data.get('stack_trace') or
            vuln_data.get('hook_data') or
            vuln_data.get('execution_context')):
            return 'runtime_hook_data'
        
        # Check for static code evidence
        if (vuln_data.get('code_location') or
            vuln_data.get('method_signature') or
            vuln_data.get('class_name')):
            return 'static_code_pattern'
        
        # Check for manifest evidence
        if (vuln_data.get('manifest_entry') or
            vuln_data.get('permission')):
            return 'manifest_declaration'
        
        # Check for configuration evidence
        if vuln_data.get('configuration_setting'):
            return 'configuration_setting'
        
        return 'no_evidence'
    
    def _determine_confidence_source(self, vuln_data: Dict[str, Any], 
                                   plugin_context: Dict[str, Any]) -> str:
        """Determine the source of confidence scoring."""
        
        confidence_value = vuln_data.get('confidence', 0.0)
        
        # High confidence typically indicates strong evidence
        if confidence_value >= 0.8:
            if vuln_data.get('runtime_context'):
                return 'runtime_evidence_verification'
            else:
                return 'static_pattern_matching'
        
        # Medium confidence
        elif confidence_value >= 0.5:
            return 'heuristic_analysis'
        
        # Low confidence
        else:
            return 'weak_indicators'
    
    def _extract_runtime_indicators(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract runtime-specific indicators."""
        indicators = []
        
        if vuln_data.get('hook_timestamp'):
            indicators.append('hook_timestamp')
        if vuln_data.get('stack_trace'):
            indicators.append('stack_trace')
        if vuln_data.get('execution_context'):
            indicators.append('execution_context')
        if vuln_data.get('runtime_parameters'):
            indicators.append('runtime_parameters')
        if vuln_data.get('frida_session_id'):
            indicators.append('frida_session_id')
        
        return indicators
    
    def _extract_static_indicators(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract static analysis indicators."""
        indicators = []
        
        if vuln_data.get('source_code'):
            indicators.append('source_code')
        if vuln_data.get('decompiled_code'):
            indicators.append('decompiled_code')
        if vuln_data.get('method_signature'):
            indicators.append('method_signature')
        if vuln_data.get('class_name'):
            indicators.append('class_name')
        if vuln_data.get('code_location'):
            indicators.append('code_location')
        
        return indicators
    
    def _extract_config_indicators(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract configuration analysis indicators."""
        indicators = []
        
        if vuln_data.get('manifest_entry'):
            indicators.append('manifest_entry')
        if vuln_data.get('permission'):
            indicators.append('permission')
        if vuln_data.get('intent_filter'):
            indicators.append('intent_filter')
        if vuln_data.get('configuration_setting'):
            indicators.append('configuration_setting')
        
        return indicators
    
    def _validate_origin(self, origin_metadata: OriginMetadata, 
                        vuln_data: Dict[str, Any]) -> str:
        """Validate the origin metadata against vulnerability data."""
        
        validation_score = 0.0
        max_score = 4.0
        
        # Check method consistency
        if origin_metadata.detection_method != 'unknown_method':
            validation_score += 1.0
        
        # Check evidence consistency
        if origin_metadata.evidence_type != 'no_evidence':
            validation_score += 1.0
        
        # Check runtime validation
        if 'runtime' in origin_metadata.detection_method:
            if vuln_data.get('runtime_context') or vuln_data.get('hook_timestamp'):
                validation_score += 1.0
        
        # Check static validation
        if 'static' in origin_metadata.detection_method:
            if vuln_data.get('source_code') or vuln_data.get('decompiled_code'):
                validation_score += 1.0
        
        # Determine validation status
        validation_ratio = validation_score / max_score
        
        if validation_ratio >= 0.8:
            return 'validated'
        elif validation_ratio >= 0.5:
            return 'partially_validated'
        else:
            return 'validation_failed'
    
    def _create_audit_trail(self, origin_metadata: OriginMetadata, 
                          vuln_data: Dict[str, Any]) -> None:
        """Create audit trail for vulnerability origin."""
        
        vulnerability_id = vuln_data.get('id', f"vuln_{int(time.time())}")
        
        audit_trail = OriginAuditTrail(
            origin_id=origin_metadata.origin_id,
            vulnerability_id=vulnerability_id,
            creation_timestamp=origin_metadata.tracking_timestamp,
            last_updated=origin_metadata.tracking_timestamp
        )
        
        # Add initial tracking event
        tracking_event = {
            'event_type': 'origin_creation',
            'timestamp': time.time(),
            'detection_method': origin_metadata.detection_method,
            'evidence_type': origin_metadata.evidence_type,
            'plugin_name': origin_metadata.plugin_name,
            'validation_status': origin_metadata.validation_status
        }
        audit_trail.tracking_events.append(tracking_event)
        
        # Add initial classification
        classification_event = {
            'timestamp': time.time(),
            'classification_type': 'initial',
            'source_classification': self._get_source_classification(origin_metadata),
            'confidence_level': self._get_confidence_level(origin_metadata)
        }
        audit_trail.classification_history.append(classification_event)
        
        self.audit_trails[origin_metadata.origin_id] = audit_trail
    
    def _add_tracking_event(self, origin_id: str, event_type: str, 
                          event_data: Dict[str, Any]) -> None:
        """Add tracking event to audit trail."""
        
        if origin_id not in self.audit_trails:
            return
        
        audit_trail = self.audit_trails[origin_id]
        
        tracking_event = {
            'event_type': event_type,
            'timestamp': time.time(),
            **event_data
        }
        
        audit_trail.tracking_events.append(tracking_event)
        audit_trail.last_updated = time.time()
    
    def _get_source_classification(self, origin_metadata: OriginMetadata) -> str:
        """Get source classification based on origin metadata."""
        
        if 'runtime' in origin_metadata.detection_method:
            return 'runtime_dynamic_analysis'
        elif 'static' in origin_metadata.detection_method:
            return 'static_analysis'
        elif 'manifest' in origin_metadata.detection_method:
            return 'configuration_analysis'
        else:
            return 'unknown_source'
    
    def _get_confidence_level(self, origin_metadata: OriginMetadata) -> str:
        """Get confidence level based on origin metadata."""
        
        if origin_metadata.validation_status == 'validated':
            return 'high'
        elif origin_metadata.validation_status == 'partially_validated':
            return 'medium'
        else:
            return 'low'
    
    def get_origin_metadata(self, origin_id: str) -> Optional[OriginMetadata]:
        """Get origin metadata by ID."""
        return self.tracked_origins.get(origin_id)
    
    def get_audit_trail(self, origin_id: str) -> Optional[OriginAuditTrail]:
        """Get audit trail by origin ID."""
        return self.audit_trails.get(origin_id)
    
    def update_origin_metadata(self, origin_id: str, updates: Dict[str, Any]) -> bool:
        """Update origin metadata and record changes."""
        
        if origin_id not in self.tracked_origins:
            return False
        
        origin_metadata = self.tracked_origins[origin_id]
        
        # Record metadata changes
        metadata_change = {
            'timestamp': time.time(),
            'change_type': 'metadata_update',
            'updates': updates,
            'previous_values': {}
        }
        
        # Apply updates and record previous values
        for key, new_value in updates.items():
            if hasattr(origin_metadata, key):
                metadata_change['previous_values'][key] = getattr(origin_metadata, key)
                setattr(origin_metadata, key, new_value)
        
        # Update audit trail
        if origin_id in self.audit_trails:
            self.audit_trails[origin_id].metadata_changes.append(metadata_change)
            self.audit_trails[origin_id].last_updated = time.time()
        
        # Add tracking event
        self._add_tracking_event(origin_id, 'metadata_updated', {
            'updates_applied': list(updates.keys()),
            'update_count': len(updates)
        })
        
        return True
    
    def get_tracking_summary(self) -> Dict[str, Any]:
        """Get comprehensive tracking summary."""
        
        total_tracked = len(self.tracked_origins)
        validated_count = len([m for m in self.tracked_origins.values() 
                             if m.validation_status == 'validated'])
        
        # Count by detection method
        method_counts = {}
        for metadata in self.tracked_origins.values():
            method = metadata.detection_method
            method_counts[method] = method_counts.get(method, 0) + 1
        
        # Count by evidence type
        evidence_counts = {}
        for metadata in self.tracked_origins.values():
            evidence = metadata.evidence_type
            evidence_counts[evidence] = evidence_counts.get(evidence, 0) + 1
        
        return {
            'session_id': self.session_id,
            'total_tracked_origins': total_tracked,
            'validated_origins': validated_count,
            'validation_rate': validated_count / max(1, total_tracked),
            'method_distribution': method_counts,
            'evidence_distribution': evidence_counts,
            'tracking_timestamp': time.time(),
            'audit_trails_count': len(self.audit_trails)
        }
    
    def export_tracking_data(self, output_path: str = None) -> Dict[str, Any]:
        """Export complete tracking data."""
        
        tracking_data = {
            'session_metadata': {
                'session_id': self.session_id,
                'export_timestamp': time.time(),
                'total_origins': len(self.tracked_origins),
                'total_audit_trails': len(self.audit_trails)
            },
            'tracked_origins': {
                origin_id: {
                    'origin_id': metadata.origin_id,
                    'tracking_timestamp': metadata.tracking_timestamp,
                    'detection_method': metadata.detection_method,
                    'analysis_phase': metadata.analysis_phase,
                    'evidence_type': metadata.evidence_type,
                    'confidence_source': metadata.confidence_source,
                    'plugin_name': metadata.plugin_name,
                    'plugin_version': metadata.plugin_version,
                    'validation_status': metadata.validation_status,
                    'detection_context': metadata.detection_context
                }
                for origin_id, metadata in self.tracked_origins.items()
            },
            'audit_trails': {
                origin_id: {
                    'origin_id': trail.origin_id,
                    'vulnerability_id': trail.vulnerability_id,
                    'creation_timestamp': trail.creation_timestamp,
                    'last_updated': trail.last_updated,
                    'tracking_events_count': len(trail.tracking_events),
                    'validation_events_count': len(trail.validation_events),
                    'classification_history_count': len(trail.classification_history),
                    'metadata_changes_count': len(trail.metadata_changes)
                }
                for origin_id, trail in self.audit_trails.items()
            },
            'summary': self.get_tracking_summary()
        }
        
        if output_path:
            try:
                with open(output_path, 'w') as f:
                    json.dump(tracking_data, f, indent=2, default=str)
                self.logger.info(f"📄 Tracking data exported to: {output_path}")
            except Exception as e:
                self.logger.error(f"❌ Export failed: {e}")
        
        return tracking_data


# Convenience functions
def track_vulnerability_origin(vulnerability: Union[Dict[str, Any], Any], 
                             plugin_context: Dict[str, Any] = None) -> OriginMetadata:
    """Track vulnerability origin with default tracker."""
    tracker = VulnerabilityOriginTracker()
    return tracker.track_vulnerability_origin(vulnerability, plugin_context)


def get_vulnerability_origin_summary(vulnerabilities: List[Union[Dict[str, Any], Any]]) -> Dict[str, Any]:
    """Get origin summary for a list of vulnerabilities."""
    tracker = VulnerabilityOriginTracker()
    
    origins = []
    for vuln in vulnerabilities:
        origin = tracker.track_vulnerability_origin(vuln)
        origins.append(origin)
    
    return tracker.get_tracking_summary()


if __name__ == "__main__":
    # Demo usage
    print("🕵️ Vulnerability Origin Tracker Demo")
    print("=" * 40)
    
    # Create tracker
    tracker = VulnerabilityOriginTracker()
    
    print("✅ VulnerabilityOriginTracker initialized")
    print(f"📋 Session ID: {tracker.session_id}")
    
    print("\n🎯 Origin Types:")
    origins = list(OriginType)
    for origin in origins:
        print(f"   • {origin.value}")
    
    print("\n📊 Tracking Features:")
    print("   ✅ Complete audit trail generation")
    print("   ✅ Origin metadata validation")
    print("   ✅ Detection method classification")
    print("   ✅ Evidence type analysis")
    print("   ✅ Comprehensive tracking summary")
    
    print("\n✅ Tracker ready for origin tracking!")