#!/usr/bin/env python3
"""
Base Vulnerability Data Structures for AODS Plugin Modularization

This module provides standardized vulnerability data structures that ensure
consistency across all plugins and eliminate duplication of vulnerability
classes throughout the codebase.

Features:
- Standardized vulnerability severity levels
- Consistent vulnerability type categorization
- Rich metadata support for detailed analysis
- MASVS compliance mapping integration
- Extensible architecture for plugin-specific needs
"""

import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set, Union
from enum import Enum
from datetime import datetime

logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    """Standardized vulnerability type categorization."""
    # Cryptographic vulnerabilities
    WEAK_CRYPTOGRAPHY = "weak_cryptography"
    INSECURE_RANDOM = "insecure_random"
    HARDCODED_SECRETS = "hardcoded_secrets"
    CERTIFICATE_PINNING = "certificate_pinning"
    WEAK_KEY_GENERATION = "weak_key_generation"
    
    # Data storage vulnerabilities
    INSECURE_STORAGE = "insecure_storage"
    UNENCRYPTED_DATA = "unencrypted_data"
    EXTERNAL_STORAGE = "external_storage"
    SHARED_PREFERENCES = "shared_preferences"
    DATABASE_SECURITY = "database_security"
    
    # Network security vulnerabilities
    CLEARTEXT_TRAFFIC = "cleartext_traffic"
    SSL_TLS_BYPASS = "ssl_tls_bypass"
    CERTIFICATE_VALIDATION = "certificate_validation"
    NETWORK_SECURITY_CONFIG = "network_security_config"
    WEBVIEW_SECURITY = "webview_security"
    
    # Platform usage vulnerabilities
    EXPORTED_COMPONENTS = "exported_components"
    INTENT_SECURITY = "intent_security"
    PERMISSION_MISUSE = "permission_misuse"
    CONTENT_PROVIDER = "content_provider"
    BROADCAST_RECEIVER = "broadcast_receiver"
    
    # Binary security vulnerabilities
    NATIVE_CODE_SECURITY = "native_code_security"
    BINARY_HARDENING = "binary_hardening"
    JNI_SECURITY = "jni_security"
    MEMORY_PROTECTION = "memory_protection"
    ANTI_TAMPERING = "anti_tampering"
    
    # Code quality vulnerabilities
    CODE_INJECTION = "code_injection"
    PATH_TRAVERSAL = "path_traversal"
    SQL_INJECTION = "sql_injection"
    XSS_VULNERABILITY = "xss_vulnerability"
    DESERIALIZATION = "deserialization"
    
    # Authentication and authorization
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_FLAW = "authorization_flaw"
    SESSION_MANAGEMENT = "session_management"
    ACCESS_CONTROL = "access_control"
    BIOMETRIC_SECURITY = "biometric_security"
    
    # Dynamic analysis findings
    RUNTIME_MANIPULATION = "runtime_manipulation"
    DEBUGGING_ENABLED = "debugging_enabled"
    ROOT_DETECTION = "root_detection"
    EMULATOR_DETECTION = "emulator_detection"
    FRIDA_DETECTION = "frida_detection"
    
    # General security issues
    INFORMATION_DISCLOSURE = "information_disclosure"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    COMPLIANCE_VIOLATION = "compliance_violation"
    ATTACK_SURFACE = "attack_surface"
    GENERAL_SECURITY = "general_security"

class VulnerabilitySeverity(Enum):
    """Standardized vulnerability severity levels."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"
    
    @property
    def score(self) -> int:
        """Get numeric score for severity (1-5)."""
        severity_scores = {
            VulnerabilitySeverity.CRITICAL: 5,
            VulnerabilitySeverity.HIGH: 4,
            VulnerabilitySeverity.MEDIUM: 3,
            VulnerabilitySeverity.LOW: 2,
            VulnerabilitySeverity.INFO: 1
        }
        return severity_scores.get(self, 1)
    
    @property
    def color(self) -> str:
        """Get color code for Rich Text formatting."""
        severity_colors = {
            VulnerabilitySeverity.CRITICAL: "bright_red",
            VulnerabilitySeverity.HIGH: "red",
            VulnerabilitySeverity.MEDIUM: "yellow",
            VulnerabilitySeverity.LOW: "blue",
            VulnerabilitySeverity.INFO: "green"
        }
        return severity_colors.get(self, "white")

@dataclass
class VulnerabilityContext:
    """Context information for vulnerability findings."""
    file_path: str = ""
    line_number: int = 0
    method_name: str = ""
    class_name: str = ""
    package_name: str = ""
    component_type: str = ""
    analysis_source: str = ""
    code_snippet: str = ""
    surrounding_context: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class VulnerabilityMatch:
    """Represents a specific pattern match within a vulnerability."""
    pattern_id: str
    pattern_name: str
    match_text: str
    match_confidence: float
    match_location: str
    line_number: int = 0
    evidence: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class BaseVulnerability:
    """
    Base vulnerability class providing standardized structure for all
    vulnerability findings across AODS plugins.
    """
    # Core vulnerability identification
    vulnerability_id: str
    vulnerability_type: VulnerabilityType
    severity: VulnerabilitySeverity
    title: str
    description: str
    
    # Context and location information
    context: VulnerabilityContext = field(default_factory=VulnerabilityContext)
    matches: List[VulnerabilityMatch] = field(default_factory=list)
    
    # Confidence and validation
    confidence: float = 0.8
    confidence_factors: Dict[str, float] = field(default_factory=dict)
    validation_sources: List[str] = field(default_factory=list)
    
    # Security impact and recommendations
    security_impact: str = ""
    remediation: str = ""
    recommendations: List[str] = field(default_factory=list)
    
    # MASVS and compliance mapping
    masvs_controls: List[str] = field(default_factory=list)
    compliance_standards: Dict[str, List[str]] = field(default_factory=dict)
    
    # Technical details
    cvss_score: Optional[float] = None
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    
    # Analysis metadata
    plugin_name: str = ""
    analysis_timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    analysis_duration: float = 0.0
    
    # Additional metadata and evidence
    evidence: Dict[str, Any] = field(default_factory=dict)
    references: List[str] = field(default_factory=list)
    tags: Set[str] = field(default_factory=set)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate vulnerability data after initialization."""
        # Validate confidence value
        if not 0.0 <= self.confidence <= 1.0:
            logger.warning(f"Invalid confidence value {self.confidence} for {self.vulnerability_id}, clamping to valid range")
            self.confidence = max(0.0, min(1.0, self.confidence))
        
        # Ensure tags is a set
        if isinstance(self.tags, list):
            self.tags = set(self.tags)
        
        # Validate CVSS score if provided
        if self.cvss_score is not None:
            if not 0.0 <= self.cvss_score <= 10.0:
                logger.warning(f"Invalid CVSS score {self.cvss_score} for {self.vulnerability_id}")
                self.cvss_score = None

    @property
    def risk_score(self) -> float:
        """Calculate risk score based on severity and confidence."""
        return (self.severity.score / 5.0) * self.confidence

    @property
    def is_high_risk(self) -> bool:
        """Determine if this is a high-risk vulnerability."""
        return self.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH] and self.confidence >= 0.7

    @property
    def match_count(self) -> int:
        """Get number of pattern matches."""
        return len(self.matches)

    @property
    def evidence_count(self) -> int:
        """Get number of evidence items."""
        return len(self.evidence)

    def add_match(self, 
                  pattern_id: str,
                  pattern_name: str,
                  match_text: str,
                  confidence: float,
                  location: str,
                  line_number: int = 0,
                  evidence: Optional[Dict[str, Any]] = None,
                  metadata: Optional[Dict[str, Any]] = None) -> None:
        """Add a pattern match to this vulnerability."""
        match = VulnerabilityMatch(
            pattern_id=pattern_id,
            pattern_name=pattern_name,
            match_text=match_text,
            match_confidence=confidence,
            match_location=location,
            line_number=line_number,
            evidence=evidence or {},
            metadata=metadata or {}
        )
        self.matches.append(match)

    def add_evidence(self, key: str, value: Any, description: str = "") -> None:
        """Add evidence to support this vulnerability finding."""
        self.evidence[key] = {
            'value': value,
            'description': description,
            'timestamp': datetime.now().isoformat()
        }

    def add_recommendation(self, recommendation: str) -> None:
        """Add a security recommendation."""
        if recommendation and recommendation not in self.recommendations:
            self.recommendations.append(recommendation)

    def add_masvs_control(self, control: str) -> None:
        """Add MASVS control mapping."""
        if control and control not in self.masvs_controls:
            self.masvs_controls.append(control)

    def add_compliance_mapping(self, standard: str, controls: List[str]) -> None:
        """Add compliance standard mapping."""
        if standard not in self.compliance_standards:
            self.compliance_standards[standard] = []
        
        for control in controls:
            if control not in self.compliance_standards[standard]:
                self.compliance_standards[standard].append(control)

    def add_tag(self, tag: str) -> None:
        """Add a tag to this vulnerability."""
        if tag:
            self.tags.add(tag)

    def update_confidence(self, new_confidence: float, factors: Optional[Dict[str, float]] = None) -> None:
        """Update confidence score with optional factors."""
        if 0.0 <= new_confidence <= 1.0:
            self.confidence = new_confidence
            if factors:
                self.confidence_factors.update(factors)

    def merge_vulnerability(self, other: 'BaseVulnerability') -> None:
        """Merge another vulnerability finding into this one."""
        if other.vulnerability_type != self.vulnerability_type:
            logger.warning(f"Merging different vulnerability types: {self.vulnerability_type} and {other.vulnerability_type}")
        
        # Merge matches
        self.matches.extend(other.matches)
        
        # Merge evidence
        self.evidence.update(other.evidence)
        
        # Merge recommendations
        for rec in other.recommendations:
            self.add_recommendation(rec)
        
        # Merge MASVS controls
        for control in other.masvs_controls:
            self.add_masvs_control(control)
        
        # Merge compliance mappings
        for standard, controls in other.compliance_standards.items():
            self.add_compliance_mapping(standard, controls)
        
        # Merge tags
        self.tags.update(other.tags)
        
        # Update confidence to higher value
        if other.confidence > self.confidence:
            self.confidence = other.confidence
        
        # Merge metadata
        self.metadata.update(other.metadata)

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary representation."""
        return {
            'vulnerability_id': self.vulnerability_id,
            'vulnerability_type': self.vulnerability_type.value,
            'severity': self.severity.value,
            'severity_score': self.severity.score,
            'title': self.title,
            'description': self.description,
            'confidence': self.confidence,
            'confidence_factors': self.confidence_factors,
            'risk_score': self.risk_score,
            'is_high_risk': self.is_high_risk,
            'context': {
                'file_path': self.context.file_path,
                'line_number': self.context.line_number,
                'method_name': self.context.method_name,
                'class_name': self.context.class_name,
                'package_name': self.context.package_name,
                'component_type': self.context.component_type,
                'analysis_source': self.context.analysis_source,
                'code_snippet': self.context.code_snippet,
                'metadata': self.context.metadata
            },
            'matches': [
                {
                    'pattern_id': match.pattern_id,
                    'pattern_name': match.pattern_name,
                    'match_text': match.match_text,
                    'match_confidence': match.match_confidence,
                    'match_location': match.match_location,
                    'line_number': match.line_number,
                    'evidence': match.evidence,
                    'metadata': match.metadata
                }
                for match in self.matches
            ],
            'security_impact': self.security_impact,
            'remediation': self.remediation,
            'recommendations': self.recommendations,
            'masvs_controls': self.masvs_controls,
            'compliance_standards': self.compliance_standards,
            'cvss_score': self.cvss_score,
            'cwe_id': self.cwe_id,
            'owasp_category': self.owasp_category,
            'plugin_name': self.plugin_name,
            'analysis_timestamp': self.analysis_timestamp,
            'analysis_duration': self.analysis_duration,
            'evidence': self.evidence,
            'references': self.references,
            'tags': list(self.tags),
            'metadata': self.metadata,
            'match_count': self.match_count,
            'evidence_count': self.evidence_count,
            'validation_sources': self.validation_sources
        }

@dataclass
class VulnerabilityFinding:
    """
    Container for multiple vulnerability findings from a single analysis.
    """
    plugin_name: str
    analysis_type: str
    target_name: str
    vulnerabilities: List[BaseVulnerability] = field(default_factory=list)
    analysis_metadata: Dict[str, Any] = field(default_factory=dict)
    analysis_timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    analysis_duration: float = 0.0
    
    @property
    def vulnerability_count(self) -> int:
        """Get total number of vulnerabilities."""
        return len(self.vulnerabilities)
    
    @property
    def high_risk_count(self) -> int:
        """Get number of high-risk vulnerabilities."""
        return sum(1 for vuln in self.vulnerabilities if vuln.is_high_risk)
    
    @property
    def severity_breakdown(self) -> Dict[str, int]:
        """Get breakdown of vulnerabilities by severity."""
        breakdown = {severity.value: 0 for severity in VulnerabilitySeverity}
        
        for vuln in self.vulnerabilities:
            breakdown[vuln.severity.value] += 1
        
        return breakdown
    
    @property
    def average_confidence(self) -> float:
        """Get average confidence across all vulnerabilities."""
        if not self.vulnerabilities:
            return 0.0
        
        return sum(vuln.confidence for vuln in self.vulnerabilities) / len(self.vulnerabilities)
    
    def add_vulnerability(self, vulnerability: BaseVulnerability) -> None:
        """Add a vulnerability to this finding."""
        vulnerability.plugin_name = self.plugin_name
        self.vulnerabilities.append(vulnerability)
    
    def get_vulnerabilities_by_severity(self, severity: VulnerabilitySeverity) -> List[BaseVulnerability]:
        """Get vulnerabilities filtered by severity."""
        return [vuln for vuln in self.vulnerabilities if vuln.severity == severity]
    
    def get_vulnerabilities_by_type(self, vuln_type: VulnerabilityType) -> List[BaseVulnerability]:
        """Get vulnerabilities filtered by type."""
        return [vuln for vuln in self.vulnerabilities if vuln.vulnerability_type == vuln_type] 