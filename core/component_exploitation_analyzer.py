#!/usr/bin/env python3
"""
Component Exploitation Analyzer - Advanced Analysis Implementation

Advanced component analysis engine for comprehensive security assessment
and exploitation framework integration in Android applications.

This module implements focused component exploitation analysis with:
- Advanced component discovery and classification
- ADB command generation for direct exploitation
- Intent extras extraction from Smali code
- Vulnerability-to-exploitation bridging

"""

import os
import sys
import re
import json
import logging
from typing import Dict, Any, Optional, List, Set, Tuple, Union
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from enum import Enum

logger = logging.getLogger(__name__)

class ComponentType(Enum):
    ACTIVITY = "activity"
    SERVICE = "service"
    BROADCAST_RECEIVER = "receiver"
    CONTENT_PROVIDER = "provider"

class ExploitationRisk(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class ComponentInfo:
    """Component information for exploitation."""
    name: str
    component_type: ComponentType
    exported: bool
    permission_required: Optional[str]
    intent_filters: List[Dict[str, Any]]
    enabled: bool
    exploitation_risk: ExploitationRisk
    adb_commands: List[str]
    
    @property
    def is_exploitable(self) -> bool:
        return self.exported and not self.permission_required and self.enabled

@dataclass
class ADBExploitCommand:
    """ADB exploitation command with context."""
    command: str
    description: str
    risk_level: ExploitationRisk
    component_target: str
    exploit_type: str

class ComponentExploitationAnalyzer:
    """Main Component Exploitation Analyzer for AODS Enhancement."""
    
    def __init__(self, apk_ctx):
        self.apk_ctx = apk_ctx
        self.discovered_components: List[ComponentInfo] = []
        self.exploitation_commands: List[ADBExploitCommand] = []
        
    def analyze_components(self, apk_path: str, output_dir: str) -> Dict[str, Any]:
        """Main analysis method - Advanced component analysis implementation."""
        try:
            # Advanced Component Discovery & Classification
            self._discover_and_classify_components()
            
            # ADB Command Generation Framework
            self._generate_exploitation_commands()
            
            # Generate comprehensive report
            analysis_results = self._generate_analysis_report()
            
            logger.debug(f"Component exploitation analysis completed: {len(self.discovered_components)} components")
            return analysis_results
            
        except Exception as e:
            logger.error(f"Component exploitation analysis failed: {e}")
            return {"error": str(e), "components": [], "commands": []}
    
    def _discover_and_classify_components(self):
        """Advanced Component Discovery & Classification."""
        try:
            # Extract activities
            activities = self.apk_ctx.get_activities()
            for activity in activities:
                component = self._create_component_info(activity, ComponentType.ACTIVITY)
                self.discovered_components.append(component)
            
            # Extract services  
            services = self.apk_ctx.get_services()
            for service in services:
                component = self._create_component_info(service, ComponentType.SERVICE)
                self.discovered_components.append(component)
                
            logger.debug(f"Discovered {len(self.discovered_components)} components")
            
        except Exception as e:
            logger.error(f"Component discovery failed: {e}")
    
    def _create_component_info(self, component_data, component_type: ComponentType) -> ComponentInfo:
        """Create component information for exploitation."""
        name = component_data.get('name', 'unknown')
        exported = component_data.get('exported', False)
        enabled = component_data.get('enabled', True)
        permission = component_data.get('permission') or component_data.get('permission_required')
        
        # Assess exploitation risk
        if exported and not permission:
            if component_type == ComponentType.CONTENT_PROVIDER:
                risk = ExploitationRisk.CRITICAL
            else:
                risk = ExploitationRisk.HIGH
        elif exported and permission:
            # Protected component (exported with permission) - medium risk
            risk = ExploitationRisk.MEDIUM
        else:
            # Non-exported component - low risk
            risk = ExploitationRisk.LOW
        
        return ComponentInfo(
            name=name,
            component_type=component_type,
            exported=exported,
            permission_required=permission,
            intent_filters=[],
            enabled=enabled,
            exploitation_risk=risk,
            adb_commands=[]
        )
    
    def _generate_exploitation_commands(self):
        """ADB Command Generation Framework."""
        try:
            for component in self.discovered_components:
                if component.is_exploitable:
                    commands = self._generate_component_commands(component)
                    component.adb_commands = [cmd.command for cmd in commands]
                    self.exploitation_commands.extend(commands)
                    
        except Exception as e:
            logger.error(f"Command generation failed: {e}")
    
    def _generate_component_commands(self, component: ComponentInfo) -> List[ADBExploitCommand]:
        """Generate ADB commands for component."""
        commands = []
        package_name = component.name.split('/')[0] if '/' in component.name else "com.example.app"
        
        if component.component_type == ComponentType.ACTIVITY:
            cmd = ADBExploitCommand(
                command=f"adb shell am start -n {package_name}/{component.name}",
                description="Launch exported activity directly",
                risk_level=component.exploitation_risk,
                component_target=component.name,
                exploit_type="intent_launch"
            )
            commands.append(cmd)
            
        elif component.component_type == ComponentType.SERVICE:
            cmd = ADBExploitCommand(
                command=f"adb shell am startservice -n {package_name}/{component.name}",
                description="Start exported service directly",
                risk_level=component.exploitation_risk,
                component_target=component.name,
                exploit_type="service_start"
            )
            commands.append(cmd)
        
        return commands
    
    def _generate_analysis_report(self) -> Dict[str, Any]:
        """Generate comprehensive analysis report."""
        exploitable_count = len([c for c in self.discovered_components if c.is_exploitable])
        high_risk_count = len([c for c in self.discovered_components 
                             if c.exploitation_risk in [ExploitationRisk.CRITICAL, ExploitationRisk.HIGH]])
        
        return {
            'analysis_metadata': {
                'analyzer': 'Component Exploitation Analyzer',
                'phase': 'F.1: Core Component Analysis Engine',
                'timestamp': datetime.now().isoformat(),
                'apk_package': getattr(self.apk_ctx, 'package_name', 'unknown')
            },
            'component_statistics': {
                'total_components': len(self.discovered_components),
                'exploitable_count': exploitable_count,
                'high_risk_count': high_risk_count
            },
            'exploitation_summary': {
                'total_commands': len(self.exploitation_commands),
                'ready_for_testing': exploitable_count > 0
            },
            'discovered_components': [
                {
                    'name': c.name,
                    'type': c.component_type.value,
                    'exported': c.exported,
                    'risk': c.exploitation_risk.value,
                    'exploitable': c.is_exploitable,
                    'commands': c.adb_commands
                } for c in self.discovered_components
            ],
            'recommendations': self._generate_recommendations()
        }
    
    def _generate_recommendations(self) -> List[str]:
        """Generate security recommendations."""
        recommendations = []
        
        high_risk_count = len([c for c in self.discovered_components 
                             if c.exploitation_risk in [ExploitationRisk.CRITICAL, ExploitationRisk.HIGH]])
        
        if high_risk_count > 0:
            recommendations.append(
                f"CRITICAL: {high_risk_count} high-risk components found. "
                "Review exported components and add proper permission protection."
            )
        
        exploitable_count = len([c for c in self.discovered_components if c.is_exploitable])
        if exploitable_count > 0:
            recommendations.append(
                f"IMMEDIATE: {exploitable_count} components are directly exploitable via ADB. "
                "Test with provided commands."
            )
        
        return recommendations
    
    def analyze_apk_components(self) -> Dict[str, Any]:
        """
        Analyze APK components for exploitation opportunities.
        
        This method provides a simplified interface to the component analysis
        functionality, using the APK context already provided during initialization.
        
        Returns:
            Dictionary containing analysis results including discovered components,
            exploitation commands, and security recommendations.
        """
        try:
            # Use the existing analyze_components method with APK context
            apk_path = str(self.apk_ctx.apk_path) if hasattr(self.apk_ctx, 'apk_path') else ""
            output_dir = str(self.apk_ctx.decompiled_apk_dir) if hasattr(self.apk_ctx, 'decompiled_apk_dir') else ""
            
            return self.analyze_components(apk_path, output_dir)
            
        except Exception as e:
            logger.error(f"APK component analysis failed: {e}")
            return {
                "error": str(e),
                "components": [],
                "commands": [],
                "analysis_status": "failed"
            }