#!/usr/bin/env python3
"""
AODS Vulnerability Enhancement Pipeline

Provides comprehensive enhancement of AODS vulnerability findings with:
1. Contextual recommendations generation
2. ML-based evidence enhancement
3. Smart filtering integration

Designed for seamless integration into the main AODS workflow without regressions.
"""

import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class EnhancementConfig:
    """Configuration for vulnerability enhancement pipeline."""
    enable_recommendations: bool = True
    enable_ml_enhancement: bool = True
    enable_smart_filtering: bool = True
    ml_confidence_threshold: float = 0.6
    recommendation_min_count: int = 3
    smart_filtering_mode: str = "balanced"  # conservative, balanced, aggressive

class AODSVulnerabilityEnhancer:
    """
    Main enhancement pipeline for AODS vulnerabilities.
    
    Integrates with existing AODS components to provide:
    - Contextual security recommendations
    - ML-based evidence enhancement
    - Smart false positive filtering
    - Organic code snippet extraction (no hardcoding)
    """
    
    def __init__(self, config: Optional[EnhancementConfig] = None, decompiled_path: Optional[str] = None):
        self.config = config or EnhancementConfig()
        self.decompiled_path = decompiled_path
        self.logger = logger
        
        # Initialize components
        self._init_recommendation_engine()
        self._init_ml_components()
        self._init_smart_filtering()
        self._init_organic_code_extraction()
    
    def _init_recommendation_engine(self):
        """Initialize recommendation generation components."""
        try:
            from core.enhanced_vulnerability_processor import EnhancedVulnerabilityProcessor
            self.vulnerability_processor = EnhancedVulnerabilityProcessor()
            self.recommendations_available = True
            self.logger.info("âœ… Recommendation engine initialized")
        except ImportError as e:
            self.vulnerability_processor = None
            self.recommendations_available = False
            self.logger.warning(f"âš ï¸ Recommendation engine not available: {e}")
    
    def _init_ml_components(self):
        """Initialize ML enhancement components."""
        try:
            from core.ai_ml.intelligent_vulnerability_detector import IntelligentVulnerabilityDetector
            from core.ml_enhanced_classifier import MLEnhancedClassifier
            
            self.ml_detector = IntelligentVulnerabilityDetector()
            self.ml_classifier = MLEnhancedClassifier()
            self.ml_available = True
            self.logger.info("âœ… ML enhancement components initialized")
        except ImportError as e:
            self.ml_detector = None
            self.ml_classifier = None
            self.ml_available = False
            self.logger.warning(f"âš ï¸ ML components not available: {e}")
    
    def _init_smart_filtering(self):
        """Initialize smart filtering components."""
        try:
            from core.aods_smart_filtering_integration import integrate_smart_filtering_into_aods_pipeline
            self.smart_filter_func = integrate_smart_filtering_into_aods_pipeline
            self.smart_filtering_available = True
            self.logger.info("âœ… Smart filtering initialized")
        except ImportError as e:
            self.smart_filter_func = None
            self.smart_filtering_available = False
            self.logger.warning(f"âš ï¸ Smart filtering not available: {e}")
    
    def _init_organic_code_extraction(self):
        """Initialize organic code snippet extraction."""
        try:
            from core.organic_code_snippet_extractor import OrganicCodeSnippetExtractor
            self.code_extractor = OrganicCodeSnippetExtractor(self.decompiled_path)
            self.organic_code_available = True
            self.logger.info("âœ… Organic code extraction initialized")
        except ImportError as e:
            self.code_extractor = None
            self.organic_code_available = False
            self.logger.warning(f"âš ï¸ Organic code extraction not available: {e}")
    
    def enhance_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]], 
                              scan_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Main enhancement pipeline for AODS vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerability dictionaries
            scan_context: Context information (scan_type, package_name, etc.)
            
        Returns:
            Enhanced vulnerabilities with recommendations, ML enhancements, and filtering
        """
        self.logger.info(f"ðŸ”§ DEBUG: Starting enhancement with {len(vulnerabilities)} vulnerabilities")
        self.logger.info(f"ðŸ”§ DEBUG: Scan context: {scan_context}")
        
        if not vulnerabilities:
            self.logger.warning("ðŸ”§ DEBUG: No vulnerabilities provided to enhancement pipeline")
            return vulnerabilities
        
        enhanced_vulns = vulnerabilities.copy()
        enhancement_stats = {
            'total_vulnerabilities': len(vulnerabilities),
            'recommendations_added': 0,
            'ml_enhanced': 0,
            'filtered_count': 0
        }
        
        # Step 1: Add organic code snippets (highest priority)
        if self.organic_code_available:
            enhanced_vulns = self._add_organic_code_snippets(enhanced_vulns)
            enhancement_stats['organic_code_added'] = sum(
                1 for v in enhanced_vulns if v.get('code_snippet_source') == 'organic_extraction'
            )
        
        # Step 2: Add recommendations
        if self.config.enable_recommendations:
            enhanced_vulns = self._add_recommendations(enhanced_vulns)
            enhancement_stats['recommendations_added'] = sum(
                1 for v in enhanced_vulns if v.get('recommendations')
            )
        
        # Step 3: Apply ML enhancement
        if self.config.enable_ml_enhancement and self.ml_available:
            enhanced_vulns = self._apply_ml_enhancement(enhanced_vulns)
            enhancement_stats['ml_enhanced'] = sum(
                1 for v in enhanced_vulns if v.get('ml_enhanced')
            )
        
        # Step 4: Smart filtering
        if self.config.enable_smart_filtering and self.smart_filtering_available:
            original_count = len(enhanced_vulns)
            self.logger.info(f"ðŸ”§ DEBUG: Starting smart filtering with {original_count} vulnerabilities")
            enhanced_vulns = self._apply_smart_filtering(enhanced_vulns, scan_context)
            final_count = len(enhanced_vulns)
            enhancement_stats['filtered_count'] = original_count - final_count
            self.logger.info(f"ðŸ”§ DEBUG: Smart filtering complete: {original_count} -> {final_count} vulnerabilities")
        
        # Log enhancement statistics
        self._log_enhancement_stats(enhancement_stats)
        
        self.logger.info(f"ðŸ”§ DEBUG: Enhancement pipeline returning {len(enhanced_vulns)} vulnerabilities")
        return enhanced_vulns
    
    def _add_organic_code_snippets(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Add organic code snippets extracted from actual APK source code."""
        enhanced_vulns = []
        
        for vuln in vulnerabilities:
            enhanced_vuln = vuln.copy()
            
            # Only add organic code if no real code snippet exists
            existing_snippet = enhanced_vuln.get('code_snippet', '')
            
            # Check if existing snippet is real or hardcoded
            if not existing_snippet or not self.code_extractor._is_real_code(existing_snippet):
                try:
                    organic_snippet = self.code_extractor.extract_organic_snippet(vuln)
                    if organic_snippet:
                        enhanced_vuln['code_snippet'] = organic_snippet
                        enhanced_vuln['code_snippet_source'] = 'organic_extraction'
                        enhanced_vuln['code_snippet_organic'] = True
                except Exception as e:
                    self.logger.debug(f"Organic code extraction failed for {vuln.get('title', 'Unknown')}: {e}")
            
            enhanced_vulns.append(enhanced_vuln)
        
        return enhanced_vulns
    
    def _add_recommendations(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Add contextual recommendations to vulnerabilities."""
        enhanced_vulns = []
        
        for vuln in vulnerabilities:
            enhanced_vuln = vuln.copy()
            
            # Only add recommendations if none exist
            if not vuln.get('recommendations') or vuln.get('recommendations') == []:
                recommendations = self._generate_contextual_recommendations(vuln)
                enhanced_vuln['recommendations'] = recommendations
                enhanced_vuln['recommendations_source'] = 'aods_contextual_generator'
            
            enhanced_vulns.append(enhanced_vuln)
        
        return enhanced_vulns
    
    def _generate_contextual_recommendations(self, vuln: Dict[str, Any]) -> List[str]:
        """Generate contextual recommendations for a vulnerability."""
        recommendations = []
        
        title = vuln.get('title', '').lower()
        description = vuln.get('description', '').lower()
        severity = vuln.get('severity', 'MEDIUM').upper()
        cwe_id = vuln.get('configuration_evidence', {}).get('cwe_id', '')
        
        # Specific recommendations based on vulnerability patterns
        if 'biometric' in title:
            if 'bypass' in title or 'deprecated' in title:
                recommendations.extend([
                    "Upgrade to BiometricPrompt API for enhanced security",
                    "Implement hardware-backed biometric authentication when available",
                    "Add fallback authentication mechanisms for critical operations"
                ])
            
        elif 'storage' in title or 'sqlite' in title:
            recommendations.extend([
                "Implement database encryption using SQLCipher",
                "Use secure keystore solutions for key management",
                "Avoid storing sensitive data in unencrypted databases"
            ])
            
        elif 'network' in title or 'cleartext' in title:
            recommendations.extend([
                "Implement Network Security Configuration to block cleartext traffic",
                "Use HTTPS for all network communications",
                "Implement certificate pinning for critical endpoints"
            ])
            
        elif 'platform usage' in title or 'exported' in title:
            # Extract component count for specific recommendations
            import re
            exported_match = re.search(r'exported components:?\s*(\d+)', description)
            if exported_match:
                count = int(exported_match.group(1))
                if count > 5:
                    recommendations.append(f"Review and reduce {count} exported components to minimum required")
                else:
                    recommendations.append("Review necessity of each exported component")
            
            recommendations.extend([
                "Add permission checks to exported Activities and Services",
                "Implement input validation for Intent data",
                "Use signature-level permissions for sensitive operations"
            ])
            
        elif 'sql injection' in title:
            recommendations.extend([
                "Use parameterized queries instead of string concatenation",
                "Implement proper input validation and sanitization",
                "Consider using Room database with compile-time validation"
            ])
            
        elif 'debuggable' in title:
            recommendations.extend([
                "Disable debug flags in production builds",
                "Implement build variant-specific configurations",
                "Add runtime debug detection and protection"
            ])
        
        # CWE-specific recommendations
        if 'CWE-287' in cwe_id:  # Improper Authentication
            recommendations.extend([
                "Implement multi-factor authentication for sensitive operations",
                "Use secure session management with proper timeout"
            ])
        elif 'CWE-200' in cwe_id:  # Information Exposure
            recommendations.extend([
                "Remove sensitive information from logs and error messages",
                "Implement proper exception handling without information leakage"
            ])
        
        # Severity-based recommendations
        if severity in ['HIGH', 'CRITICAL']:
            recommendations.insert(0, "Prioritize immediate remediation due to high severity")
        
        # Ensure minimum recommendation count
        if len(recommendations) < self.config.recommendation_min_count:
            recommendations.extend([
                "Follow OWASP Mobile Security Testing Guide recommendations",
                "Conduct security code review and testing",
                "Implement appropriate security controls for this vulnerability type"
            ])
        
        return recommendations[:8]  # Limit to 8 recommendations for readability
    
    def _apply_ml_enhancement(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Apply ML enhancement to vulnerabilities with low confidence."""
        enhanced_vulns = []
        
        for vuln in vulnerabilities:
            enhanced_vuln = vuln.copy()
            confidence = vuln.get('confidence', 0.5)
            
            # Apply ML enhancement to low-confidence findings
            if confidence < self.config.ml_confidence_threshold:
                try:
                    ml_result = self.ml_detector.detect_vulnerabilities(
                        content=vuln.get('description', ''),
                        title=vuln.get('title', ''),
                        context=vuln
                    )
                    
                    if ml_result.confidence > confidence:
                        enhanced_vuln.update({
                            'ml_enhanced': True,
                            'confidence': ml_result.confidence,
                            'ml_evidence': ml_result.evidence,
                            'ml_enhancement_type': 'confidence_boost'
                        })
                    else:
                        enhanced_vuln['ml_enhanced'] = True
                        enhanced_vuln['ml_enhancement_type'] = 'analyzed_no_boost'
                        
                except Exception as e:
                    self.logger.warning(f"ML enhancement failed for vulnerability {vuln.get('title', 'Unknown')}: {e}")
                    enhanced_vuln['ml_enhanced'] = False
            
            enhanced_vulns.append(enhanced_vuln)
        
        return enhanced_vulns
    
    def _apply_smart_filtering(self, vulnerabilities: List[Dict[str, Any]], 
                             scan_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Apply smart filtering to reduce false positives."""
        try:
            result = self.smart_filter_func(
                findings=vulnerabilities,
                scan_context=scan_context
            )
            
            filtered_vulns = result.get('filtered_findings', vulnerabilities)
            filter_stats = result.get('filtering_stats', {})
            
            if filter_stats:
                self.logger.info(f"Smart filtering: {filter_stats}")
            
            return filtered_vulns
            
        except Exception as e:
            self.logger.warning(f"Smart filtering failed: {e}")
            return vulnerabilities
    
    def _log_enhancement_stats(self, stats: Dict[str, int]):
        """Log enhancement statistics."""
        total = stats['total_vulnerabilities']
        
        self.logger.info(f"ðŸŽ¯ Vulnerability Enhancement Complete:")
        self.logger.info(f"   ðŸ“Š Total vulnerabilities: {total}")
        
        if stats.get('organic_code_added', 0) > 0:
            pct = (stats['organic_code_added'] / total) * 100
            self.logger.info(f"   ðŸ§¬ Organic code snippets added: {stats['organic_code_added']} ({pct:.1f}%)")
        
        if stats['recommendations_added'] > 0:
            pct = (stats['recommendations_added'] / total) * 100
            self.logger.info(f"   ðŸ’¡ Recommendations added: {stats['recommendations_added']} ({pct:.1f}%)")
        
        if stats['ml_enhanced'] > 0:
            pct = (stats['ml_enhanced'] / total) * 100
            self.logger.info(f"   ðŸ¤– ML enhanced: {stats['ml_enhanced']} ({pct:.1f}%)")
        
        if stats['filtered_count'] > 0:
            pct = (stats['filtered_count'] / total) * 100
            self.logger.info(f"   ðŸ” False positives filtered: {stats['filtered_count']} ({pct:.1f}%)")

def enhance_aods_vulnerabilities(vulnerabilities: List[Dict[str, Any]], 
                               scan_context: Dict[str, Any],
                               disable_ml: bool = False,
                               decompiled_path: Optional[str] = None) -> List[Dict[str, Any]]:
    """
    Convenience function for integrating vulnerability enhancement into AODS workflow.
    
    Args:
        vulnerabilities: List of vulnerability dictionaries from AODS scan
        scan_context: Context information (scan_type, package_name, etc.)
        disable_ml: Whether to disable ML enhancement
        decompiled_path: Path to decompiled APK sources for organic code extraction
        
    Returns:
        Enhanced vulnerabilities with organic code snippets, recommendations, ML analysis, and filtering
    """
    config = EnhancementConfig()
    config.enable_ml_enhancement = not disable_ml
    
    enhancer = AODSVulnerabilityEnhancer(config, decompiled_path)
    return enhancer.enhance_vulnerabilities(vulnerabilities, scan_context)
