#!/usr/bin/env python3
"""
Runtime Vulnerability Detection Patterns

Comprehensive pattern system for detecting security vulnerabilities during dynamic 
application execution. Unlike static analysis patterns that examine code structure,
these patterns monitor runtime behavior, API calls, data flows, and execution patterns
to identify security issues as they occur.

Core Features:
- Runtime behavior pattern matching for API calls and data flows
- Configurable detection rules without hardcoded vulnerability signatures
- Integration with Dynamic Analysis Coordinator for orchestrated detection
- Support for Frida-based instrumentation and monitoring engines
- Intelligent confidence scoring based on runtime evidence

Pattern Categories:
- Network Security: Insecure communications, certificate validation bypasses
- Data Protection: Sensitive data exposure, insecure storage operations
- Authentication: Weak authentication mechanisms, session management issues
- Cryptographic: Weak encryption usage, key management vulnerabilities
- Input Validation: Injection vulnerabilities, input sanitization bypasses
- Platform Security: Privilege escalation, platform API misuse
"""

import logging
import re
import time
from datetime import datetime
from typing import Dict, List, Any, Optional, Set, Callable, Union
from dataclasses import dataclass, field
from enum import Enum
from abc import ABC, abstractmethod


class RuntimePatternType(Enum):
    """Categories of runtime vulnerability patterns."""
    NETWORK_SECURITY = "network_security"
    DATA_PROTECTION = "data_protection"
    AUTHENTICATION = "authentication"
    CRYPTOGRAPHIC = "cryptographic"
    INPUT_VALIDATION = "input_validation"
    PLATFORM_SECURITY = "platform_security"
    BEHAVIORAL_ANOMALY = "behavioral_anomaly"
    WEBVIEW_SECURITY = "webview_security"
    DATABASE_SECURITY = "database_security"
    IPC_SECURITY = "ipc_security"
    PERMISSION_SECURITY = "permission_security"


class RuntimePatternSeverity(Enum):
    """Severity levels for runtime vulnerability patterns."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class RuntimeDetectionTrigger(Enum):
    """Triggers that activate runtime pattern detection."""
    API_CALL = "api_call"
    NETWORK_REQUEST = "network_request"
    FILE_OPERATION = "file_operation"
    DATABASE_QUERY = "database_query"
    CRYPTO_OPERATION = "crypto_operation"
    PERMISSION_REQUEST = "permission_request"
    INTENT_PROCESSING = "intent_processing"
    MEMORY_OPERATION = "memory_operation"


@dataclass
class RuntimeEvidence:
    """Evidence collected during runtime pattern detection."""
    trigger_type: RuntimeDetectionTrigger
    timestamp: float
    api_signature: Optional[str] = None
    parameters: Dict[str, Any] = field(default_factory=dict)
    return_value: Any = None
    stack_trace: List[str] = field(default_factory=list)
    memory_context: Dict[str, Any] = field(default_factory=dict)
    network_context: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if self.timestamp <= 0:
            self.timestamp = time.time()


@dataclass 
class RuntimePatternMatch:
    """Represents a successful runtime pattern match."""
    pattern_id: str
    pattern_name: str
    severity: RuntimePatternSeverity
    confidence: float
    evidence: List[RuntimeEvidence]
    description: str
    cwe_id: Optional[str] = None
    masvs_category: Optional[str] = None
    remediation_guidance: str = ""
    timestamp: float = field(default_factory=time.time)
    
    def __post_init__(self):
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")


@dataclass
class RuntimeVulnerabilityPattern:
    """
    Defines a runtime vulnerability detection pattern.
    
    Unlike static patterns that examine code, runtime patterns monitor execution
    behavior to detect vulnerabilities as they manifest during app operation.
    """
    
    # Core identification
    pattern_id: str
    pattern_name: str
    pattern_type: RuntimePatternType
    severity: RuntimePatternSeverity
    
    # Detection configuration
    detection_triggers: List[RuntimeDetectionTrigger]
    api_signatures: List[str] = field(default_factory=list)
    parameter_patterns: Dict[str, str] = field(default_factory=dict)
    behavioral_indicators: List[str] = field(default_factory=list)
    
    # Vulnerability classification
    cwe_id: Optional[str] = None
    masvs_category: Optional[str] = None
    owasp_category: Optional[str] = None
    description: str = ""
    remediation_guidance: str = ""
    
    # Detection logic
    detection_logic: Optional[Callable] = None
    confidence_calculator: Optional[Callable] = None
    false_positive_filters: List[str] = field(default_factory=list)
    
    # Pattern metadata
    base_confidence: float = 0.7
    requires_network: bool = False
    requires_filesystem: bool = False
    requires_crypto: bool = False
    requires_permissions: List[str] = field(default_factory=list)
    
    # Learning and adaptation
    learning_enabled: bool = True
    adaptation_weight: float = 0.1
    usage_count: int = 0
    false_positive_count: int = 0
    true_positive_count: int = 0
    last_updated: datetime = field(default_factory=datetime.now)
    
    def __post_init__(self):
        """Validate pattern configuration."""
        if not 0.0 <= self.base_confidence <= 1.0:
            raise ValueError(f"Base confidence must be between 0.0 and 1.0")
        
        if self.cwe_id and not self.cwe_id.startswith("CWE-"):
            self.cwe_id = f"CWE-{self.cwe_id}"
    
    def calculate_confidence(self, evidence: List[RuntimeEvidence]) -> float:
        """Calculate pattern match confidence based on runtime evidence."""
        if self.confidence_calculator:
            return self.confidence_calculator(evidence, self)
        
        # Default confidence calculation
        base_confidence = self.base_confidence
        evidence_boost = min(0.3, len(evidence) * 0.05)
        
        # Adjust for pattern learning
        if self.usage_count > 0:
            accuracy = self.true_positive_count / (self.true_positive_count + self.false_positive_count + 1)
            learning_adjustment = (accuracy - 0.5) * self.adaptation_weight
            base_confidence += learning_adjustment
        
        return min(1.0, max(0.0, base_confidence + evidence_boost))
    
    def matches_runtime_behavior(self, evidence: RuntimeEvidence) -> bool:
        """Check if runtime evidence matches this pattern."""
        if self.detection_logic:
            return self.detection_logic(evidence, self)
        
        # Default matching logic
        if evidence.trigger_type not in self.detection_triggers:
            return False
        
        # Check API signature matches
        if self.api_signatures and evidence.api_signature:
            api_match = any(
                re.search(pattern, evidence.api_signature, re.IGNORECASE)
                for pattern in self.api_signatures
            )
            if not api_match:
                return False
        
        # Check parameter patterns
        for param_name, pattern in self.parameter_patterns.items():
            if param_name in evidence.parameters:
                param_value = str(evidence.parameters[param_name])
                if not re.search(pattern, param_value, re.IGNORECASE):
                    return False
        
        return True


class RuntimePatternDetector:
    """
    Core engine for runtime vulnerability pattern detection.
    
    Monitors application execution and applies vulnerability patterns to detect
    security issues during runtime. Integrates with Dynamic Analysis Coordinator
    and various monitoring engines.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize runtime pattern detector."""
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        
        # Pattern management
        self.active_patterns: Dict[str, RuntimeVulnerabilityPattern] = {}
        self.pattern_matches: List[RuntimePatternMatch] = []
        
        # Detection state
        self.detection_active = False
        self.evidence_buffer: List[RuntimeEvidence] = []
        self.max_evidence_buffer = self.config.get('max_evidence_buffer', 1000)
        
        # Performance tracking
        self.detection_stats = {
            'patterns_checked': 0,
            'matches_found': 0,
            'false_positives': 0,
            'detection_time_ms': 0.0
        }
    
    def load_patterns(self, patterns: List[RuntimeVulnerabilityPattern]):
        """Load runtime vulnerability patterns for detection."""
        for pattern in patterns:
            self.active_patterns[pattern.pattern_id] = pattern
            self.logger.debug(f"Loaded runtime pattern: {pattern.pattern_name}")
        
        self.logger.info(f"Loaded {len(patterns)} runtime vulnerability patterns")
    
    def add_runtime_evidence(self, evidence: RuntimeEvidence):
        """Add runtime evidence for pattern analysis."""
        self.evidence_buffer.append(evidence)
        
        # Maintain buffer size
        if len(self.evidence_buffer) > self.max_evidence_buffer:
            self.evidence_buffer = self.evidence_buffer[-self.max_evidence_buffer:]
        
        # Immediate pattern checking for real-time detection
        if self.detection_active:
            self._check_patterns_for_evidence(evidence)
    
    def _check_patterns_for_evidence(self, evidence: RuntimeEvidence):
        """Check all active patterns against new evidence."""
        start_time = time.time()
        
        for pattern_id, pattern in self.active_patterns.items():
            self.detection_stats['patterns_checked'] += 1
            
            try:
                if pattern.matches_runtime_behavior(evidence):
                    # Collect related evidence for confidence calculation
                    related_evidence = self._collect_related_evidence(pattern, evidence)
                    confidence = pattern.calculate_confidence(related_evidence)
                    
                    # Create pattern match
                    match = RuntimePatternMatch(
                        pattern_id=pattern_id,
                        pattern_name=pattern.pattern_name,
                        severity=pattern.severity,
                        confidence=confidence,
                        evidence=related_evidence,
                        description=pattern.description,
                        cwe_id=pattern.cwe_id,
                        masvs_category=pattern.masvs_category,
                        remediation_guidance=pattern.remediation_guidance
                    )
                    
                    self.pattern_matches.append(match)
                    self.detection_stats['matches_found'] += 1
                    pattern.usage_count += 1
                    
                    self.logger.info(f"Runtime vulnerability detected: {pattern.pattern_name} "
                                   f"(confidence: {confidence:.2f})")
                    
            except Exception as e:
                self.logger.error(f"Error checking pattern {pattern_id}: {e}")
        
        detection_time = (time.time() - start_time) * 1000
        self.detection_stats['detection_time_ms'] += detection_time
    
    def _collect_related_evidence(self, pattern: RuntimeVulnerabilityPattern, 
                                current_evidence: RuntimeEvidence) -> List[RuntimeEvidence]:
        """Collect evidence related to a pattern match for confidence calculation."""
        related_evidence = [current_evidence]
        
        # Look for related evidence in recent buffer
        time_window = 30.0  # 30 second window
        current_time = current_evidence.timestamp
        
        for evidence in reversed(self.evidence_buffer):
            if current_time - evidence.timestamp > time_window:
                break
            
            if evidence != current_evidence and self._is_evidence_related(pattern, evidence):
                related_evidence.append(evidence)
                
                # Limit related evidence to prevent performance impact
                if len(related_evidence) >= 10:
                    break
        
        return related_evidence
    
    def _is_evidence_related(self, pattern: RuntimeVulnerabilityPattern, 
                           evidence: RuntimeEvidence) -> bool:
        """Check if evidence is related to a pattern."""
        # Evidence is related if it shares triggers or API signatures
        if evidence.trigger_type in pattern.detection_triggers:
            return True
        
        if pattern.api_signatures and evidence.api_signature:
            for api_pattern in pattern.api_signatures:
                if re.search(api_pattern, evidence.api_signature, re.IGNORECASE):
                    return True
        
        return False
    
    def start_detection(self):
        """Start runtime pattern detection."""
        self.detection_active = True
        self.logger.info("Runtime vulnerability pattern detection started")
    
    def stop_detection(self):
        """Stop runtime pattern detection."""
        self.detection_active = False
        self.logger.info("Runtime vulnerability pattern detection stopped")
    
    def get_detection_results(self) -> Dict[str, Any]:
        """Get comprehensive detection results."""
        return {
            'pattern_matches': self.pattern_matches,
            'detection_stats': self.detection_stats.copy(),
            'active_patterns': len(self.active_patterns),
            'evidence_collected': len(self.evidence_buffer),
            'detection_active': self.detection_active
        }
    
    def clear_results(self):
        """Clear detection results and reset state."""
        self.pattern_matches.clear()
        self.evidence_buffer.clear()
        self.detection_stats = {key: 0 if isinstance(value, (int, float)) else value 
                              for key, value in self.detection_stats.items()}


class RuntimePatternLibrary:
    """
    Library of predefined runtime vulnerability patterns.
    
    Provides a comprehensive collection of runtime vulnerability detection patterns
    covering common security issues that manifest during application execution.
    """
    
    @staticmethod
    def get_network_security_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Network security vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="net_insecure_http",
                pattern_name="Insecure HTTP Communication",
                pattern_type=RuntimePatternType.NETWORK_SECURITY,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.NETWORK_REQUEST],
                api_signatures=[r"http://.*", r"HttpURLConnection.*http://"],
                description="Application communicating over unencrypted HTTP protocol",
                cwe_id="CWE-319",
                masvs_category="MSTG-NETWORK-1",
                remediation_guidance="Use HTTPS for all network communications",
                base_confidence=0.9,
                requires_network=True
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="net_cert_bypass",
                pattern_name="Certificate Validation Bypass",
                pattern_type=RuntimePatternType.NETWORK_SECURITY,
                severity=RuntimePatternSeverity.CRITICAL,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"setHostnameVerifier.*ALLOW_ALL",
                    r"TrustManager.*checkServerTrusted",
                    r"X509TrustManager.*"
                ],
                behavioral_indicators=["certificate_bypass", "trust_all_certificates"],
                description="Application bypassing SSL certificate validation",
                cwe_id="CWE-295",
                masvs_category="MSTG-NETWORK-3",
                remediation_guidance="Implement proper certificate validation",
                base_confidence=0.95,
                requires_network=True
            )
        ]
    
    @staticmethod
    def get_data_protection_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Data protection vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="data_external_storage",
                pattern_name="Sensitive Data in External Storage",
                pattern_type=RuntimePatternType.DATA_PROTECTION,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.FILE_OPERATION],
                api_signatures=[
                    r"getExternalStorageDirectory",
                    r"Environment\.getExternalStorageDirectory",
                    r"openFileOutput.*MODE_WORLD_READABLE"
                ],
                parameter_patterns={
                    "filename": r".*(password|token|secret|key|private).*",
                    "data": r".*(password|token|secret|key|private).*"
                },
                description="Sensitive data being written to external storage",
                cwe_id="CWE-200",
                masvs_category="MSTG-STORAGE-2",
                remediation_guidance="Store sensitive data in internal app storage with proper encryption",
                base_confidence=0.8,
                requires_filesystem=True
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="data_logging_sensitive",
                pattern_name="Sensitive Data in Logs",
                pattern_type=RuntimePatternType.DATA_PROTECTION,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"Log\.[dievw]",
                    r"System\.out\.print",
                    r"System\.err\.print"
                ],
                parameter_patterns={
                    "message": r".*(password|token|secret|key|private|ssn|credit.*card).*"
                },
                description="Sensitive information being logged",
                cwe_id="CWE-532",
                masvs_category="MSTG-CODE-10",
                remediation_guidance="Remove sensitive data from log outputs",
                base_confidence=0.7
            )
        ]
    
    @staticmethod
    def get_cryptographic_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Cryptographic vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="crypto_weak_cipher",
                pattern_name="Weak Cryptographic Cipher",
                pattern_type=RuntimePatternType.CRYPTOGRAPHIC,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.CRYPTO_OPERATION],
                api_signatures=[r"Cipher\.getInstance"],
                parameter_patterns={
                    "transformation": r".*(DES|RC4|MD5|SHA1).*"
                },
                description="Application using weak cryptographic algorithms",
                cwe_id="CWE-327",
                masvs_category="MSTG-CRYPTO-4",
                remediation_guidance="Use strong cryptographic algorithms (AES, SHA-256, etc.)",
                base_confidence=0.9,
                requires_crypto=True
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="crypto_hardcoded_key",
                pattern_name="Hardcoded Cryptographic Key",
                pattern_type=RuntimePatternType.CRYPTOGRAPHIC,
                severity=RuntimePatternSeverity.CRITICAL,
                detection_triggers=[RuntimeDetectionTrigger.CRYPTO_OPERATION],
                api_signatures=[r"SecretKeySpec", r"KeySpec"],
                parameter_patterns={
                    "key": r"^[a-fA-F0-9]{16,}$|^[A-Za-z0-9+/=]{16,}$"
                },
                description="Hardcoded cryptographic key detected in runtime",
                cwe_id="CWE-798",
                masvs_category="MSTG-CRYPTO-1",
                remediation_guidance="Generate keys dynamically or use secure key storage",
                base_confidence=0.85,
                requires_crypto=True
            )
        ]
    
    @staticmethod
    def get_authentication_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Authentication and session management vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="auth_weak_session",
                pattern_name="Weak Session Management",
                pattern_type=RuntimePatternType.AUTHENTICATION,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"SharedPreferences.*edit.*putString.*session",
                    r"getSharedPreferences.*session",
                    r"cookie.*expires.*"
                ],
                parameter_patterns={
                    "session_id": r"^[a-zA-Z0-9]{1,8}$"  # Short session IDs
                },
                description="Weak session management implementation detected",
                cwe_id="CWE-384",
                masvs_category="MSTG-AUTH-2",
                remediation_guidance="Implement secure session management with proper expiration",
                base_confidence=0.8
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="auth_hardcoded_credentials",
                pattern_name="Hardcoded Authentication Credentials",
                pattern_type=RuntimePatternType.AUTHENTICATION,
                severity=RuntimePatternSeverity.CRITICAL,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"authenticate.*password",
                    r"login.*username.*password",
                    r"setPassword"
                ],
                parameter_patterns={
                    "password": r"^(admin|password|123456|test|default)$",
                    "username": r"^(admin|root|test|user)$"
                },
                description="Hardcoded authentication credentials detected",
                cwe_id="CWE-798",
                masvs_category="MSTG-AUTH-1",
                remediation_guidance="Remove hardcoded credentials, use secure authentication",
                base_confidence=0.95
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="auth_biometric_bypass",
                pattern_name="Biometric Authentication Bypass",
                pattern_type=RuntimePatternType.AUTHENTICATION,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"BiometricPrompt.*setAllowedAuthenticators.*BIOMETRIC_WEAK",
                    r"FingerprintManager.*authenticate.*null"
                ],
                description="Biometric authentication configured with weak security",
                cwe_id="CWE-287",
                masvs_category="MSTG-AUTH-8",
                remediation_guidance="Use strong biometric authentication settings",
                base_confidence=0.85
            )
        ]
    
    @staticmethod
    def get_input_validation_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Input validation vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="input_sql_injection",
                pattern_name="SQL Injection Vulnerability",
                pattern_type=RuntimePatternType.INPUT_VALIDATION,
                severity=RuntimePatternSeverity.CRITICAL,
                detection_triggers=[RuntimeDetectionTrigger.DATABASE_QUERY],
                api_signatures=[
                    r"rawQuery.*SELECT.*\+",
                    r"execSQL.*\+.*",
                    r"query.*selection.*\+"
                ],
                parameter_patterns={
                    "query": r".*(union|select|insert|delete|drop|update).*\+.*"
                },
                description="SQL injection vulnerability in database operations",
                cwe_id="CWE-89",
                masvs_category="MSTG-CODE-8",
                remediation_guidance="Use parameterized queries and input validation",
                base_confidence=0.9
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="input_path_traversal",
                pattern_name="Path Traversal Vulnerability",
                pattern_type=RuntimePatternType.INPUT_VALIDATION,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.FILE_OPERATION],
                api_signatures=[
                    r"openFileInput",
                    r"FileInputStream",
                    r"File\("
                ],
                parameter_patterns={
                    "filename": r".*\.\./.*|.*\\\.\\\.\\.*"
                },
                description="Path traversal vulnerability in file operations",
                cwe_id="CWE-22",
                masvs_category="MSTG-PLATFORM-6",
                remediation_guidance="Validate and sanitize file paths",
                base_confidence=0.85,
                requires_filesystem=True
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="input_url_validation",
                pattern_name="URL Scheme Validation Bypass",
                pattern_type=RuntimePatternType.INPUT_VALIDATION,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"Intent.*setData.*Uri\.parse",
                    r"startActivity.*intent"
                ],
                parameter_patterns={
                    "url": r"^(javascript|file|content|android_asset):"
                },
                description="Dangerous URL scheme accepted without validation",
                cwe_id="CWE-20",
                masvs_category="MSTG-PLATFORM-11",
                remediation_guidance="Validate URL schemes and implement allowlists",
                base_confidence=0.7
            )
        ]
    
    @staticmethod
    def get_platform_security_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Platform-specific security vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="platform_root_detection_bypass",
                pattern_name="Root Detection Bypass",
                pattern_type=RuntimePatternType.PLATFORM_SECURITY,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"su",
                    r"/system/bin/su",
                    r"Superuser\.apk",
                    r"RootTools"
                ],
                description="Root detection mechanisms bypassed or missing",
                cwe_id="CWE-693",
                masvs_category="MSTG-RESILIENCE-1",
                remediation_guidance="Implement robust root detection",
                base_confidence=0.6
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="platform_debug_enabled",
                pattern_name="Debug Mode Enabled in Production",
                pattern_type=RuntimePatternType.PLATFORM_SECURITY,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"ApplicationInfo\.FLAG_DEBUGGABLE",
                    r"BuildConfig\.DEBUG.*true"
                ],
                description="Debug mode enabled in production application",
                cwe_id="CWE-489",
                masvs_category="MSTG-CODE-2",
                remediation_guidance="Disable debug mode in production builds",
                base_confidence=0.9
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="platform_backup_enabled",
                pattern_name="Application Backup Enabled",
                pattern_type=RuntimePatternType.PLATFORM_SECURITY,
                severity=RuntimePatternSeverity.LOW,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"allowBackup.*true",
                    r"BackupManager"
                ],
                description="Application backup enabled, potential data exposure",
                cwe_id="CWE-200",
                masvs_category="MSTG-STORAGE-8",
                remediation_guidance="Disable application backup for sensitive apps",
                base_confidence=0.7
            )
        ]
    
    @staticmethod
    def get_webview_security_patterns() -> List[RuntimeVulnerabilityPattern]:
        """WebView security vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="webview_javascript_enabled",
                pattern_name="WebView JavaScript Execution Enabled",
                pattern_type=RuntimePatternType.WEBVIEW_SECURITY,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"WebSettings.*setJavaScriptEnabled.*true",
                    r"addJavascriptInterface"
                ],
                description="WebView JavaScript execution enabled without proper controls",
                cwe_id="CWE-79",
                masvs_category="MSTG-PLATFORM-7",
                remediation_guidance="Disable JavaScript or implement proper controls",
                base_confidence=0.8
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="webview_file_access",
                pattern_name="WebView File Access Enabled",
                pattern_type=RuntimePatternType.WEBVIEW_SECURITY,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"setAllowFileAccess.*true",
                    r"setAllowFileAccessFromFileURLs.*true"
                ],
                description="WebView file access enabled, potential local file disclosure",
                cwe_id="CWE-200",
                masvs_category="MSTG-PLATFORM-7",
                remediation_guidance="Disable file access in WebView settings",
                base_confidence=0.85
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="webview_mixed_content",
                pattern_name="WebView Mixed Content Allowed",
                pattern_type=RuntimePatternType.WEBVIEW_SECURITY,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"setMixedContentMode.*MIXED_CONTENT_ALWAYS_ALLOW"
                ],
                description="WebView allows mixed HTTP/HTTPS content",
                cwe_id="CWE-319",
                masvs_category="MSTG-NETWORK-1",
                remediation_guidance="Restrict mixed content in WebView",
                base_confidence=0.8
            )
        ]
    
    @staticmethod
    def get_database_security_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Database security vulnerability patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="db_unencrypted_database",
                pattern_name="Unencrypted Database Storage",
                pattern_type=RuntimePatternType.DATABASE_SECURITY,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.DATABASE_QUERY],
                api_signatures=[
                    r"SQLiteOpenHelper",
                    r"openOrCreateDatabase"
                ],
                behavioral_indicators=["database_created", "no_encryption"],
                description="Database created without encryption",
                cwe_id="CWE-311",
                masvs_category="MSTG-STORAGE-1",
                remediation_guidance="Use encrypted database storage (SQLCipher)",
                base_confidence=0.7
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="db_world_readable",
                pattern_name="World-Readable Database",
                pattern_type=RuntimePatternType.DATABASE_SECURITY,
                severity=RuntimePatternSeverity.CRITICAL,
                detection_triggers=[RuntimeDetectionTrigger.DATABASE_QUERY],
                api_signatures=[
                    r"openOrCreateDatabase.*MODE_WORLD_READABLE"
                ],
                description="Database created with world-readable permissions",
                cwe_id="CWE-732",
                masvs_category="MSTG-STORAGE-2",
                remediation_guidance="Use private database permissions",
                base_confidence=0.95
            )
        ]
    
    @staticmethod
    def get_ipc_security_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Inter-Process Communication security patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="ipc_exported_component",
                pattern_name="Exported Component Without Protection",
                pattern_type=RuntimePatternType.IPC_SECURITY,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"startActivity.*Intent",
                    r"sendBroadcast",
                    r"bindService"
                ],
                behavioral_indicators=["exported_component", "no_permission"],
                description="Exported component accessible without proper protection",
                cwe_id="CWE-200",
                masvs_category="MSTG-PLATFORM-1",
                remediation_guidance="Add permission protection to exported components",
                base_confidence=0.8
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="ipc_intent_hijacking",
                pattern_name="Intent Hijacking Vulnerability",
                pattern_type=RuntimePatternType.IPC_SECURITY,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"startActivity.*new Intent\(\)",
                    r"sendBroadcast.*new Intent\(\)"
                ],
                parameter_patterns={
                    "action": r"^android\.intent\.action\..*"
                },
                description="Implicit intent usage susceptible to hijacking",
                cwe_id="CWE-924",
                masvs_category="MSTG-PLATFORM-1",
                remediation_guidance="Use explicit intents when possible",
                base_confidence=0.6
            )
        ]
    
    @staticmethod
    def get_permission_security_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Permission and privacy security patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="perm_dangerous_permissions",
                pattern_name="Dangerous Permission Usage",
                pattern_type=RuntimePatternType.PERMISSION_SECURITY,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"requestPermissions",
                    r"checkSelfPermission"
                ],
                parameter_patterns={
                    "permission": r".*(CAMERA|MICROPHONE|LOCATION|READ_CONTACTS|READ_SMS).*"
                },
                description="Dangerous permissions requested without clear justification",
                cwe_id="CWE-250",
                masvs_category="MSTG-PLATFORM-1",
                remediation_guidance="Minimize permission requests and provide clear justification",
                base_confidence=0.5
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="perm_location_tracking",
                pattern_name="Excessive Location Tracking",
                pattern_type=RuntimePatternType.PERMISSION_SECURITY,
                severity=RuntimePatternSeverity.MEDIUM,
                detection_triggers=[RuntimeDetectionTrigger.API_CALL],
                api_signatures=[
                    r"LocationManager.*requestLocationUpdates",
                    r"FusedLocationProviderClient.*requestLocationUpdates"
                ],
                parameter_patterns={
                    "interval": r"^[0-9]{1,4}$"  # Very short intervals
                },
                description="Excessive location tracking with high frequency",
                cwe_id="CWE-200",
                masvs_category="MSTG-PLATFORM-1",
                remediation_guidance="Reduce location tracking frequency and duration",
                base_confidence=0.7
            )
        ]
    
    @staticmethod
    def get_behavioral_anomaly_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Behavioral anomaly detection patterns."""
        return [
            RuntimeVulnerabilityPattern(
                pattern_id="behavior_excessive_network",
                pattern_name="Excessive Network Activity",
                pattern_type=RuntimePatternType.BEHAVIORAL_ANOMALY,
                severity=RuntimePatternSeverity.LOW,
                detection_triggers=[RuntimeDetectionTrigger.NETWORK_REQUEST],
                behavioral_indicators=["high_frequency_requests", "data_exfiltration"],
                description="Unusually high network activity detected",
                cwe_id="CWE-200",
                masvs_category="MSTG-NETWORK-1",
                remediation_guidance="Review network usage patterns",
                base_confidence=0.4,
                requires_network=True
            ),
            
            RuntimeVulnerabilityPattern(
                pattern_id="behavior_memory_manipulation",
                pattern_name="Memory Manipulation Detected",
                pattern_type=RuntimePatternType.BEHAVIORAL_ANOMALY,
                severity=RuntimePatternSeverity.HIGH,
                detection_triggers=[RuntimeDetectionTrigger.MEMORY_OPERATION],
                api_signatures=[
                    r"Runtime\.getRuntime\(\)\.exec",
                    r"ProcessBuilder"
                ],
                behavioral_indicators=["memory_modification", "runtime_manipulation"],
                description="Runtime memory manipulation detected",
                cwe_id="CWE-94",
                masvs_category="MSTG-RESILIENCE-2",
                remediation_guidance="Implement anti-tampering measures",
                base_confidence=0.8
            )
        ]
    
    @staticmethod
    def get_all_patterns() -> List[RuntimeVulnerabilityPattern]:
        """Get all predefined runtime vulnerability patterns."""
        patterns = []
        patterns.extend(RuntimePatternLibrary.get_network_security_patterns())
        patterns.extend(RuntimePatternLibrary.get_data_protection_patterns())
        patterns.extend(RuntimePatternLibrary.get_cryptographic_patterns())
        patterns.extend(RuntimePatternLibrary.get_authentication_patterns())
        patterns.extend(RuntimePatternLibrary.get_input_validation_patterns())
        patterns.extend(RuntimePatternLibrary.get_platform_security_patterns())
        patterns.extend(RuntimePatternLibrary.get_webview_security_patterns())
        patterns.extend(RuntimePatternLibrary.get_database_security_patterns())
        patterns.extend(RuntimePatternLibrary.get_ipc_security_patterns())
        patterns.extend(RuntimePatternLibrary.get_permission_security_patterns())
        patterns.extend(RuntimePatternLibrary.get_behavioral_anomaly_patterns())
        return patterns


def create_runtime_pattern_detector(config: Optional[Dict[str, Any]] = None) -> RuntimePatternDetector:
    """Create and configure a runtime pattern detector with default patterns."""
    detector = RuntimePatternDetector(config)
    
    # Load all predefined patterns
    patterns = RuntimePatternLibrary.get_all_patterns()
    detector.load_patterns(patterns)
    
    return detector


def main():
    """Demonstration of runtime vulnerability pattern detection."""
    print("üîç Runtime Vulnerability Detection Patterns - Security Analysis")
    print("=" * 65)
    
    # Create detector with default patterns
    detector = create_runtime_pattern_detector()
    
    # Display loaded patterns
    print(f"Loaded {len(detector.active_patterns)} runtime vulnerability patterns")
    
    pattern_types = {}
    for pattern in detector.active_patterns.values():
        pattern_type = pattern.pattern_type.value
        pattern_types[pattern_type] = pattern_types.get(pattern_type, 0) + 1
    
    print("\nPattern Distribution:")
    for pattern_type, count in pattern_types.items():
        print(f"  - {pattern_type.replace('_', ' ').title()}: {count} patterns")
    
    print("\n‚úÖ Runtime Pattern Detection System Ready")
    print("\nCapabilities:")
    print("  - Real-time vulnerability detection during app execution")
    print("  - Configurable pattern matching with confidence scoring")
    print("  - Integration with Dynamic Analysis Coordinator")
    print("  - Evidence-based detection with false positive filtering")
    print("  - Learning and adaptation based on detection accuracy")


if __name__ == "__main__":
    main() 